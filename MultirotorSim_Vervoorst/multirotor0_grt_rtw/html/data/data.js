var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"Sim_Multi/multirotor","ref":false,"files":[{"name":"multirotor0.cpp","type":"source","group":"model","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * multirotor0.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"multirotor0.h\"\n#include \"rtwtypes.h\"\n#include <cmath>\n#include <cstring>\n#include \"multirotor0_private.h\"\n#include \"rt_defines.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/*\n * This function updates continuous states using the ODE3 fixed-step\n * solver algorithm\n */\nvoid multirotor0::rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  /* Solver Matrices */\n  static const real_T rt_ODE3_A[3]{\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3]{\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t { rtsiGetT(si) };\n\n  time_T tnew { rtsiGetSolverStopTime(si) };\n\n  time_T h { rtsiGetStepSize(si) };\n\n  real_T *x { rtsiGetContStates(si) };\n\n  ODE3_IntgData *id { static_cast<ODE3_IntgData *>(rtsiGetSolverData(si)) };\n\n  real_T *y { id->y };\n\n  real_T *f0 { id->f[0] };\n\n  real_T *f1 { id->f[1] };\n\n  real_T *f2 { id->f[2] };\n\n  real_T hB[3];\n  int_T i;\n  int_T nXc { 21 };\n\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  /* Save the state values at time t in y, we'll use x as ynew. */\n  (void) std::memcpy(y, x,\n                     static_cast<uint_T>(nXc)*sizeof(real_T));\n\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n  /* f0 = f(t,y) */\n  rtsiSetdX(si, f0);\n  multirotor0_derivatives();\n\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  this->step0();\n  multirotor0_derivatives();\n\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  this->step0();\n  multirotor0_derivatives();\n\n  /* tnew = t + hA(3);\n     ynew = y + f*hB(:,3); */\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (std::isnan(u0) || std::isnan(u1)) {\n    y = (rtNaN);\n  } else if (std::isinf(u0) && std::isinf(u1)) {\n    int32_T tmp;\n    int32_T tmp_0;\n    if (u0 > 0.0) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u1 > 0.0) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = std::atan2(static_cast<real_T>(tmp), static_cast<real_T>(tmp_0));\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = std::atan2(u0, u1);\n  }\n\n  return y;\n}\n\nvoid rt_mldivide_U1d3x3_U2d_JBYZyA3A(const real_T u0[9], const real_T u1[3],\n  real_T y[3])\n{\n  real_T A[9];\n  real_T a21;\n  real_T maxval;\n  int32_T r1;\n  int32_T r2;\n  int32_T r3;\n  std::memcpy(&A[0], &u0[0], 9U * sizeof(real_T));\n  r1 = 0;\n  r2 = 1;\n  r3 = 2;\n  maxval = std::abs(u0[0]);\n  a21 = std::abs(u0[1]);\n  if (a21 > maxval) {\n    maxval = a21;\n    r1 = 1;\n    r2 = 0;\n  }\n\n  if (std::abs(u0[2]) > maxval) {\n    r1 = 2;\n    r2 = 1;\n    r3 = 0;\n  }\n\n  A[r2] = u0[r2] / u0[r1];\n  A[r3] /= A[r1];\n  A[r2 + 3] -= A[r1 + 3] * A[r2];\n  A[r3 + 3] -= A[r1 + 3] * A[r3];\n  A[r2 + 6] -= A[r1 + 6] * A[r2];\n  A[r3 + 6] -= A[r1 + 6] * A[r3];\n  if (std::abs(A[r3 + 3]) > std::abs(A[r2 + 3])) {\n    int32_T rtemp;\n    rtemp = r2 + 1;\n    r2 = r3;\n    r3 = rtemp - 1;\n  }\n\n  A[r3 + 3] /= A[r2 + 3];\n  A[r3 + 6] -= A[r3 + 3] * A[r2 + 6];\n  y[1] = u1[r2] - u1[r1] * A[r2];\n  y[2] = (u1[r3] - u1[r1] * A[r3]) - A[r3 + 3] * y[1];\n  y[2] /= A[r3 + 6];\n  y[0] = u1[r1] - A[r1 + 6] * y[2];\n  y[1] -= A[r2 + 6] * y[2];\n  y[1] /= A[r2 + 3];\n  y[0] -= A[r1 + 3] * y[1];\n  y[0] /= A[r1];\n}\n\n/* Model step function for TID0 */\nvoid multirotor0::step0()              /* Sample time: [0.0s, 0.0s] */\n{\n  /* local scratch DWork variables */\n  int32_T ForEach_itr;\n  real_T Rz[36];\n  real_T COM_airframe[12];\n  real_T COM_propeller[12];\n  real_T d_y[12];\n  real_T rtb_ImpAsg_InsertedFor_Motor_fo[12];\n  real_T rtb_ImpAsg_InsertedFor_Motor_mo[12];\n  real_T y[12];\n  real_T I_airframe_total[9];\n  real_T I_propeller_cm[9];\n  real_T I_propeller_total[9];\n  real_T Product_tmp[9];\n  real_T d_propeller[9];\n  real_T rtb_VectorConcatenate[9];\n  real_T airframe_mass[4];\n  real_T propeller_mass[4];\n  real_T rtb_Divide[4];\n  real_T rtb_ImpAsg_InsertedFor_RPM_moto[4];\n  real_T rtb_Sum_a[3];\n  real_T rtb_TrueairspeedBodyaxes[3];\n  real_T rtb_TrueairspeedBodyaxes_b[3];\n  real_T rtb_TrueairspeedBodyaxes_m[3];\n  real_T COM_airframe_0;\n  real_T COM_airframe_1;\n  real_T COM_airframe_2;\n  real_T COM_airframe_3;\n  real_T COM_airframe_4;\n  real_T COM_airframe_5;\n  real_T COM_airframe_6;\n  real_T COM_airframe_7;\n  real_T COM_airframe_8;\n  real_T COM_airframe_9;\n  real_T COM_airframe_a;\n  real_T COM_airframe_b;\n  real_T COM_propeller_0;\n  real_T COM_propeller_1;\n  real_T COM_propeller_2;\n  real_T COM_propeller_3;\n  real_T COM_propeller_4;\n  real_T COM_propeller_5;\n  real_T COM_propeller_6;\n  real_T COM_system_inter_idx_0;\n  real_T COM_system_inter_idx_1;\n  real_T COM_system_inter_idx_2;\n  real_T cphi;\n  real_T ctheta;\n  real_T phi;\n  real_T q1;\n  real_T rtb_Airspeeddirectionintherot_0;\n  real_T rtb_VectorConcatenate_tmp;\n  real_T rtb_VectorConcatenate_tmp_0;\n  real_T rtb_VectorConcatenate_tmp_1;\n  real_T rtb_VectorConcatenate_tmp_2;\n  real_T rtb_VectorConcatenate_tmp_3;\n  real_T theta;\n  int32_T Rz_tmp;\n  int32_T i;\n  int32_T xpageoffset;\n  int8_T b_I[9];\n  int8_T rtAction;\n  if (rtmIsMajorTimeStep((&multirotor0_M))) {\n    /* set solver stop time */\n    rtsiSetSolverStopTime(&(&multirotor0_M)->solverInfo,(((&multirotor0_M)\n      ->Timing.clockTick0+1)*(&multirotor0_M)->Timing.stepSize0));\n\n    /* Update the flag to indicate when data transfers from\n     *  Sample time: [0.001s, 0.0s] to Sample time: [0.002s, 0.0s]  */\n    ((&multirotor0_M)->Timing.RateInteraction.TID1_2)++;\n    if (((&multirotor0_M)->Timing.RateInteraction.TID1_2) > 1) {\n      (&multirotor0_M)->Timing.RateInteraction.TID1_2 = 0;\n    }\n  }                                    /* end MajorTimeStep */\n\n  /* Update absolute time of base rate at minor time step */\n  if (rtmIsMinorTimeStep((&multirotor0_M))) {\n    (&multirotor0_M)->Timing.t[0] = rtsiGetT(&(&multirotor0_M)->solverInfo);\n  }\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  if (rtmIsMajorTimeStep((&multirotor0_M))) {\n    /* MATLAB Function: '<S8>/MATLAB Function' */\n    multirotor0_B.quat_output[0] = 1.0;\n    multirotor0_B.quat_output[1] = 0.0;\n    multirotor0_B.quat_output[2] = 0.0;\n    multirotor0_B.quat_output[3] = 0.0;\n  }\n\n  /* Integrator: '<S8>/Q-Integrator' */\n  if (multirotor0_DW.QIntegrator_IWORK != 0) {\n    multirotor0_X.QIntegrator_CSTATE[0] = multirotor0_B.quat_output[0];\n    multirotor0_X.QIntegrator_CSTATE[1] = multirotor0_B.quat_output[1];\n    multirotor0_X.QIntegrator_CSTATE[2] = multirotor0_B.quat_output[2];\n    multirotor0_X.QIntegrator_CSTATE[3] = multirotor0_B.quat_output[3];\n  }\n\n  /* Sqrt: '<S22>/Sqrt' incorporates:\n   *  Integrator: '<S8>/Q-Integrator'\n   *  Product: '<S23>/Product'\n   */\n  cphi = std::sqrt(((multirotor0_X.QIntegrator_CSTATE[0] *\n                     multirotor0_X.QIntegrator_CSTATE[0] +\n                     multirotor0_X.QIntegrator_CSTATE[1] *\n                     multirotor0_X.QIntegrator_CSTATE[1]) +\n                    multirotor0_X.QIntegrator_CSTATE[2] *\n                    multirotor0_X.QIntegrator_CSTATE[2]) +\n                   multirotor0_X.QIntegrator_CSTATE[3] *\n                   multirotor0_X.QIntegrator_CSTATE[3]);\n\n  /* Product: '<S19>/Divide' incorporates:\n   *  Integrator: '<S8>/Q-Integrator'\n   */\n  rtb_Divide[0] = multirotor0_X.QIntegrator_CSTATE[0] / cphi;\n  rtb_Divide[1] = multirotor0_X.QIntegrator_CSTATE[1] / cphi;\n  rtb_Divide[2] = multirotor0_X.QIntegrator_CSTATE[2] / cphi;\n  rtb_Divide[3] = multirotor0_X.QIntegrator_CSTATE[3] / cphi;\n\n  /* Product: '<S24>/Product' incorporates:\n   *  Product: '<S25>/Product'\n   */\n  rtb_VectorConcatenate_tmp_0 = rtb_Divide[0] * rtb_Divide[0];\n\n  /* Product: '<S24>/Product2' incorporates:\n   *  Product: '<S25>/Product2'\n   */\n  rtb_VectorConcatenate_tmp_1 = rtb_Divide[1] * rtb_Divide[1];\n\n  /* Product: '<S24>/Product3' incorporates:\n   *  Product: '<S25>/Product3'\n   *  Product: '<S26>/Product3'\n   */\n  cphi = rtb_Divide[2] * rtb_Divide[2];\n\n  /* Product: '<S24>/Product4' incorporates:\n   *  Product: '<S25>/Product4'\n   *  Product: '<S26>/Product4'\n   */\n  phi = rtb_Divide[3] * rtb_Divide[3];\n\n  /* Sum: '<S24>/Add' incorporates:\n   *  Fcn: '<S9>/Fcn4'\n   *  Product: '<S24>/Product'\n   *  Product: '<S24>/Product2'\n   *  Product: '<S24>/Product3'\n   *  Product: '<S24>/Product4'\n   */\n  rtb_VectorConcatenate_tmp_3 = ((rtb_VectorConcatenate_tmp_0 +\n    rtb_VectorConcatenate_tmp_1) - cphi) - phi;\n  rtb_VectorConcatenate[0] = rtb_VectorConcatenate_tmp_3;\n\n  /* Product: '<S29>/Product' incorporates:\n   *  Product: '<S27>/Product'\n   */\n  rtb_VectorConcatenate_tmp = rtb_Divide[1] * rtb_Divide[2];\n\n  /* Product: '<S29>/Product2' incorporates:\n   *  Product: '<S27>/Product2'\n   */\n  ctheta = rtb_Divide[0] * rtb_Divide[3];\n\n  /* Gain: '<S29>/Gain' incorporates:\n   *  Product: '<S29>/Product'\n   *  Product: '<S29>/Product2'\n   *  Sum: '<S29>/Add'\n   */\n  rtb_VectorConcatenate[1] = (rtb_VectorConcatenate_tmp - ctheta) * 2.0;\n\n  /* Product: '<S31>/Product' incorporates:\n   *  Product: '<S28>/Product'\n   */\n  rtb_VectorConcatenate_tmp_2 = rtb_Divide[1] * rtb_Divide[3];\n\n  /* Product: '<S31>/Product2' incorporates:\n   *  Product: '<S28>/Product2'\n   */\n  theta = rtb_Divide[0] * rtb_Divide[2];\n\n  /* Gain: '<S31>/Gain' incorporates:\n   *  Product: '<S31>/Product'\n   *  Product: '<S31>/Product2'\n   *  Sum: '<S31>/Add'\n   */\n  rtb_VectorConcatenate[2] = (rtb_VectorConcatenate_tmp_2 + theta) * 2.0;\n\n  /* Sum: '<S27>/Add' incorporates:\n   *  Fcn: '<S9>/Fcn2'\n   */\n  rtb_VectorConcatenate_tmp += ctheta;\n\n  /* Gain: '<S27>/Gain' incorporates:\n   *  Sum: '<S27>/Add'\n   */\n  rtb_VectorConcatenate[3] = rtb_VectorConcatenate_tmp * 2.0;\n\n  /* Sum: '<S25>/Add' incorporates:\n   *  Sum: '<S26>/Add'\n   */\n  rtb_VectorConcatenate_tmp_0 -= rtb_VectorConcatenate_tmp_1;\n  rtb_VectorConcatenate[4] = (rtb_VectorConcatenate_tmp_0 + cphi) - phi;\n\n  /* Product: '<S32>/Product' incorporates:\n   *  Product: '<S30>/Product'\n   */\n  rtb_VectorConcatenate_tmp_1 = rtb_Divide[2] * rtb_Divide[3];\n\n  /* Product: '<S32>/Product2' incorporates:\n   *  Product: '<S30>/Product2'\n   */\n  ctheta = rtb_Divide[0] * rtb_Divide[1];\n\n  /* Gain: '<S32>/Gain' incorporates:\n   *  Product: '<S32>/Product'\n   *  Product: '<S32>/Product2'\n   *  Sum: '<S32>/Add'\n   */\n  rtb_VectorConcatenate[5] = (rtb_VectorConcatenate_tmp_1 - ctheta) * 2.0;\n\n  /* Sum: '<S28>/Add' incorporates:\n   *  Fcn: '<S9>/Fcn1'\n   */\n  rtb_VectorConcatenate_tmp_2 -= theta;\n\n  /* Gain: '<S28>/Gain' incorporates:\n   *  Sum: '<S28>/Add'\n   */\n  rtb_VectorConcatenate[6] = rtb_VectorConcatenate_tmp_2 * 2.0;\n\n  /* Sum: '<S30>/Add' incorporates:\n   *  Fcn: '<S9>/Fcn'\n   */\n  rtb_VectorConcatenate_tmp_1 += ctheta;\n\n  /* Gain: '<S30>/Gain' incorporates:\n   *  Sum: '<S30>/Add'\n   */\n  rtb_VectorConcatenate[7] = rtb_VectorConcatenate_tmp_1 * 2.0;\n\n  /* Sum: '<S26>/Add' incorporates:\n   *  Fcn: '<S9>/Fcn3'\n   */\n  rtb_VectorConcatenate_tmp_0 = (rtb_VectorConcatenate_tmp_0 - cphi) + phi;\n  rtb_VectorConcatenate[8] = rtb_VectorConcatenate_tmp_0;\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n    /* Math: '<S5>/Math Function2' incorporates:\n     *  Concatenate: '<S33>/Vector Concatenate'\n     *  Math: '<S6>/Math Function2'\n     */\n    Product_tmp[3 * xpageoffset] = rtb_VectorConcatenate[xpageoffset];\n    Product_tmp[3 * xpageoffset + 1] = rtb_VectorConcatenate[xpageoffset + 3];\n    Product_tmp[3 * xpageoffset + 2] = rtb_VectorConcatenate[xpageoffset + 6];\n  }\n\n  /* Integrator: '<S2>/V_b' incorporates:\n   *  Math: '<S5>/Math Function2'\n   */\n  cphi = multirotor0_X.V_b_CSTATE[1];\n  phi = multirotor0_X.V_b_CSTATE[0];\n  ctheta = multirotor0_X.V_b_CSTATE[2];\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n    /* Product: '<S5>/Product' incorporates:\n     *  Integrator: '<S2>/V_b'\n     *  Math: '<S5>/Math Function2'\n     */\n    multirotor0_B.Product[xpageoffset] = (Product_tmp[xpageoffset + 3] * cphi +\n      Product_tmp[xpageoffset] * phi) + Product_tmp[xpageoffset + 6] * ctheta;\n  }\n\n  /* RateTransition: '<S1>/Rate Transition1' */\n  if (rtmIsMajorTimeStep((&multirotor0_M)) && ((&multirotor0_M)\n       ->Timing.RateInteraction.TID1_2 == 1)) {\n    /* RateTransition: '<S1>/Rate Transition1' */\n    multirotor0_B.RateTransition1[0] = multirotor0_DW.RateTransition1_Buffer0[0];\n    multirotor0_B.RateTransition1[1] = multirotor0_DW.RateTransition1_Buffer0[1];\n    multirotor0_B.RateTransition1[2] = multirotor0_DW.RateTransition1_Buffer0[2];\n    multirotor0_B.RateTransition1[3] = multirotor0_DW.RateTransition1_Buffer0[3];\n  }\n\n  /* End of RateTransition: '<S1>/Rate Transition1' */\n\n  /* Product: '<S117>/Product' incorporates:\n   *  Inport: '<Root>/wind'\n   */\n  cphi = multirotor0_U.Wind_i[1];\n  phi = multirotor0_U.Wind_i[0];\n  ctheta = multirotor0_U.Wind_i[2];\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n    /* Product: '<S56>/Product' incorporates:\n     *  Concatenate: '<S33>/Vector Concatenate'\n     */\n    theta = (rtb_VectorConcatenate[xpageoffset + 3] * cphi +\n             rtb_VectorConcatenate[xpageoffset] * phi) +\n      rtb_VectorConcatenate[xpageoffset + 6] * ctheta;\n    rtb_TrueairspeedBodyaxes_b[xpageoffset] = theta;\n\n    /* Sum: '<S58>/Sum1' incorporates:\n     *  Integrator: '<S2>/V_b'\n     */\n    rtb_TrueairspeedBodyaxes[xpageoffset] = multirotor0_X.V_b_CSTATE[xpageoffset]\n      - theta;\n  }\n\n  /* End of Product: '<S117>/Product' */\n  if (rtmIsMajorTimeStep((&multirotor0_M))) {\n    /* MATLAB Function: '<S3>/MATLAB Function' incorporates:\n     *  Inport: '<Root>/COM_mass_center'\n     *  Inport: '<Root>/Motor_arm_angle'\n     *  Inport: '<Root>/Surface_params'\n     *  Inport: '<Root>/arm_length'\n     *  Inport: '<Root>/arm_radius'\n     *  Inport: '<Root>/mass_center'\n     *  Inport: '<Root>/max_rpm'\n     *  Inport: '<Root>/min_rpm'\n     *  Inport: '<Root>/prop_diameter'\n     *  Inport: '<Root>/prop_height'\n     *  Inport: '<Root>/rotation_direction'\n     */\n    multirotor0_B.Surface_params[0] = multirotor0_U.Surface_params[0];\n    multirotor0_B.Surface_params[1] = multirotor0_U.Surface_params[1];\n    multirotor0_B.Surface_params[2] = multirotor0_U.Surface_params[2];\n    for (i = 0; i < 4; i++) {\n      phi = 1.5707963267948966 * static_cast<real_T>(i) + 0.78539816339744828;\n      cphi = std::sin(phi);\n      phi = std::cos(phi);\n      Rz[9 * i] = phi;\n      Rz[9 * i + 3] = -cphi;\n      Rz[9 * i + 6] = 0.0;\n      Rz[9 * i + 1] = cphi;\n      Rz[9 * i + 4] = phi;\n      Rz[9 * i + 7] = 0.0;\n      Rz[9 * i + 2] = 0.0;\n      Rz[9 * i + 5] = 0.0;\n      Rz[9 * i + 8] = 1.0;\n      propeller_mass[i] = multirotor0_U.prop_diameter[i] * 0.054133858267716536;\n    }\n\n    cphi = ((propeller_mass[0] + propeller_mass[1]) + propeller_mass[2]) +\n      propeller_mass[3];\n    airframe_mass[0] = 3.1415926535897931 * multirotor0_U.arm_length[0] *\n      (multirotor0_U.arm_radius[0] * multirotor0_U.arm_radius[0]) * 1700.0;\n    phi = 3.1415926535897931 * multirotor0_U.arm_length[1] *\n      (multirotor0_U.arm_radius[1] * multirotor0_U.arm_radius[1]) * 1700.0;\n    airframe_mass[1] = phi;\n    airframe_mass[2] = 3.1415926535897931 * multirotor0_U.arm_length[2] *\n      (multirotor0_U.arm_radius[2] * multirotor0_U.arm_radius[2]) * 1700.0;\n    ctheta = 3.1415926535897931 * multirotor0_U.arm_length[3] *\n      (multirotor0_U.arm_radius[3] * multirotor0_U.arm_radius[3]) * 1700.0;\n    airframe_mass[3] = ctheta;\n    phi = ((phi + airframe_mass[0]) + airframe_mass[2]) + ctheta;\n    multirotor0_B.total_mass = (multirotor0_U.mass_center + phi) + cphi;\n    for (i = 0; i < 4; i++) {\n      theta = multirotor0_U.arm_length[i];\n      COM_system_inter_idx_1 = multirotor0_U.prop_height[i];\n      COM_system_inter_idx_0 = theta / 2.0;\n      for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n        Rz_tmp = 9 * i + xpageoffset;\n        ctheta = Rz[Rz_tmp + 3];\n        q1 = Rz[Rz_tmp];\n        COM_system_inter_idx_2 = Rz[Rz_tmp + 6];\n        Rz_tmp = (xpageoffset << 2) + i;\n        COM_propeller[Rz_tmp] = (ctheta * 0.0 + q1 * theta) +\n          COM_system_inter_idx_2 * COM_system_inter_idx_1;\n        COM_airframe[Rz_tmp] = (ctheta * 0.0 + q1 * COM_system_inter_idx_0) +\n          COM_system_inter_idx_2 * 0.0;\n      }\n    }\n\n    q1 = COM_propeller[0];\n    COM_system_inter_idx_0 = COM_propeller[1];\n    COM_system_inter_idx_1 = COM_propeller[2];\n    COM_system_inter_idx_2 = COM_propeller[3];\n    COM_propeller_0 = COM_propeller[4];\n    rtb_Airspeeddirectionintherot_0 = COM_propeller[5];\n    COM_propeller_1 = COM_propeller[6];\n    COM_propeller_2 = COM_propeller[7];\n    COM_propeller_3 = COM_propeller[8];\n    COM_propeller_4 = COM_propeller[9];\n    COM_propeller_5 = COM_propeller[10];\n    COM_propeller_6 = COM_propeller[11];\n    COM_airframe_0 = COM_airframe[0];\n    COM_airframe_1 = COM_airframe[1];\n    COM_airframe_2 = COM_airframe[2];\n    COM_airframe_3 = COM_airframe[3];\n    COM_airframe_4 = COM_airframe[4];\n    COM_airframe_5 = COM_airframe[5];\n    COM_airframe_6 = COM_airframe[6];\n    COM_airframe_7 = COM_airframe[7];\n    COM_airframe_8 = COM_airframe[8];\n    COM_airframe_9 = COM_airframe[9];\n    COM_airframe_a = COM_airframe[10];\n    COM_airframe_b = COM_airframe[11];\n    for (i = 0; i < 4; i++) {\n      ctheta = propeller_mass[i];\n      theta = airframe_mass[i];\n      y[3 * i] = ((ctheta * COM_system_inter_idx_0 + ctheta * q1) + ctheta *\n                  COM_system_inter_idx_1) + ctheta * COM_system_inter_idx_2;\n      xpageoffset = 3 * i + 1;\n      y[xpageoffset] = ((ctheta * rtb_Airspeeddirectionintherot_0 + ctheta *\n                         COM_propeller_0) + ctheta * COM_propeller_1) + ctheta *\n        COM_propeller_2;\n      Rz_tmp = 3 * i + 2;\n      y[Rz_tmp] = ((ctheta * COM_propeller_4 + ctheta * COM_propeller_3) +\n                   ctheta * COM_propeller_5) + ctheta * COM_propeller_6;\n      d_y[3 * i] = ((theta * COM_airframe_1 + theta * COM_airframe_0) + theta *\n                    COM_airframe_2) + theta * COM_airframe_3;\n      d_y[xpageoffset] = ((theta * COM_airframe_5 + theta * COM_airframe_4) +\n                          theta * COM_airframe_6) + theta * COM_airframe_7;\n      d_y[Rz_tmp] = ((theta * COM_airframe_9 + theta * COM_airframe_8) + theta *\n                     COM_airframe_a) + theta * COM_airframe_b;\n    }\n\n    cphi = (cphi + phi) + multirotor0_U.mass_center;\n    COM_system_inter_idx_0 = ((y[0] + d_y[0]) + multirotor0_U.mass_center *\n      multirotor0_U.COM_mass_center[0]) / cphi;\n    COM_system_inter_idx_1 = ((y[1] + d_y[1]) + multirotor0_U.mass_center *\n      multirotor0_U.COM_mass_center[1]) / cphi;\n    COM_system_inter_idx_2 = ((y[2] + d_y[2]) + multirotor0_U.mass_center *\n      multirotor0_U.COM_mass_center[2]) / cphi;\n    for (i = 0; i < 4; i++) {\n      ctheta = propeller_mass[i];\n      theta = multirotor0_U.arm_length[i];\n      phi = theta * theta;\n      q1 = 0.083333333333333329 * ctheta * phi;\n      std::memset(&I_propeller_cm[0], 0, 9U * sizeof(real_T));\n      I_propeller_cm[0] = q1;\n      COM_propeller_0 = COM_propeller[i] - COM_system_inter_idx_0;\n      rtb_Sum_a[0] = COM_propeller_0;\n      cphi = COM_propeller_0 * COM_propeller_0;\n      I_propeller_cm[4] = q1;\n      COM_propeller_0 = COM_propeller[i + 4] - COM_system_inter_idx_1;\n      rtb_Sum_a[1] = COM_propeller_0;\n      cphi += COM_propeller_0 * COM_propeller_0;\n      I_propeller_cm[8] = 0.0;\n      COM_propeller_0 = COM_propeller[i + 8] - COM_system_inter_idx_2;\n      rtb_Sum_a[2] = COM_propeller_0;\n      cphi = (COM_propeller_0 * COM_propeller_0 + cphi) * ctheta;\n      for (xpageoffset = 0; xpageoffset < 9; xpageoffset++) {\n        b_I[xpageoffset] = 0;\n      }\n\n      for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n        b_I[xpageoffset + 3 * xpageoffset] = 1;\n        d_propeller[3 * xpageoffset] = rtb_Sum_a[0] * rtb_Sum_a[xpageoffset];\n        d_propeller[3 * xpageoffset + 1] = rtb_Sum_a[1] * rtb_Sum_a[xpageoffset];\n        d_propeller[3 * xpageoffset + 2] = COM_propeller_0 *\n          rtb_Sum_a[xpageoffset];\n      }\n\n      theta = airframe_mass[i];\n      q1 = multirotor0_U.arm_radius[i];\n      q1 *= q1;\n      COM_propeller_0 = COM_airframe[i] - COM_system_inter_idx_0;\n      rtb_Sum_a[0] = COM_propeller_0;\n      for (xpageoffset = 0; xpageoffset < 9; xpageoffset++) {\n        I_propeller_total[xpageoffset] = (cphi * static_cast<real_T>\n          (b_I[xpageoffset]) + I_propeller_cm[xpageoffset]) - ctheta *\n          d_propeller[xpageoffset];\n        I_propeller_cm[xpageoffset] = 0.0;\n        b_I[xpageoffset] = 0;\n      }\n\n      cphi = 0.25 * theta * q1 + 0.083333333333333329 * theta * phi;\n      phi = cphi;\n      I_propeller_cm[0] = cphi;\n      cphi = COM_propeller_0 * COM_propeller_0;\n      I_propeller_cm[4] = phi;\n      COM_propeller_0 = COM_airframe[i + 4] - COM_system_inter_idx_1;\n      rtb_Sum_a[1] = COM_propeller_0;\n      cphi += COM_propeller_0 * COM_propeller_0;\n      I_propeller_cm[8] = 0.5 * theta * q1;\n      COM_propeller_0 = COM_airframe[i + 8] - COM_system_inter_idx_2;\n      rtb_Sum_a[2] = COM_propeller_0;\n      cphi = (COM_propeller_0 * COM_propeller_0 + cphi) * theta;\n      for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n        b_I[xpageoffset + 3 * xpageoffset] = 1;\n        d_propeller[3 * xpageoffset] = rtb_Sum_a[0] * rtb_Sum_a[xpageoffset];\n        d_propeller[3 * xpageoffset + 1] = rtb_Sum_a[1] * rtb_Sum_a[xpageoffset];\n        d_propeller[3 * xpageoffset + 2] = COM_propeller_0 *\n          rtb_Sum_a[xpageoffset];\n      }\n\n      for (xpageoffset = 0; xpageoffset < 9; xpageoffset++) {\n        I_airframe_total[xpageoffset] = (cphi * static_cast<real_T>\n          (b_I[xpageoffset]) + I_propeller_cm[xpageoffset]) - theta *\n          d_propeller[xpageoffset];\n      }\n    }\n\n    for (xpageoffset = 0; xpageoffset < 9; xpageoffset++) {\n      I_propeller_total[xpageoffset] += I_airframe_total[xpageoffset];\n    }\n\n    multirotor0_B.inertial_matrix[0] = I_propeller_total[0];\n    multirotor0_B.inertial_matrix[3] = 0.0;\n    multirotor0_B.inertial_matrix[6] = 0.0;\n    multirotor0_B.inertial_matrix[1] = 0.0;\n    multirotor0_B.inertial_matrix[4] = I_propeller_total[4];\n    multirotor0_B.inertial_matrix[7] = 0.0;\n    multirotor0_B.inertial_matrix[2] = 0.0;\n    multirotor0_B.inertial_matrix[5] = 0.0;\n    multirotor0_B.inertial_matrix[8] = I_propeller_total[8];\n    multirotor0_B.MotorMatrix_real[0] = multirotor0_U.Motor_arm_angle[0];\n    multirotor0_B.MotorMatrix_real[4] = multirotor0_U.arm_length[0];\n    multirotor0_B.MotorMatrix_real[8] = multirotor0_U.prop_height[0];\n    multirotor0_B.MotorMatrix_real[12] = multirotor0_U.rotation_direction[0];\n    multirotor0_B.MotorMatrix_real[16] = 1.0;\n    multirotor0_B.MotorMatrix_real[20] = 0.01;\n    multirotor0_B.MotorMatrix_real[24] = 9.6820000000000012E-5;\n    multirotor0_B.MotorMatrix_real[32] = 1.4504E-6;\n    multirotor0_B.MotorMatrix_real[28] = 1.0872000000000001E-7;\n    multirotor0_B.MotorMatrix_real[36] = 1.6312E-9;\n    multirotor0_B.MotorMatrix_real[40] = multirotor0_U.min_rpm[0];\n    multirotor0_B.MotorMatrix_real[44] = multirotor0_U.max_rpm[0];\n    multirotor0_B.MotorMatrix_real[48] = 0.0;\n    multirotor0_B.MotorMatrix_real[52] = 0.0;\n    multirotor0_B.MotorMatrix_real[56] = 0.0;\n    multirotor0_B.MotorMatrix_real[60] = multirotor0_U.prop_diameter[0];\n    multirotor0_B.MotorMatrix_real[64] = propeller_mass[0];\n    multirotor0_B.MotorMatrix_real[1] = multirotor0_U.Motor_arm_angle[1];\n    multirotor0_B.MotorMatrix_real[5] = multirotor0_U.arm_length[1];\n    multirotor0_B.MotorMatrix_real[9] = multirotor0_U.prop_height[1];\n    multirotor0_B.MotorMatrix_real[13] = multirotor0_U.rotation_direction[1];\n    multirotor0_B.MotorMatrix_real[17] = 1.0;\n    multirotor0_B.MotorMatrix_real[21] = 0.01;\n    multirotor0_B.MotorMatrix_real[25] = 9.6820000000000012E-5;\n    multirotor0_B.MotorMatrix_real[33] = 1.4504E-6;\n    multirotor0_B.MotorMatrix_real[29] = 1.0872000000000001E-7;\n    multirotor0_B.MotorMatrix_real[37] = 1.6312E-9;\n    multirotor0_B.MotorMatrix_real[41] = multirotor0_U.min_rpm[1];\n    multirotor0_B.MotorMatrix_real[45] = multirotor0_U.max_rpm[1];\n    multirotor0_B.MotorMatrix_real[49] = 0.0;\n    multirotor0_B.MotorMatrix_real[53] = 0.0;\n    multirotor0_B.MotorMatrix_real[57] = 0.0;\n    multirotor0_B.MotorMatrix_real[61] = multirotor0_U.prop_diameter[1];\n    multirotor0_B.MotorMatrix_real[65] = propeller_mass[1];\n    multirotor0_B.MotorMatrix_real[2] = multirotor0_U.Motor_arm_angle[2];\n    multirotor0_B.MotorMatrix_real[6] = multirotor0_U.arm_length[2];\n    multirotor0_B.MotorMatrix_real[10] = multirotor0_U.prop_height[2];\n    multirotor0_B.MotorMatrix_real[14] = multirotor0_U.rotation_direction[2];\n    multirotor0_B.MotorMatrix_real[18] = 1.0;\n    multirotor0_B.MotorMatrix_real[22] = 0.01;\n    multirotor0_B.MotorMatrix_real[26] = 9.6820000000000012E-5;\n    multirotor0_B.MotorMatrix_real[34] = 1.4504E-6;\n    multirotor0_B.MotorMatrix_real[30] = 1.0872000000000001E-7;\n    multirotor0_B.MotorMatrix_real[38] = 1.6312E-9;\n    multirotor0_B.MotorMatrix_real[42] = multirotor0_U.min_rpm[2];\n    multirotor0_B.MotorMatrix_real[46] = multirotor0_U.max_rpm[2];\n    multirotor0_B.MotorMatrix_real[50] = 0.0;\n    multirotor0_B.MotorMatrix_real[54] = 0.0;\n    multirotor0_B.MotorMatrix_real[58] = 0.0;\n    multirotor0_B.MotorMatrix_real[62] = multirotor0_U.prop_diameter[2];\n    multirotor0_B.MotorMatrix_real[66] = propeller_mass[2];\n    multirotor0_B.MotorMatrix_real[3] = multirotor0_U.Motor_arm_angle[3];\n    multirotor0_B.MotorMatrix_real[7] = multirotor0_U.arm_length[3];\n    multirotor0_B.MotorMatrix_real[11] = multirotor0_U.prop_height[3];\n    multirotor0_B.MotorMatrix_real[15] = multirotor0_U.rotation_direction[3];\n    multirotor0_B.MotorMatrix_real[19] = 1.0;\n    multirotor0_B.MotorMatrix_real[23] = 0.01;\n    multirotor0_B.MotorMatrix_real[27] = 9.6820000000000012E-5;\n    multirotor0_B.MotorMatrix_real[35] = 1.4504E-6;\n    multirotor0_B.MotorMatrix_real[31] = 1.0872000000000001E-7;\n    multirotor0_B.MotorMatrix_real[39] = 1.6312E-9;\n    multirotor0_B.MotorMatrix_real[43] = multirotor0_U.min_rpm[3];\n    multirotor0_B.MotorMatrix_real[47] = multirotor0_U.max_rpm[3];\n    multirotor0_B.MotorMatrix_real[63] = multirotor0_U.prop_diameter[3];\n    multirotor0_B.MotorMatrix_real[67] = propeller_mass[3];\n    multirotor0_B.MotorMatrix_real[51] = 0.0;\n    multirotor0_B.COM_system[0] = COM_system_inter_idx_0;\n    multirotor0_B.MotorMatrix_real[55] = 0.0;\n    multirotor0_B.COM_system[1] = COM_system_inter_idx_1;\n    multirotor0_B.MotorMatrix_real[59] = 0.0;\n    multirotor0_B.COM_system[2] = COM_system_inter_idx_2;\n\n    /* End of MATLAB Function: '<S3>/MATLAB Function' */\n  }\n\n  /* Outputs for Iterator SubSystem: '<S39>/For Each Subsystem' incorporates:\n   *  ForEach: '<S57>/For Each'\n   */\n  for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n    /* ForEachSliceSelector generated from: '<S57>/MotorMatrix_real' incorporates:\n     *  RelationalOperator: '<S63>/Relational Operator'\n     *  RelationalOperator: '<S67>/LowerRelop1'\n     */\n    q1 = multirotor0_B.MotorMatrix_real[ForEach_itr + 44];\n\n    /* Switch: '<S67>/Switch2' incorporates:\n     *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n     *  Integrator: '<S63>/Integrator'\n     *  RelationalOperator: '<S67>/LowerRelop1'\n     */\n    if (multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE > q1) {\n      cphi = multirotor0_B.MotorMatrix_real[ForEach_itr + 44];\n    } else {\n      /* RelationalOperator: '<S67>/UpperRelop' incorporates:\n       *  Switch: '<S67>/Switch'\n       */\n      cphi = multirotor0_B.MotorMatrix_real[ForEach_itr + 40];\n\n      /* Switch: '<S67>/Switch' incorporates:\n       *  RelationalOperator: '<S67>/UpperRelop'\n       */\n      if (!(multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE < cphi)) {\n        cphi = multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE;\n      }\n    }\n\n    /* End of Switch: '<S67>/Switch2' */\n    if (rtmIsMajorTimeStep((&multirotor0_M))) {\n      /* Product: '<S59>/Product' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       *  ForEachSliceSelector generated from: '<S57>/RPM_commands'\n       *  RateTransition: '<S1>/Rate Transition1'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].Product =\n        multirotor0_B.MotorMatrix_real[ForEach_itr + 16] *\n        multirotor0_B.RateTransition1[ForEach_itr];\n    }\n\n    /* Product: '<S59>/Divide' incorporates:\n     *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n     *  Sum: '<S59>/Sum1'\n     */\n    ctheta = (multirotor0_B.CoreSubsys[ForEach_itr].Product - cphi) /\n      multirotor0_B.MotorMatrix_real[ForEach_itr + 20];\n\n    /* Switch: '<S63>/Switch' incorporates:\n     *  Constant: '<S65>/Constant'\n     *  Constant: '<S66>/Constant'\n     *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n     *  Integrator: '<S63>/Integrator'\n     *  Logic: '<S63>/Logical Operator'\n     *  Logic: '<S63>/Logical Operator1'\n     *  Logic: '<S63>/Logical Operator2'\n     *  RelationalOperator: '<S63>/Relational Operator'\n     *  RelationalOperator: '<S63>/Relational Operator1'\n     *  RelationalOperator: '<S65>/Compare'\n     *  RelationalOperator: '<S66>/Compare'\n     */\n    if (((multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE <= q1) ||\n         (ctheta < 0.0)) && ((ctheta > 0.0) ||\n         (multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE >=\n          multirotor0_B.MotorMatrix_real[ForEach_itr + 40]))) {\n      /* Switch: '<S63>/Switch' */\n      multirotor0_B.CoreSubsys[ForEach_itr].Switch = ctheta;\n    } else {\n      /* Switch: '<S63>/Switch' incorporates:\n       *  Constant: '<S63>/Constant'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].Switch = 0.0;\n    }\n\n    /* End of Switch: '<S63>/Switch' */\n\n    /* Switch: '<S64>/Switch' */\n    multirotor0_B.CoreSubsys[ForEach_itr].Switch_a = 0.0;\n    if (rtmIsMajorTimeStep((&multirotor0_M))) {\n      /* Gain: '<S61>/Conversion deg to rad' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       */\n      phi = 0.017453292519943295 * multirotor0_B.MotorMatrix_real[ForEach_itr];\n\n      /* Abs: '<S61>/Abs' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       */\n      ctheta = std::abs(multirotor0_B.MotorMatrix_real[ForEach_itr + 4]);\n\n      /* Sum: '<S61>/Subtract' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       *  Product: '<S61>/Product4'\n       *  Reshape: '<S61>/Reshape'\n       *  Trigonometry: '<S61>/Trigonometric Function'\n       *  Trigonometry: '<S61>/Trigonometric Function1'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[0] =\n        std::cos(phi) * ctheta - multirotor0_B.COM_system[0];\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[1] =\n        std::sin(phi) * ctheta - multirotor0_B.COM_system[1];\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[2] =\n        multirotor0_B.MotorMatrix_real[ForEach_itr + 8] -\n        multirotor0_B.COM_system[2];\n\n      /* Gain: '<S74>/Conversion deg to rad' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       */\n      rtb_Sum_a[0] = multirotor0_B.MotorMatrix_real[ForEach_itr + 48] *\n        0.017453292519943295;\n      rtb_Sum_a[1] = multirotor0_B.MotorMatrix_real[ForEach_itr + 52] *\n        0.017453292519943295;\n      rtb_Sum_a[2] = multirotor0_B.MotorMatrix_real[ForEach_itr + 56] *\n        0.017453292519943295;\n\n      /* Trigonometry: '<S105>/Trigonometric Function3' incorporates:\n       *  Trigonometry: '<S108>/Trigonometric Function3'\n       *  Trigonometry: '<S109>/Trigonometric Function'\n       *  Trigonometry: '<S111>/Trigonometric Function4'\n       *  Trigonometry: '<S112>/Trigonometric Function'\n       */\n      phi = std::cos(rtb_Sum_a[2]);\n\n      /* Trigonometry: '<S105>/Trigonometric Function1' incorporates:\n       *  Trigonometry: '<S106>/Trigonometric Function1'\n       *  Trigonometry: '<S110>/Trigonometric Function1'\n       *  Trigonometry: '<S113>/Trigonometric Function1'\n       */\n      ctheta = std::cos(rtb_Sum_a[1]);\n\n      /* Product: '<S105>/Product' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Trigonometry: '<S105>/Trigonometric Function1'\n       *  Trigonometry: '<S105>/Trigonometric Function3'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[0] = ctheta * phi;\n\n      /* Trigonometry: '<S108>/Trigonometric Function5' incorporates:\n       *  Trigonometry: '<S109>/Trigonometric Function5'\n       *  Trigonometry: '<S111>/Trigonometric Function12'\n       *  Trigonometry: '<S113>/Trigonometric Function3'\n       */\n      theta = std::cos(rtb_Sum_a[0]);\n\n      /* Trigonometry: '<S108>/Trigonometric Function1' incorporates:\n       *  Trigonometry: '<S107>/Trigonometric Function1'\n       *  Trigonometry: '<S111>/Trigonometric Function2'\n       */\n      COM_system_inter_idx_1 = std::sin(rtb_Sum_a[1]);\n\n      /* Trigonometry: '<S108>/Trigonometric Function12' incorporates:\n       *  Trigonometry: '<S110>/Trigonometric Function3'\n       *  Trigonometry: '<S111>/Trigonometric Function5'\n       *  Trigonometry: '<S112>/Trigonometric Function5'\n       */\n      COM_system_inter_idx_2 = std::sin(rtb_Sum_a[0]);\n\n      /* Trigonometry: '<S108>/Trigonometric Function' incorporates:\n       *  Trigonometry: '<S106>/Trigonometric Function3'\n       *  Trigonometry: '<S109>/Trigonometric Function4'\n       *  Trigonometry: '<S111>/Trigonometric Function'\n       *  Trigonometry: '<S112>/Trigonometric Function3'\n       */\n      q1 = std::sin(rtb_Sum_a[2]);\n\n      /* Product: '<S108>/Product' incorporates:\n       *  Product: '<S109>/Product1'\n       *  Trigonometry: '<S108>/Trigonometric Function1'\n       *  Trigonometry: '<S108>/Trigonometric Function12'\n       */\n      COM_system_inter_idx_0 = COM_system_inter_idx_2 * COM_system_inter_idx_1;\n\n      /* Sum: '<S108>/Sum' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Product: '<S108>/Product'\n       *  Product: '<S108>/Product1'\n       *  Trigonometry: '<S108>/Trigonometric Function'\n       *  Trigonometry: '<S108>/Trigonometric Function5'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[1] =\n        COM_system_inter_idx_0 * phi - theta * q1;\n\n      /* Product: '<S111>/Product1' incorporates:\n       *  Product: '<S112>/Product'\n       */\n      COM_propeller_0 = theta * COM_system_inter_idx_1;\n\n      /* Sum: '<S111>/Sum' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Product: '<S111>/Product1'\n       *  Product: '<S111>/Product2'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[2] =\n        COM_propeller_0 * phi + COM_system_inter_idx_2 * q1;\n\n      /* Product: '<S106>/Product' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[3] = ctheta * q1;\n\n      /* Sum: '<S109>/Sum' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Product: '<S109>/Product1'\n       *  Product: '<S109>/Product2'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[4] =\n        COM_system_inter_idx_0 * q1 + theta * phi;\n\n      /* Sum: '<S112>/Sum' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       *  Product: '<S112>/Product'\n       *  Product: '<S112>/Product1'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[5] =\n        COM_propeller_0 * q1 - COM_system_inter_idx_2 * phi;\n\n      /* Gain: '<S107>/Gain' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[6] =\n        -COM_system_inter_idx_1;\n\n      /* Product: '<S110>/Product' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[7] =\n        COM_system_inter_idx_2 * ctheta;\n\n      /* Product: '<S113>/Product' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[8] = theta *\n        ctheta;\n    }\n\n    /* Sum: '<S57>/Sum1' incorporates:\n     *  Integrator: '<S2>/omega'\n     *  Product: '<S71>/Product'\n     *  Product: '<S71>/Product1'\n     *  Product: '<S71>/Product2'\n     *  Product: '<S72>/Product'\n     *  Product: '<S72>/Product1'\n     *  Product: '<S72>/Product2'\n     *  Sum: '<S58>/Sum1'\n     *  Sum: '<S60>/Sum'\n     */\n    COM_system_inter_idx_0 = (multirotor0_X.omega_CSTATE[1] *\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[2] -\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[1] *\n      multirotor0_X.omega_CSTATE[2]) + rtb_TrueairspeedBodyaxes[0];\n    COM_system_inter_idx_2 = (multirotor0_B.CoreSubsys[ForEach_itr].\n      VectorfromrealCoGtopropellerBod[0] * multirotor0_X.omega_CSTATE[2] -\n      multirotor0_X.omega_CSTATE[0] * multirotor0_B.CoreSubsys[ForEach_itr].\n      VectorfromrealCoGtopropellerBod[2]) + rtb_TrueairspeedBodyaxes[1];\n    COM_system_inter_idx_1 = (multirotor0_X.omega_CSTATE[0] *\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[1] -\n      multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[0] *\n      multirotor0_X.omega_CSTATE[1]) + rtb_TrueairspeedBodyaxes[2];\n\n    /* Product: '<S74>/Product' */\n    for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n      /* Product: '<S74>/Product' incorporates:\n       *  Concatenate: '<S114>/Vector Concatenate'\n       */\n      rtb_Sum_a[xpageoffset] = (multirotor0_B.CoreSubsys[ForEach_itr].\n        VectorConcatenate[xpageoffset + 3] * COM_system_inter_idx_2 +\n        multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[xpageoffset] *\n        COM_system_inter_idx_0) + multirotor0_B.CoreSubsys[ForEach_itr].\n        VectorConcatenate[xpageoffset + 6] * COM_system_inter_idx_1;\n    }\n\n    /* End of Product: '<S74>/Product' */\n\n    /* Gain: '<S89>/Gain' */\n    multirotor0_B.CoreSubsys[ForEach_itr].Climbspeedv_c = -rtb_Sum_a[2];\n    if (rtmIsMajorTimeStep((&multirotor0_M))) {\n      /* Outputs for IfAction SubSystem: '<S90>/Vortex ring state -2 <= vc//vh < 0 ' incorporates:\n       *  ActionPort: '<S98>/Action Port'\n       */\n      /* If: '<S90>/If' incorporates:\n       *  Constant: '<S77>/Induced velocity at hover'\n       *  Product: '<S90>/Divide'\n       *  Product: '<S98>/Divide'\n       */\n      q1 = multirotor0_B.CoreSubsys[ForEach_itr].Climbspeedv_c / 4.0;\n\n      /* End of Outputs for SubSystem: '<S90>/Vortex ring state -2 <= vc//vh < 0 ' */\n      if (rtsiIsModeUpdateTimeStep(&(&multirotor0_M)->solverInfo)) {\n        if (q1 >= 0.0) {\n          rtAction = 0;\n        } else if (q1 >= -2.0) {\n          rtAction = 1;\n        } else {\n          rtAction = 2;\n        }\n\n        multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem = rtAction;\n      } else {\n        rtAction = multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem;\n      }\n\n      switch (rtAction) {\n       case 0:\n        /* Outputs for IfAction SubSystem: '<S90>/Normal working state vc//vh >= 0' incorporates:\n         *  ActionPort: '<S97>/Action Port'\n         */\n        /* Gain: '<S97>/Gain' */\n        phi = 0.5 * multirotor0_B.CoreSubsys[ForEach_itr].Climbspeedv_c;\n\n        /* Merge: '<S90>/Merge' incorporates:\n         *  Product: '<S97>/Product'\n         *  Sqrt: '<S97>/Sqrt'\n         *  Sum: '<S97>/Sum'\n         *  Sum: '<S97>/Sum1'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Merge = std::sqrt(phi * phi + 16.0)\n          - phi;\n\n        /* End of Outputs for SubSystem: '<S90>/Normal working state vc//vh >= 0' */\n        break;\n\n       case 1:\n        /* Outputs for IfAction SubSystem: '<S90>/Vortex ring state -2 <= vc//vh < 0 ' incorporates:\n         *  ActionPort: '<S98>/Action Port'\n         */\n        /* Product: '<S98>/Product' */\n        ctheta = q1 * q1;\n\n        /* Gain: '<S98>/Gain1' */\n        theta = -1.372 * ctheta;\n\n        /* Product: '<S98>/Product1' */\n        ctheta *= q1;\n\n        /* Merge: '<S90>/Merge' incorporates:\n         *  Constant: '<S98>/Constant'\n         *  Constant: '<S98>/Induced velocity at hover'\n         *  Gain: '<S98>/Gain'\n         *  Gain: '<S98>/Gain2'\n         *  Gain: '<S98>/Gain3'\n         *  Product: '<S98>/Product2'\n         *  Product: '<S98>/Product3'\n         *  Sum: '<S98>/Add'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Merge = ((((-1.125 * q1 + 1.0) +\n          theta) + -1.718 * ctheta) + ctheta * q1 * -0.655) * 4.0;\n\n        /* End of Outputs for SubSystem: '<S90>/Vortex ring state -2 <= vc//vh < 0 ' */\n        break;\n\n       default:\n        /* Outputs for IfAction SubSystem: '<S90>/Windmill braking state vc//vh < -2' incorporates:\n         *  ActionPort: '<S99>/Action Port'\n         */\n        /* Gain: '<S99>/Gain' */\n        phi = 0.5 * multirotor0_B.CoreSubsys[ForEach_itr].Climbspeedv_c;\n\n        /* Merge: '<S90>/Merge' incorporates:\n         *  Product: '<S99>/Product'\n         *  Sqrt: '<S99>/Sqrt'\n         *  Sum: '<S99>/Sum'\n         *  Sum: '<S99>/Sum1'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Merge = (0.0 - phi) - std::sqrt\n          (phi * phi - 16.0);\n\n        /* End of Outputs for SubSystem: '<S90>/Windmill braking state vc//vh < -2' */\n        break;\n      }\n\n      /* End of If: '<S90>/If' */\n    }\n\n    /* Outputs for IfAction SubSystem: '<S76>/Nonzero airspeed in rotor plane' incorporates:\n     *  ActionPort: '<S82>/Action Port'\n     */\n    /* Outputs for IfAction SubSystem: '<S88>/Nonzero airspeed' incorporates:\n     *  ActionPort: '<S91>/Action Port'\n     */\n    /* If: '<S76>/If' incorporates:\n     *  If: '<S88>/If'\n     *  Math: '<S96>/transpose'\n     *  Product: '<S74>/Product'\n     *  Product: '<S86>/Product'\n     *  Product: '<S87>/Product'\n     *  Product: '<S95>/Product'\n     *  Product: '<S96>/Product'\n     */\n    theta = rtb_Sum_a[0] * rtb_Sum_a[0] + rtb_Sum_a[1] * rtb_Sum_a[1];\n\n    /* End of Outputs for SubSystem: '<S88>/Nonzero airspeed' */\n    /* End of Outputs for SubSystem: '<S76>/Nonzero airspeed in rotor plane' */\n\n    /* Sqrt: '<S93>/Sqrt' incorporates:\n     *  Math: '<S96>/transpose'\n     *  Product: '<S74>/Product'\n     *  Product: '<S96>/Product'\n     */\n    ctheta = std::sqrt(rtb_Sum_a[2] * rtb_Sum_a[2] + theta);\n\n    /* If: '<S88>/If' */\n    if (rtsiIsModeUpdateTimeStep(&(&multirotor0_M)->solverInfo)) {\n      rtAction = static_cast<int8_T>(!(ctheta == 0.0));\n      multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem_l = rtAction;\n    } else {\n      rtAction = multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem_l;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S88>/Zero airspeed' incorporates:\n       *  ActionPort: '<S92>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&multirotor0_M))) {\n        /* Merge: '<S88>/Merge' incorporates:\n         *  Constant: '<S92>/Constant'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Angleofattackrad = 0.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S88>/Zero airspeed' */\n    } else {\n      /* Outputs for IfAction SubSystem: '<S88>/Nonzero airspeed' incorporates:\n       *  ActionPort: '<S91>/Action Port'\n       */\n      /* Merge: '<S88>/Merge' incorporates:\n       *  Product: '<S91>/Divide1'\n       *  Sqrt: '<S94>/Sqrt'\n       *  Trigonometry: '<S91>/Trigonometric Function'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].Angleofattackrad = std::atan(1.0 /\n        std::sqrt(theta) * rtb_Sum_a[2]);\n\n      /* End of Outputs for SubSystem: '<S88>/Nonzero airspeed' */\n    }\n\n    /* Product: '<S77>/Divide' incorporates:\n     *  Constant: '<S77>/Induced velocity at hover'\n     *  Product: '<S77>/Product2'\n     *  Sum: '<S77>/Sum2'\n     *  Trigonometry: '<S77>/Trigonometric Function'\n     */\n    phi = 4.0 / (multirotor0_B.CoreSubsys[ForEach_itr].Merge - std::sin\n                 (multirotor0_B.CoreSubsys[ForEach_itr].Angleofattackrad) *\n                 ctheta);\n\n    /* Product: '<S80>/Product5' incorporates:\n     *  Product: '<S79>/Product1'\n     */\n    q1 = cphi * cphi;\n\n    /* Product: '<S73>/Product7' incorporates:\n     *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n     *  Product: '<S80>/Product4'\n     *  Product: '<S80>/Product5'\n     *  Product: '<S80>/Product6'\n     *  Sum: '<S80>/Sum1'\n     *  Switch: '<S77>/Switch'\n     */\n    ctheta = (multirotor0_B.MotorMatrix_real[ForEach_itr + 24] * cphi +\n              multirotor0_B.MotorMatrix_real[ForEach_itr + 28] * q1) * phi;\n\n    /* If: '<S76>/If' incorporates:\n     *  Sqrt: '<S84>/Sqrt'\n     */\n    if (rtsiIsModeUpdateTimeStep(&(&multirotor0_M)->solverInfo)) {\n      rtAction = static_cast<int8_T>(!(std::sqrt(theta) == 0.0));\n      multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem_e = rtAction;\n    } else {\n      rtAction = multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem_e;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S76>/Zero airspeed in rotor plane' incorporates:\n       *  ActionPort: '<S83>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&multirotor0_M))) {\n        /* Merge: '<S76>/Merge' incorporates:\n         *  Constant: '<S83>/Constant'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[0]\n          = 0.0;\n\n        /* Merge: '<S76>/Merge1' incorporates:\n         *  Constant: '<S83>/Constant1'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Momentinthemotorhubduetobending[0]\n          = 0.0;\n\n        /* Merge: '<S76>/Merge' incorporates:\n         *  Constant: '<S83>/Constant'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[1]\n          = 0.0;\n\n        /* Merge: '<S76>/Merge1' incorporates:\n         *  Constant: '<S83>/Constant1'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Momentinthemotorhubduetobending[1]\n          = 0.0;\n\n        /* Merge: '<S76>/Merge' incorporates:\n         *  Constant: '<S83>/Constant'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[2]\n          = -1.0;\n\n        /* Merge: '<S76>/Merge1' incorporates:\n         *  Constant: '<S83>/Constant1'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Momentinthemotorhubduetobending[2]\n          = 0.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S76>/Zero airspeed in rotor plane' */\n    } else {\n      /* Outputs for IfAction SubSystem: '<S76>/Nonzero airspeed in rotor plane' incorporates:\n       *  ActionPort: '<S82>/Action Port'\n       */\n      /* Sqrt: '<S85>/Sqrt' */\n      theta = std::sqrt(theta);\n\n      /* Gain: '<S82>/Conversion deg to rad' incorporates:\n       *  Product: '<S82>/Product4'\n       */\n      COM_system_inter_idx_1 = theta * 0.375 * 0.017453292519943295;\n\n      /* Trigonometry: '<S82>/Trigonometric Function' */\n      COM_system_inter_idx_2 = std::sin(COM_system_inter_idx_1);\n\n      /* Product: '<S82>/Divide' */\n      COM_propeller_0 = rtb_Sum_a[0] / theta;\n      rtb_Airspeeddirectionintherot_0 = COM_propeller_0;\n\n      /* Product: '<S82>/Product2' incorporates:\n       *  Gain: '<S82>/Gain'\n       *  Product: '<S82>/Divide'\n       *  Product: '<S82>/Product'\n       */\n      COM_system_inter_idx_0 = -COM_propeller_0 * COM_system_inter_idx_2;\n\n      /* Product: '<S82>/Divide' */\n      COM_propeller_0 = rtb_Sum_a[1] / theta;\n\n      /* Product: '<S82>/Product2' incorporates:\n       *  Gain: '<S82>/Gain'\n       *  Product: '<S82>/Divide'\n       *  Product: '<S82>/Product'\n       */\n      COM_system_inter_idx_2 *= -COM_propeller_0;\n\n      /* Gain: '<S82>/Gain1' incorporates:\n       *  Trigonometry: '<S82>/Trigonometric Function1'\n       */\n      theta = -std::cos(COM_system_inter_idx_1);\n\n      /* Product: '<S82>/Product3' incorporates:\n       *  Constant: '<S82>/Constant'\n       *  Constant: '<S82>/Constant1'\n       *  Gain: '<S82>/Gain2'\n       *  Product: '<S82>/Divide'\n       *  Product: '<S82>/Product1'\n       */\n      COM_propeller_0 = -COM_propeller_0 * 0.23 * COM_system_inter_idx_1;\n      rtb_Airspeeddirectionintherot_0 = rtb_Airspeeddirectionintherot_0 * 0.23 *\n        COM_system_inter_idx_1;\n      COM_system_inter_idx_1 *= 0.0;\n      for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n        /* Product: '<S82>/Product2' incorporates:\n         *  Concatenate: '<S114>/Vector Concatenate'\n         */\n        COM_propeller_1 = multirotor0_B.CoreSubsys[ForEach_itr].\n          VectorConcatenate[3 * xpageoffset];\n        COM_propeller_2 = multirotor0_B.CoreSubsys[ForEach_itr].\n          VectorConcatenate[3 * xpageoffset + 1];\n        COM_propeller_3 = multirotor0_B.CoreSubsys[ForEach_itr].\n          VectorConcatenate[3 * xpageoffset + 2];\n\n        /* Merge: '<S76>/Merge' incorporates:\n         *  Product: '<S82>/Product2'\n         *  Reshape: '<S82>/Reshape1'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr]\n          .NewtiltedthrustdirectionBodyaxe[xpageoffset] = (COM_propeller_2 *\n          COM_system_inter_idx_2 + COM_propeller_1 * COM_system_inter_idx_0) +\n          COM_propeller_3 * theta;\n\n        /* Merge: '<S76>/Merge1' incorporates:\n         *  Product: '<S82>/Product3'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr]\n          .Momentinthemotorhubduetobending[xpageoffset] = (COM_propeller_2 *\n          rtb_Airspeeddirectionintherot_0 + COM_propeller_1 * COM_propeller_0) +\n          COM_propeller_3 * COM_system_inter_idx_1;\n      }\n\n      /* End of Outputs for SubSystem: '<S76>/Nonzero airspeed in rotor plane' */\n    }\n\n    /* Product: '<S73>/Product9' incorporates:\n     *  Merge: '<S76>/Merge'\n     */\n    COM_system_inter_idx_0 = ctheta * multirotor0_B.CoreSubsys[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[0];\n    COM_system_inter_idx_1 = ctheta * multirotor0_B.CoreSubsys[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[1];\n    COM_system_inter_idx_2 = ctheta * multirotor0_B.CoreSubsys[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[2];\n    if (rtmIsMajorTimeStep((&multirotor0_M))) {\n      for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n        /* Product: '<S81>/Product9' incorporates:\n         *  Concatenate: '<S114>/Vector Concatenate'\n         *  Constant: '<S81>/Constant'\n         *  Math: '<S81>/Math Function'\n         */\n        multirotor0_B.CoreSubsys[ForEach_itr].Product9[xpageoffset] =\n          (multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[3 *\n           xpageoffset + 1] * 0.0 + multirotor0_B.CoreSubsys[ForEach_itr].\n           VectorConcatenate[3 * xpageoffset] * 0.0) -\n          multirotor0_B.CoreSubsys[ForEach_itr].VectorConcatenate[3 *\n          xpageoffset + 2];\n      }\n\n      /* Gain: '<S101>/Gain' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       */\n      ctheta = multirotor0_B.MotorMatrix_real[ForEach_itr + 60] * 0.5;\n\n      /* Gain: '<S101>/Gain1' incorporates:\n       *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n       *  Product: '<S101>/Product7'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].Gain1 = ctheta * ctheta *\n        multirotor0_B.MotorMatrix_real[ForEach_itr + 64] * 0.58333333333333337;\n    }\n\n    /* Gain: '<S78>/Conversion rpm to rad//s' */\n    ctheta = 0.10471975511965977 * cphi;\n\n    /* ForEachSliceAssignment generated from: '<S57>/RPM_motor' */\n    rtb_ImpAsg_InsertedFor_RPM_moto[ForEach_itr] = cphi;\n\n    /* ForEachSliceSelector generated from: '<S57>/MotorMatrix_real' incorporates:\n     *  Product: '<S73>/Product3'\n     *  Product: '<S78>/Product5'\n     */\n    COM_propeller_0 = multirotor0_B.MotorMatrix_real[ForEach_itr + 12];\n\n    /* Product: '<S73>/Product3' incorporates:\n     *  ForEachSliceSelector generated from: '<S57>/MotorMatrix_real'\n     *  Product: '<S79>/Product'\n     *  Product: '<S79>/Product1'\n     *  Sum: '<S79>/Sum'\n     */\n    theta = (multirotor0_B.MotorMatrix_real[ForEach_itr + 32] * cphi +\n             multirotor0_B.MotorMatrix_real[ForEach_itr + 36] * q1) *\n      COM_propeller_0;\n\n    /* Product: '<S78>/Product5' */\n    q1 = COM_propeller_0 * multirotor0_B.CoreSubsys[ForEach_itr].Gain1;\n\n    /* ForEachSliceAssignment generated from: '<S57>/Motor_moment' incorporates:\n     *  Integrator: '<S2>/omega'\n     *  Merge: '<S76>/Merge1'\n     *  Product: '<S102>/Product'\n     *  Product: '<S103>/Product'\n     *  Product: '<S115>/Product'\n     *  Product: '<S116>/Product'\n     *  Product: '<S73>/Product3'\n     *  Product: '<S73>/Product8'\n     *  Product: '<S78>/Product5'\n     *  Product: '<S81>/Product9'\n     *  Sum: '<S100>/Sum'\n     *  Sum: '<S62>/Add'\n     *  Sum: '<S75>/Sum'\n     *  Switch: '<S77>/Switch'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_mo[3 * ForEach_itr] =\n      ((multirotor0_X.omega_CSTATE[1] * multirotor0_B.CoreSubsys[ForEach_itr].\n        NewtiltedthrustdirectionBodyaxe[2] -\n        multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[1]\n        * multirotor0_X.omega_CSTATE[2]) * q1 * ctheta + (theta *\n        multirotor0_B.CoreSubsys[ForEach_itr].Product9[0] * phi +\n        multirotor0_B.CoreSubsys[ForEach_itr].Momentinthemotorhubduetobending[0]))\n      + (multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[1]\n         * COM_system_inter_idx_2 - COM_system_inter_idx_1 *\n         multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[2]);\n\n    /* ForEachSliceAssignment generated from: '<S57>/Motor_force' incorporates:\n     *  Product: '<S73>/Product9'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_fo[3 * ForEach_itr] = COM_system_inter_idx_0;\n\n    /* ForEachSliceAssignment generated from: '<S57>/Motor_moment' incorporates:\n     *  ForEachSliceAssignment generated from: '<S57>/Motor_force'\n     *  Integrator: '<S2>/omega'\n     *  Merge: '<S76>/Merge1'\n     *  Product: '<S102>/Product1'\n     *  Product: '<S103>/Product1'\n     *  Product: '<S115>/Product1'\n     *  Product: '<S116>/Product1'\n     *  Product: '<S73>/Product3'\n     *  Product: '<S73>/Product8'\n     *  Product: '<S78>/Product5'\n     *  Product: '<S81>/Product9'\n     *  Sum: '<S100>/Sum'\n     *  Sum: '<S62>/Add'\n     *  Sum: '<S75>/Sum'\n     *  Switch: '<S77>/Switch'\n     */\n    i = 3 * ForEach_itr + 1;\n    rtb_ImpAsg_InsertedFor_Motor_mo[i] = ((multirotor0_B.CoreSubsys[ForEach_itr]\n      .NewtiltedthrustdirectionBodyaxe[0] * multirotor0_X.omega_CSTATE[2] -\n      multirotor0_X.omega_CSTATE[0] * multirotor0_B.CoreSubsys[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[2]) * q1 * ctheta + (theta *\n      multirotor0_B.CoreSubsys[ForEach_itr].Product9[1] * phi +\n      multirotor0_B.CoreSubsys[ForEach_itr].Momentinthemotorhubduetobending[1]))\n      + (COM_system_inter_idx_0 * multirotor0_B.CoreSubsys[ForEach_itr].\n         VectorfromrealCoGtopropellerBod[2] -\n         multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[0]\n         * COM_system_inter_idx_2);\n\n    /* ForEachSliceAssignment generated from: '<S57>/Motor_force' incorporates:\n     *  Product: '<S73>/Product9'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_fo[i] = COM_system_inter_idx_1;\n\n    /* ForEachSliceAssignment generated from: '<S57>/Motor_moment' incorporates:\n     *  ForEachSliceAssignment generated from: '<S57>/Motor_force'\n     *  Integrator: '<S2>/omega'\n     *  Merge: '<S76>/Merge1'\n     *  Product: '<S102>/Product2'\n     *  Product: '<S103>/Product2'\n     *  Product: '<S115>/Product2'\n     *  Product: '<S116>/Product2'\n     *  Product: '<S73>/Product3'\n     *  Product: '<S73>/Product8'\n     *  Product: '<S78>/Product5'\n     *  Product: '<S81>/Product9'\n     *  Sum: '<S100>/Sum'\n     *  Sum: '<S62>/Add'\n     *  Sum: '<S75>/Sum'\n     *  Switch: '<S77>/Switch'\n     */\n    i = 3 * ForEach_itr + 2;\n    rtb_ImpAsg_InsertedFor_Motor_mo[i] = ((multirotor0_X.omega_CSTATE[0] *\n      multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[1] -\n      multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[0] *\n      multirotor0_X.omega_CSTATE[1]) * q1 * ctheta + (theta *\n      multirotor0_B.CoreSubsys[ForEach_itr].Product9[2] * phi +\n      multirotor0_B.CoreSubsys[ForEach_itr].Momentinthemotorhubduetobending[2]))\n      + (multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[0]\n         * COM_system_inter_idx_1 - COM_system_inter_idx_0 *\n         multirotor0_B.CoreSubsys[ForEach_itr].VectorfromrealCoGtopropellerBod[1]);\n\n    /* ForEachSliceAssignment generated from: '<S57>/Motor_force' incorporates:\n     *  Product: '<S73>/Product9'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_fo[i] = COM_system_inter_idx_2;\n  }\n\n  /* End of Outputs for SubSystem: '<S39>/For Each Subsystem' */\n\n  /* Sum: '<S39>/Sum of Elements' incorporates:\n   *  ForEachSliceAssignment generated from: '<S57>/Motor_force'\n   *  Sum: '<S16>/Sum'\n   */\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n    rtb_Sum_a[xpageoffset] = ((rtb_ImpAsg_InsertedFor_Motor_fo[xpageoffset + 3]\n      + rtb_ImpAsg_InsertedFor_Motor_fo[xpageoffset]) +\n      rtb_ImpAsg_InsertedFor_Motor_fo[xpageoffset + 6]) +\n      rtb_ImpAsg_InsertedFor_Motor_fo[xpageoffset + 9];\n  }\n\n  /* End of Sum: '<S39>/Sum of Elements' */\n  if (rtmIsMajorTimeStep((&multirotor0_M))) {\n    /* Product: '<S38>/Product1' incorporates:\n     *  Constant: '<S38>/Gravity (Inertial axes)'\n     */\n    multirotor0_B.ForceofgravityInertialaxes[0] = 0.0 * multirotor0_B.total_mass;\n    multirotor0_B.ForceofgravityInertialaxes[1] = 0.0 * multirotor0_B.total_mass;\n    multirotor0_B.ForceofgravityInertialaxes[2] = 9.80665 *\n      multirotor0_B.total_mass;\n  }\n\n  /* Sum: '<S41>/Sum1' incorporates:\n   *  Integrator: '<S2>/V_b'\n   *  Product: '<S56>/Product'\n   */\n  rtb_TrueairspeedBodyaxes_b[0] = multirotor0_X.V_b_CSTATE[0] -\n    rtb_TrueairspeedBodyaxes_b[0];\n  rtb_TrueairspeedBodyaxes_b[1] = multirotor0_X.V_b_CSTATE[1] -\n    rtb_TrueairspeedBodyaxes_b[1];\n  rtb_TrueairspeedBodyaxes_b[2] = multirotor0_X.V_b_CSTATE[2] -\n    rtb_TrueairspeedBodyaxes_b[2];\n\n  /* If: '<S40>/If' incorporates:\n   *  Math: '<S55>/transpose'\n   *  Product: '<S55>/Product'\n   *  Sqrt: '<S44>/Sqrt'\n   *  Sum: '<S41>/Sum1'\n   */\n  if (rtsiIsModeUpdateTimeStep(&(&multirotor0_M)->solverInfo)) {\n    rtAction = static_cast<int8_T>(!(std::sqrt((rtb_TrueairspeedBodyaxes_b[0] *\n      rtb_TrueairspeedBodyaxes_b[0] + rtb_TrueairspeedBodyaxes_b[1] *\n      rtb_TrueairspeedBodyaxes_b[1]) + rtb_TrueairspeedBodyaxes_b[2] *\n      rtb_TrueairspeedBodyaxes_b[2]) == 0.0));\n    multirotor0_DW.If_ActiveSubsystem = rtAction;\n  } else {\n    rtAction = multirotor0_DW.If_ActiveSubsystem;\n  }\n\n  if (rtAction == 0) {\n    /* Outputs for IfAction SubSystem: '<S40>/Zero airspeed' incorporates:\n     *  ActionPort: '<S43>/Action Port'\n     */\n    if (rtmIsMajorTimeStep((&multirotor0_M))) {\n      /* Merge: '<S40>/Merge' incorporates:\n       *  Constant: '<S43>/Constant'\n       */\n      multirotor0_B.Forceagainstdirectionofmotiondu[0] = 0.0;\n      multirotor0_B.Forceagainstdirectionofmotiondu[1] = 0.0;\n      multirotor0_B.Forceagainstdirectionofmotiondu[2] = 0.0;\n    }\n\n    /* End of Outputs for SubSystem: '<S40>/Zero airspeed' */\n  } else {\n    /* Outputs for IfAction SubSystem: '<S40>/Nonzero airspeed' incorporates:\n     *  ActionPort: '<S42>/Action Port'\n     */\n    /* Product: '<S50>/Divide' */\n    cphi = rtb_TrueairspeedBodyaxes_b[0] / multirotor0_B.Surface_params[0];\n\n    /* Product: '<S50>/Product' */\n    phi = cphi * cphi;\n\n    /* Product: '<S50>/Divide1' */\n    cphi = rtb_TrueairspeedBodyaxes_b[1] / multirotor0_B.Surface_params[1];\n\n    /* Product: '<S50>/Product1' */\n    ctheta = cphi * cphi;\n\n    /* Product: '<S50>/Divide2' */\n    cphi = rtb_TrueairspeedBodyaxes_b[2] / multirotor0_B.Surface_params[2];\n\n    /* Sum: '<S50>/Add' incorporates:\n     *  Product: '<S50>/Product2'\n     */\n    cphi = (phi + ctheta) + cphi * cphi;\n\n    /* Sqrt: '<S50>/Reciprocal Sqrt' */\n    if (cphi > 0.0) {\n      if (std::isinf(cphi)) {\n        cphi = 0.0;\n      } else {\n        cphi = 1.0 / std::sqrt(cphi);\n      }\n    } else if (cphi == 0.0) {\n      cphi = (rtInf);\n    } else {\n      cphi = (rtNaN);\n    }\n\n    /* End of Sqrt: '<S50>/Reciprocal Sqrt' */\n\n    /* Product: '<S51>/Product' incorporates:\n     *  Sum: '<S41>/Sum1'\n     */\n    phi = rtb_TrueairspeedBodyaxes_b[0] * cphi;\n\n    /* Product: '<S53>/Product' incorporates:\n     *  Math: '<S53>/transpose'\n     *  Product: '<S51>/Product'\n     */\n    ctheta = phi * phi;\n\n    /* Product: '<S51>/Product' incorporates:\n     *  Sum: '<S41>/Sum1'\n     */\n    phi = rtb_TrueairspeedBodyaxes_b[1] * cphi;\n\n    /* Product: '<S53>/Product' incorporates:\n     *  Math: '<S53>/transpose'\n     *  Product: '<S51>/Product'\n     */\n    ctheta += phi * phi;\n\n    /* Product: '<S51>/Product' incorporates:\n     *  Sum: '<S41>/Sum1'\n     */\n    phi = rtb_TrueairspeedBodyaxes_b[2] * cphi;\n\n    /* Product: '<S54>/Product' incorporates:\n     *  Product: '<S49>/Product'\n     *  Product: '<S51>/Product'\n     *  Sum: '<S41>/Sum1'\n     */\n    q1 = (rtb_TrueairspeedBodyaxes_b[0] * rtb_TrueairspeedBodyaxes_b[0] +\n          rtb_TrueairspeedBodyaxes_b[1] * rtb_TrueairspeedBodyaxes_b[1]) +\n      rtb_TrueairspeedBodyaxes_b[2] * rtb_TrueairspeedBodyaxes_b[2];\n\n    /* Abs: '<S42>/Abs' incorporates:\n     *  Constant: '<S42>/Constant'\n     *  Constant: '<S42>/Constant1'\n     *  Constant: '<S42>/Constant2'\n     *  Math: '<S53>/transpose'\n     *  Product: '<S42>/Product'\n     *  Product: '<S51>/Product'\n     *  Product: '<S53>/Product'\n     *  Product: '<S54>/Product'\n     *  Sqrt: '<S52>/Sqrt'\n     */\n    phi = std::abs(q1 * 0.6125 * 0.4 * std::sqrt(phi * phi + ctheta));\n\n    /* Sqrt: '<S48>/Sqrt' */\n    cphi = std::sqrt(q1);\n\n    /* Merge: '<S40>/Merge' incorporates:\n     *  Gain: '<S42>/Drag force opposes direction of airspeed'\n     *  Product: '<S42>/Product1'\n     *  Product: '<S45>/Divide'\n     *  Sum: '<S41>/Sum1'\n     */\n    multirotor0_B.Forceagainstdirectionofmotiondu[0] =\n      -(rtb_TrueairspeedBodyaxes_b[0] / cphi * phi);\n    multirotor0_B.Forceagainstdirectionofmotiondu[1] =\n      -(rtb_TrueairspeedBodyaxes_b[1] / cphi * phi);\n    multirotor0_B.Forceagainstdirectionofmotiondu[2] =\n      -(rtb_TrueairspeedBodyaxes_b[2] / cphi * phi);\n\n    /* End of Outputs for SubSystem: '<S40>/Nonzero airspeed' */\n  }\n\n  /* End of If: '<S40>/If' */\n\n  /* Sum: '<S11>/Sum' incorporates:\n   *  Integrator: '<S2>/V_b'\n   *  Integrator: '<S2>/omega'\n   *  Product: '<S34>/Product'\n   *  Product: '<S34>/Product1'\n   *  Product: '<S34>/Product2'\n   *  Product: '<S35>/Product'\n   *  Product: '<S35>/Product1'\n   *  Product: '<S35>/Product2'\n   */\n  rtb_TrueairspeedBodyaxes[0] = multirotor0_X.omega_CSTATE[1] *\n    multirotor0_X.V_b_CSTATE[2];\n  rtb_TrueairspeedBodyaxes[1] = multirotor0_X.V_b_CSTATE[0] *\n    multirotor0_X.omega_CSTATE[2];\n  rtb_TrueairspeedBodyaxes[2] = multirotor0_X.omega_CSTATE[0] *\n    multirotor0_X.V_b_CSTATE[1];\n  rtb_TrueairspeedBodyaxes_m[0] = multirotor0_X.V_b_CSTATE[1] *\n    multirotor0_X.omega_CSTATE[2];\n  rtb_TrueairspeedBodyaxes_m[1] = multirotor0_X.omega_CSTATE[0] *\n    multirotor0_X.V_b_CSTATE[2];\n  rtb_TrueairspeedBodyaxes_m[2] = multirotor0_X.V_b_CSTATE[0] *\n    multirotor0_X.omega_CSTATE[1];\n\n  /* Product: '<S38>/Product' */\n  cphi = multirotor0_B.ForceofgravityInertialaxes[1];\n  phi = multirotor0_B.ForceofgravityInertialaxes[0];\n  ctheta = multirotor0_B.ForceofgravityInertialaxes[2];\n\n  /* Integrator: '<S2>/omega' incorporates:\n   *  Product: '<S13>/Product'\n   */\n  theta = multirotor0_X.omega_CSTATE[1];\n  q1 = multirotor0_X.omega_CSTATE[0];\n  COM_system_inter_idx_0 = multirotor0_X.omega_CSTATE[2];\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n    /* Sum: '<S2>/Sum1' incorporates:\n     *  Concatenate: '<S33>/Vector Concatenate'\n     *  Inport: '<Root>/force_disturbance'\n     *  Merge: '<S40>/Merge'\n     *  Product: '<S2>/Product1'\n     *  Product: '<S38>/Product'\n     *  Sum: '<S11>/Sum'\n     *  Sum: '<S16>/Sum'\n     *  Sum: '<S4>/Sum'\n     *  Sum: '<S4>/Sum1'\n     *  Sum: '<S4>/Sum3'\n     */\n    multirotor0_B.Sum1[xpageoffset] = (((((rtb_VectorConcatenate[xpageoffset + 3]\n      * cphi + rtb_VectorConcatenate[xpageoffset] * phi) +\n      rtb_VectorConcatenate[xpageoffset + 6] * ctheta) + rtb_Sum_a[xpageoffset])\n      + multirotor0_B.Forceagainstdirectionofmotiondu[xpageoffset]) +\n      multirotor0_U.Force_disturb[xpageoffset]) / multirotor0_B.total_mass -\n      (rtb_TrueairspeedBodyaxes[xpageoffset] -\n       rtb_TrueairspeedBodyaxes_m[xpageoffset]);\n\n    /* Product: '<S13>/Product' incorporates:\n     *  Integrator: '<S2>/omega'\n     *  Product: '<S8>/Product'\n     */\n    rtb_TrueairspeedBodyaxes_b[xpageoffset] =\n      (multirotor0_B.inertial_matrix[xpageoffset + 3] * theta +\n       multirotor0_B.inertial_matrix[xpageoffset] * q1) +\n      multirotor0_B.inertial_matrix[xpageoffset + 6] * COM_system_inter_idx_0;\n  }\n\n  /* Sum: '<S12>/Sum' incorporates:\n   *  Integrator: '<S2>/omega'\n   *  Product: '<S14>/Product'\n   *  Product: '<S14>/Product1'\n   *  Product: '<S14>/Product2'\n   *  Product: '<S15>/Product'\n   *  Product: '<S15>/Product1'\n   *  Product: '<S15>/Product2'\n   */\n  rtb_TrueairspeedBodyaxes[0] = multirotor0_X.omega_CSTATE[1] *\n    rtb_TrueairspeedBodyaxes_b[2];\n  rtb_TrueairspeedBodyaxes[1] = rtb_TrueairspeedBodyaxes_b[0] *\n    multirotor0_X.omega_CSTATE[2];\n  rtb_TrueairspeedBodyaxes[2] = multirotor0_X.omega_CSTATE[0] *\n    rtb_TrueairspeedBodyaxes_b[1];\n  rtb_TrueairspeedBodyaxes_m[0] = rtb_TrueairspeedBodyaxes_b[1] *\n    multirotor0_X.omega_CSTATE[2];\n  rtb_TrueairspeedBodyaxes_m[1] = multirotor0_X.omega_CSTATE[0] *\n    rtb_TrueairspeedBodyaxes_b[2];\n  rtb_TrueairspeedBodyaxes_m[2] = rtb_TrueairspeedBodyaxes_b[0] *\n    multirotor0_X.omega_CSTATE[1];\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\n    rtb_TrueairspeedBodyaxes_b[xpageoffset] =\n      rtb_TrueairspeedBodyaxes[xpageoffset] -\n      rtb_TrueairspeedBodyaxes_m[xpageoffset];\n\n    /* Sum: '<S39>/Sum of Elements1' incorporates:\n     *  ForEachSliceAssignment generated from: '<S57>/Motor_moment'\n     *  Sum: '<S16>/Sum'\n     */\n    rtb_Sum_a[xpageoffset] = ((rtb_ImpAsg_InsertedFor_Motor_mo[xpageoffset + 3]\n      + rtb_ImpAsg_InsertedFor_Motor_mo[xpageoffset]) +\n      rtb_ImpAsg_InsertedFor_Motor_mo[xpageoffset + 6]) +\n      rtb_ImpAsg_InsertedFor_Motor_mo[xpageoffset + 9];\n  }\n\n  /* End of Sum: '<S12>/Sum' */\n\n  /* Product: '<S17>/Product' */\n  q1 = 0.0;\n\n  /* SignalConversion generated from: '<S8>/Q-Integrator' incorporates:\n   *  Gain: '<S8>/1//2'\n   *  Integrator: '<S2>/omega'\n   *  Product: '<S20>/Product'\n   *  Product: '<S20>/Product1'\n   *  Product: '<S20>/Product2'\n   *  Product: '<S21>/Product'\n   *  Product: '<S21>/Product1'\n   *  Product: '<S21>/Product2'\n   *  Product: '<S8>/Product'\n   *  Sum: '<S16>/Sum'\n   *  Sum: '<S8>/Subtract'\n   */\n  multirotor0_B.TmpSignalConversionAtQIntegrato[1] = (rtb_Divide[0] *\n    multirotor0_X.omega_CSTATE[0] - (multirotor0_X.omega_CSTATE[1] * rtb_Divide\n    [3] - multirotor0_X.omega_CSTATE[2] * rtb_Divide[2])) * 0.5;\n  multirotor0_B.TmpSignalConversionAtQIntegrato[2] = (rtb_Divide[0] *\n    multirotor0_X.omega_CSTATE[1] - (rtb_Divide[1] * multirotor0_X.omega_CSTATE\n    [2] - multirotor0_X.omega_CSTATE[0] * rtb_Divide[3])) * 0.5;\n  multirotor0_B.TmpSignalConversionAtQIntegrato[3] = (rtb_Divide[0] *\n    multirotor0_X.omega_CSTATE[2] - (multirotor0_X.omega_CSTATE[0] * rtb_Divide\n    [2] - multirotor0_X.omega_CSTATE[1] * rtb_Divide[1])) * 0.5;\n\n  /* Fcn: '<S9>/Fcn1' */\n  rtb_VectorConcatenate_tmp_2 *= 2.0;\n\n  /* Trigonometry: '<S9>/Trigonometric Function' */\n  if (rtb_VectorConcatenate_tmp_2 > 1.0) {\n    rtb_VectorConcatenate_tmp_2 = 1.0;\n  } else if (rtb_VectorConcatenate_tmp_2 < -1.0) {\n    rtb_VectorConcatenate_tmp_2 = -1.0;\n  }\n\n  /* Gain: '<S9>/Gain' incorporates:\n   *  Outport: '<Root>/Euler'\n   *  Trigonometry: '<S9>/Trigonometric Function'\n   */\n  multirotor0_Y.Euler[1] = -std::asin(rtb_VectorConcatenate_tmp_2);\n\n  /* Trigonometry: '<S9>/Trigonometric Function1' incorporates:\n   *  Fcn: '<S9>/Fcn'\n   *  Outport: '<Root>/Euler'\n   */\n  multirotor0_Y.Euler[0] = rt_atan2d_snf(rtb_VectorConcatenate_tmp_1 * 2.0,\n    rtb_VectorConcatenate_tmp_0);\n\n  /* Trigonometry: '<S9>/Trigonometric Function2' incorporates:\n   *  Fcn: '<S9>/Fcn2'\n   *  Outport: '<Root>/Euler'\n   */\n  multirotor0_Y.Euler[2] = rt_atan2d_snf(rtb_VectorConcatenate_tmp * 2.0,\n    rtb_VectorConcatenate_tmp_3);\n  for (i = 0; i < 3; i++) {\n    /* Sum: '<S7>/Sum1' incorporates:\n     *  Inport: '<Root>/moment_disturbance'\n     *  Product: '<S8>/Product'\n     *  Sum: '<S16>/Sum'\n     *  Sum: '<S4>/Sum2'\n     */\n    rtb_TrueairspeedBodyaxes[i] = (rtb_Sum_a[i] + multirotor0_U.Moment_disturb[i])\n      - rtb_TrueairspeedBodyaxes_b[i];\n\n    /* Product: '<S17>/Product' incorporates:\n     *  Integrator: '<S2>/omega'\n     */\n    q1 += rtb_Divide[i + 1] * multirotor0_X.omega_CSTATE[i];\n\n    /* Outport: '<Root>/X_i' incorporates:\n     *  Integrator: '<S2>/X_i'\n     */\n    multirotor0_Y.X_i[i] = multirotor0_X.X_i_CSTATE[i];\n\n    /* Outport: '<Root>/V_i' incorporates:\n     *  Product: '<S5>/Product'\n     */\n    multirotor0_Y.V_i[i] = multirotor0_B.Product[i];\n\n    /* Outport: '<Root>/V_b' incorporates:\n     *  Integrator: '<S2>/V_b'\n     */\n    multirotor0_Y.V_b[i] = multirotor0_X.V_b_CSTATE[i];\n\n    /* Outport: '<Root>/a_b' incorporates:\n     *  Sum: '<S2>/Sum1'\n     */\n    multirotor0_Y.a_b[i] = multirotor0_B.Sum1[i];\n\n    /* Outport: '<Root>/a_i' incorporates:\n     *  Math: '<S6>/Math Function2'\n     *  Product: '<S6>/Product'\n     *  Sum: '<S2>/Sum1'\n     */\n    multirotor0_Y.a_i[i] = (Product_tmp[i + 3] * multirotor0_B.Sum1[1] +\n      Product_tmp[i] * multirotor0_B.Sum1[0]) + Product_tmp[i + 6] *\n      multirotor0_B.Sum1[2];\n  }\n\n  /* Product: '<S7>/Product' */\n  rt_mldivide_U1d3x3_U2d_JBYZyA3A(multirotor0_B.inertial_matrix,\n    rtb_TrueairspeedBodyaxes, multirotor0_B.Product_l);\n\n  /* SignalConversion generated from: '<S8>/Q-Integrator' incorporates:\n   *  Gain: '<S8>/-1//2'\n   *  Product: '<S17>/Product'\n   */\n  multirotor0_B.TmpSignalConversionAtQIntegrato[0] = -0.5 * q1;\n\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n\n  /* Outport: '<Root>/DCM_ib' incorporates:\n   *  Concatenate: '<S33>/Vector Concatenate'\n   */\n  std::memcpy(&multirotor0_Y.DCM_ib[0], &rtb_VectorConcatenate[0], 9U * sizeof\n              (real_T));\n\n  /* Outport: '<Root>/Quat q' incorporates:\n   *  Product: '<S19>/Divide'\n   */\n  multirotor0_Y.Quatq[0] = rtb_Divide[0];\n  multirotor0_Y.Quatq[1] = rtb_Divide[1];\n  multirotor0_Y.Quatq[2] = rtb_Divide[2];\n  multirotor0_Y.Quatq[3] = rtb_Divide[3];\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  /* Outport: '<Root>/omega' incorporates:\n   *  Integrator: '<S2>/omega'\n   */\n  multirotor0_Y.omega[0] = multirotor0_X.omega_CSTATE[0];\n\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n\n  /* Outport: '<Root>/omega_dot' incorporates:\n   *  Product: '<S7>/Product'\n   */\n  multirotor0_Y.omega_dot[0] = multirotor0_B.Product_l[0];\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  /* Outport: '<Root>/omega' incorporates:\n   *  Integrator: '<S2>/omega'\n   */\n  multirotor0_Y.omega[1] = multirotor0_X.omega_CSTATE[1];\n\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n\n  /* Outport: '<Root>/omega_dot' incorporates:\n   *  Product: '<S7>/Product'\n   */\n  multirotor0_Y.omega_dot[1] = multirotor0_B.Product_l[1];\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  /* Outport: '<Root>/omega' incorporates:\n   *  Integrator: '<S2>/omega'\n   */\n  multirotor0_Y.omega[2] = multirotor0_X.omega_CSTATE[2];\n\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n\n  /* Outport: '<Root>/omega_dot' incorporates:\n   *  Product: '<S7>/Product'\n   */\n  multirotor0_Y.omega_dot[2] = multirotor0_B.Product_l[2];\n\n  /* Outport: '<Root>/motor_RPM' incorporates:\n   *  ForEachSliceAssignment generated from: '<S57>/RPM_motor'\n   */\n  multirotor0_Y.motor_RPM[0] = rtb_ImpAsg_InsertedFor_RPM_moto[0];\n  multirotor0_Y.motor_RPM[1] = rtb_ImpAsg_InsertedFor_RPM_moto[1];\n  multirotor0_Y.motor_RPM[2] = rtb_ImpAsg_InsertedFor_RPM_moto[2];\n  multirotor0_Y.motor_RPM[3] = rtb_ImpAsg_InsertedFor_RPM_moto[3];\n  if (rtmIsMajorTimeStep((&multirotor0_M))) {\n    /* Update for Atomic SubSystem: '<Root>/multirotor' */\n    /* Update for Integrator: '<S8>/Q-Integrator' */\n    multirotor0_DW.QIntegrator_IWORK = 0;\n\n    /* End of Update for SubSystem: '<Root>/multirotor' */\n  }                                    /* end MajorTimeStep */\n\n  if (rtmIsMajorTimeStep((&multirotor0_M))) {\n    rt_ertODEUpdateContinuousStates(&(&multirotor0_M)->solverInfo);\n\n    /* Update absolute time */\n    /* The \"clockTick0\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n     * overflow during the application lifespan selected.\n     */\n    ++(&multirotor0_M)->Timing.clockTick0;\n    (&multirotor0_M)->Timing.t[0] = rtsiGetSolverStopTime(&(&multirotor0_M)\n      ->solverInfo);\n\n    /* Update absolute time */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The resolution of this integer timer is 0.001, which is the step size\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n     * application lifespan selected.\n     */\n    (&multirotor0_M)->Timing.clockTick1++;\n  }                                    /* end MajorTimeStep */\n}\n\n/* Derivatives for root system: '<Root>' */\nvoid multirotor0::multirotor0_derivatives()\n{\n  /* local scratch DWork variables */\n  int32_T ForEach_itr;\n  XDot_multirotor0_T *_rtXdot;\n  _rtXdot = ((XDot_multirotor0_T *) (&multirotor0_M)->derivs);\n\n  /* Derivatives for Atomic SubSystem: '<Root>/multirotor' */\n  /* Derivatives for Integrator: '<S8>/Q-Integrator' incorporates:\n   *  SignalConversion generated from: '<S8>/Q-Integrator'\n   */\n  _rtXdot->QIntegrator_CSTATE[0] =\n    multirotor0_B.TmpSignalConversionAtQIntegrato[0];\n  _rtXdot->QIntegrator_CSTATE[1] =\n    multirotor0_B.TmpSignalConversionAtQIntegrato[1];\n  _rtXdot->QIntegrator_CSTATE[2] =\n    multirotor0_B.TmpSignalConversionAtQIntegrato[2];\n  _rtXdot->QIntegrator_CSTATE[3] =\n    multirotor0_B.TmpSignalConversionAtQIntegrato[3];\n\n  /* Derivatives for Integrator: '<S2>/V_b' incorporates:\n   *  Sum: '<S2>/Sum1'\n   */\n  _rtXdot->V_b_CSTATE[0] = multirotor0_B.Sum1[0];\n\n  /* Derivatives for Integrator: '<S2>/omega' incorporates:\n   *  Product: '<S7>/Product'\n   */\n  _rtXdot->omega_CSTATE[0] = multirotor0_B.Product_l[0];\n\n  /* Derivatives for Integrator: '<S2>/V_b' incorporates:\n   *  Sum: '<S2>/Sum1'\n   */\n  _rtXdot->V_b_CSTATE[1] = multirotor0_B.Sum1[1];\n\n  /* Derivatives for Integrator: '<S2>/omega' incorporates:\n   *  Product: '<S7>/Product'\n   */\n  _rtXdot->omega_CSTATE[1] = multirotor0_B.Product_l[1];\n\n  /* Derivatives for Integrator: '<S2>/V_b' incorporates:\n   *  Sum: '<S2>/Sum1'\n   */\n  _rtXdot->V_b_CSTATE[2] = multirotor0_B.Sum1[2];\n\n  /* Derivatives for Integrator: '<S2>/omega' incorporates:\n   *  Product: '<S7>/Product'\n   */\n  _rtXdot->omega_CSTATE[2] = multirotor0_B.Product_l[2];\n\n  /* Derivatives for Iterator SubSystem: '<S39>/For Each Subsystem' */\n  for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n    /* Derivatives for Integrator: '<S63>/Integrator' */\n    _rtXdot->CoreSubsys[ForEach_itr].Integrator_CSTATE =\n      multirotor0_B.CoreSubsys[ForEach_itr].Switch;\n\n    /* Derivatives for Integrator: '<S64>/Integrator' */\n    _rtXdot->CoreSubsys[ForEach_itr].Integrator_CSTATE_o =\n      multirotor0_B.CoreSubsys[ForEach_itr].Switch_a;\n  }\n\n  /* End of Derivatives for SubSystem: '<S39>/For Each Subsystem' */\n\n  /* Derivatives for Integrator: '<S2>/X_i' incorporates:\n   *  Product: '<S5>/Product'\n   */\n  _rtXdot->X_i_CSTATE[0] = multirotor0_B.Product[0];\n  _rtXdot->X_i_CSTATE[1] = multirotor0_B.Product[1];\n  _rtXdot->X_i_CSTATE[2] = multirotor0_B.Product[2];\n\n  /* End of Derivatives for SubSystem: '<Root>/multirotor' */\n}\n\n/* Model step function for TID2 */\nvoid multirotor0::step2()              /* Sample time: [0.002s, 0.0s] */\n{\n  /* Update for Atomic SubSystem: '<Root>/multirotor' */\n  /* Update for RateTransition: '<S1>/Rate Transition1' incorporates:\n   *  Inport: '<Root>/RPM commands'\n   */\n  multirotor0_DW.RateTransition1_Buffer0[0] = multirotor0_U.RPMcommands[0];\n  multirotor0_DW.RateTransition1_Buffer0[1] = multirotor0_U.RPMcommands[1];\n  multirotor0_DW.RateTransition1_Buffer0[2] = multirotor0_U.RPMcommands[2];\n  multirotor0_DW.RateTransition1_Buffer0[3] = multirotor0_U.RPMcommands[3];\n\n  /* End of Update for SubSystem: '<Root>/multirotor' */\n}\n\n/* Model initialize function */\nvoid multirotor0::initialize()\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* Set task counter limit used by the static main program */\n  ((&multirotor0_M))->Timing.TaskCounters.cLimit[0] = 1;\n  ((&multirotor0_M))->Timing.TaskCounters.cLimit[1] = 1;\n  ((&multirotor0_M))->Timing.TaskCounters.cLimit[2] = 2;\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&(&multirotor0_M)->solverInfo, &(&multirotor0_M)\n                          ->Timing.simTimeStep);\n    rtsiSetTPtr(&(&multirotor0_M)->solverInfo, &rtmGetTPtr((&multirotor0_M)));\n    rtsiSetStepSizePtr(&(&multirotor0_M)->solverInfo, &(&multirotor0_M)\n                       ->Timing.stepSize0);\n    rtsiSetdXPtr(&(&multirotor0_M)->solverInfo, &(&multirotor0_M)->derivs);\n    rtsiSetContStatesPtr(&(&multirotor0_M)->solverInfo, (real_T **)\n                         &(&multirotor0_M)->contStates);\n    rtsiSetNumContStatesPtr(&(&multirotor0_M)->solverInfo, &(&multirotor0_M)\n      ->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&(&multirotor0_M)->solverInfo,\n      &(&multirotor0_M)->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&(&multirotor0_M)->solverInfo,\n      &(&multirotor0_M)->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&(&multirotor0_M)->solverInfo,\n      &(&multirotor0_M)->periodicContStateRanges);\n    rtsiSetErrorStatusPtr(&(&multirotor0_M)->solverInfo, (&rtmGetErrorStatus\n      ((&multirotor0_M))));\n    rtsiSetRTModelPtr(&(&multirotor0_M)->solverInfo, (&multirotor0_M));\n  }\n\n  rtsiSetSimTimeStep(&(&multirotor0_M)->solverInfo, MAJOR_TIME_STEP);\n  (&multirotor0_M)->intgData.y = (&multirotor0_M)->odeY;\n  (&multirotor0_M)->intgData.f[0] = (&multirotor0_M)->odeF[0];\n  (&multirotor0_M)->intgData.f[1] = (&multirotor0_M)->odeF[1];\n  (&multirotor0_M)->intgData.f[2] = (&multirotor0_M)->odeF[2];\n  (&multirotor0_M)->contStates = ((X_multirotor0_T *) &multirotor0_X);\n  rtsiSetSolverData(&(&multirotor0_M)->solverInfo, static_cast<void *>\n                    (&(&multirotor0_M)->intgData));\n  rtsiSetIsMinorTimeStepWithModeChange(&(&multirotor0_M)->solverInfo, false);\n  rtsiSetSolverName(&(&multirotor0_M)->solverInfo,\"ode3\");\n  rtmSetTPtr((&multirotor0_M), &(&multirotor0_M)->Timing.tArray[0]);\n  (&multirotor0_M)->Timing.stepSize0 = 0.001;\n  rtmSetFirstInitCond((&multirotor0_M), 1);\n\n  {\n    /* local scratch DWork variables */\n    int32_T ForEach_itr;\n\n    /* Start for Atomic SubSystem: '<Root>/multirotor' */\n    /* Start for RateTransition: '<S1>/Rate Transition1' */\n    multirotor0_B.RateTransition1[0] = 3104.5025852;\n    multirotor0_B.RateTransition1[1] = 3104.5025852;\n    multirotor0_B.RateTransition1[2] = 3104.5025852;\n    multirotor0_B.RateTransition1[3] = 3104.5025852;\n\n    /* Start for Iterator SubSystem: '<S39>/For Each Subsystem' */\n    for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n      /* Start for If: '<S90>/If' */\n      multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem = -1;\n\n      /* Start for If: '<S88>/If' */\n      multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem_l = -1;\n\n      /* Start for If: '<S76>/If' */\n      multirotor0_DW.CoreSubsys[ForEach_itr].If_ActiveSubsystem_e = -1;\n    }\n\n    /* End of Start for SubSystem: '<S39>/For Each Subsystem' */\n\n    /* Start for If: '<S40>/If' */\n    multirotor0_DW.If_ActiveSubsystem = -1;\n\n    /* End of Start for SubSystem: '<Root>/multirotor' */\n  }\n\n  {\n    /* local scratch DWork variables */\n    int32_T ForEach_itr;\n\n    /* SystemInitialize for Atomic SubSystem: '<Root>/multirotor' */\n    /* InitializeConditions for Integrator: '<S8>/Q-Integrator' */\n    if (rtmIsFirstInitCond((&multirotor0_M))) {\n      multirotor0_X.QIntegrator_CSTATE[0] = 0.0;\n      multirotor0_X.QIntegrator_CSTATE[1] = 0.0;\n      multirotor0_X.QIntegrator_CSTATE[2] = 0.0;\n      multirotor0_X.QIntegrator_CSTATE[3] = 0.0;\n    }\n\n    multirotor0_DW.QIntegrator_IWORK = 1;\n\n    /* End of InitializeConditions for Integrator: '<S8>/Q-Integrator' */\n\n    /* InitializeConditions for Integrator: '<S2>/V_b' */\n    multirotor0_X.V_b_CSTATE[0] = 0.0;\n    multirotor0_X.V_b_CSTATE[1] = 0.0;\n    multirotor0_X.V_b_CSTATE[2] = 0.0;\n\n    /* InitializeConditions for RateTransition: '<S1>/Rate Transition1' */\n    multirotor0_DW.RateTransition1_Buffer0[0] = 3104.5025852;\n    multirotor0_DW.RateTransition1_Buffer0[1] = 3104.5025852;\n    multirotor0_DW.RateTransition1_Buffer0[2] = 3104.5025852;\n    multirotor0_DW.RateTransition1_Buffer0[3] = 3104.5025852;\n\n    /* InitializeConditions for Integrator: '<S2>/omega' */\n    multirotor0_X.omega_CSTATE[0] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S2>/X_i' */\n    multirotor0_X.X_i_CSTATE[0] = 0.0;\n\n    /* SystemInitialize for IfAction SubSystem: '<S40>/Zero airspeed' */\n    /* SystemInitialize for Merge: '<S40>/Merge' incorporates:\n     *  Outport: '<S43>/Drag force'\n     */\n    multirotor0_B.Forceagainstdirectionofmotiondu[0] = 0.0;\n\n    /* End of SystemInitialize for SubSystem: '<S40>/Zero airspeed' */\n\n    /* InitializeConditions for Integrator: '<S2>/omega' */\n    multirotor0_X.omega_CSTATE[1] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S2>/X_i' */\n    multirotor0_X.X_i_CSTATE[1] = 0.0;\n\n    /* SystemInitialize for IfAction SubSystem: '<S40>/Zero airspeed' */\n    /* SystemInitialize for Merge: '<S40>/Merge' incorporates:\n     *  Outport: '<S43>/Drag force'\n     */\n    multirotor0_B.Forceagainstdirectionofmotiondu[1] = 0.0;\n\n    /* End of SystemInitialize for SubSystem: '<S40>/Zero airspeed' */\n\n    /* InitializeConditions for Integrator: '<S2>/omega' */\n    multirotor0_X.omega_CSTATE[2] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S2>/X_i' */\n    multirotor0_X.X_i_CSTATE[2] = 0.0;\n\n    /* SystemInitialize for IfAction SubSystem: '<S40>/Zero airspeed' */\n    /* SystemInitialize for Merge: '<S40>/Merge' incorporates:\n     *  Outport: '<S43>/Drag force'\n     */\n    multirotor0_B.Forceagainstdirectionofmotiondu[2] = -1.0;\n\n    /* End of SystemInitialize for SubSystem: '<S40>/Zero airspeed' */\n\n    /* SystemInitialize for Iterator SubSystem: '<S39>/For Each Subsystem' */\n    for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n      /* InitializeConditions for Integrator: '<S63>/Integrator' */\n      multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE = 3104.5025852;\n\n      /* InitializeConditions for Integrator: '<S64>/Integrator' */\n      multirotor0_X.CoreSubsys[ForEach_itr].Integrator_CSTATE_o = 3104.5025852;\n\n      /* SystemInitialize for IfAction SubSystem: '<S76>/Zero airspeed in rotor plane' */\n      /* SystemInitialize for Merge: '<S76>/Merge' incorporates:\n       *  Outport: '<S83>/Thrust direction (Body)'\n       */\n      multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[0] =\n        0.0;\n      multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[1] =\n        0.0;\n      multirotor0_B.CoreSubsys[ForEach_itr].NewtiltedthrustdirectionBodyaxe[2] =\n        -1.0;\n\n      /* End of SystemInitialize for SubSystem: '<S76>/Zero airspeed in rotor plane' */\n    }\n\n    /* End of SystemInitialize for SubSystem: '<S39>/For Each Subsystem' */\n    /* End of SystemInitialize for SubSystem: '<Root>/multirotor' */\n\n    /* set \"at time zero\" to false */\n    if (rtmIsFirstInitCond((&multirotor0_M))) {\n      rtmSetFirstInitCond((&multirotor0_M), 0);\n    }\n  }\n}\n\n/* Model terminate function */\nvoid multirotor0::terminate()\n{\n  /* (no terminate code required) */\n}\n\n/* Constructor */\nmultirotor0::multirotor0() :\n  multirotor0_U(),\n  multirotor0_Y(),\n  multirotor0_B(),\n  multirotor0_DW(),\n  multirotor0_X(),\n  multirotor0_M()\n{\n  /* Currently there is no constructor body generated.*/\n}\n\n/* Destructor */\n/* Currently there is no destructor body generated.*/\nmultirotor0::~multirotor0() = default;\n\n/* Real-Time Model get method */\nRT_MODEL_multirotor0_T * multirotor0::getRTM()\n{\n  return (&multirotor0_M);\n}\n"},{"name":"multirotor0.h","type":"header","group":"model","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * multirotor0.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_multirotor0_h_\n#define RTW_HEADER_multirotor0_h_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"multirotor0_types.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <cstring>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContStateDisabled\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\n#endif\n\n#ifndef rtmSetContStateDisabled\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\n#endif\n\n#ifndef rtmGetContStates\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\n#endif\n\n#ifndef rtmSetContStates\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\n#endif\n\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetIntgData\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\n#endif\n\n#ifndef rtmSetIntgData\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\n#endif\n\n#ifndef rtmGetOdeF\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\n#endif\n\n#ifndef rtmSetOdeF\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\n#endif\n\n#ifndef rtmGetOdeY\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\n#endif\n\n#ifndef rtmSetOdeY\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateIndices\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\n#endif\n\n#ifndef rtmSetPeriodicContStateIndices\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateRanges\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\n#endif\n\n#ifndef rtmSetPeriodicContStateRanges\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetdX\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\n#endif\n\n#ifndef rtmSetdX\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\n#endif\n\n#ifndef rtmCounterLimit\n#define rtmCounterLimit(rtm, idx)      ((rtm)->Timing.TaskCounters.cLimit[(idx)])\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmStepTask\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmTaskCounter\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\n#endif\n\n/* Block signals for system '<S39>/For Each Subsystem' */\nstruct B_CoreSubsys_multirotor0_T {\n  real_T Product;                      /* '<S59>/Product' */\n  real_T Switch;                       /* '<S63>/Switch' */\n  real_T Switch_a;                     /* '<S64>/Switch' */\n  real_T VectorfromrealCoGtopropellerBod[3];/* '<S61>/Subtract' */\n  real_T VectorConcatenate[9];         /* '<S114>/Vector Concatenate' */\n  real_T Climbspeedv_c;                /* '<S89>/Gain' */\n  real_T Merge;                        /* '<S90>/Merge' */\n  real_T Product9[3];                  /* '<S81>/Product9' */\n  real_T Gain1;                        /* '<S101>/Gain1' */\n  real_T Angleofattackrad;             /* '<S88>/Merge' */\n  real_T NewtiltedthrustdirectionBodyaxe[3];/* '<S76>/Merge' */\n  real_T Momentinthemotorhubduetobending[3];/* '<S76>/Merge1' */\n};\n\n/* Block states (default storage) for system '<S39>/For Each Subsystem' */\nstruct DW_CoreSubsys_multirotor0_T {\n  int8_T If_ActiveSubsystem;           /* '<S90>/If' */\n  int8_T If_ActiveSubsystem_l;         /* '<S88>/If' */\n  int8_T If_ActiveSubsystem_e;         /* '<S76>/If' */\n};\n\n/* Continuous states for system '<S39>/For Each Subsystem' */\nstruct X_CoreSubsys_multirotor0_T {\n  real_T Integrator_CSTATE;            /* '<S63>/Integrator' */\n  real_T Integrator_CSTATE_o;          /* '<S64>/Integrator' */\n};\n\n/* State derivatives for system '<S39>/For Each Subsystem' */\nstruct XDot_CoreSubsys_multirotor0_T {\n  real_T Integrator_CSTATE;            /* '<S63>/Integrator' */\n  real_T Integrator_CSTATE_o;          /* '<S64>/Integrator' */\n};\n\n/* State Disabled for system '<S39>/For Each Subsystem' */\nstruct XDis_CoreSubsys_multirotor0_T {\n  boolean_T Integrator_CSTATE;         /* '<S63>/Integrator' */\n  boolean_T Integrator_CSTATE_o;       /* '<S64>/Integrator' */\n};\n\n/* Block signals (default storage) */\nstruct B_multirotor0_T {\n  real_T Product[3];                   /* '<S5>/Product' */\n  real_T RateTransition1[4];           /* '<S1>/Rate Transition1' */\n  real_T ForceofgravityInertialaxes[3];/* '<S38>/Product1' */\n  real_T Sum1[3];                      /* '<S2>/Sum1' */\n  real_T Product_l[3];                 /* '<S7>/Product' */\n  real_T TmpSignalConversionAtQIntegrato[4];\n  real_T MotorMatrix_real[68];         /* '<S3>/MATLAB Function' */\n  real_T COM_system[3];                /* '<S3>/MATLAB Function' */\n  real_T total_mass;                   /* '<S3>/MATLAB Function' */\n  real_T inertial_matrix[9];           /* '<S3>/MATLAB Function' */\n  real_T Surface_params[3];            /* '<S3>/MATLAB Function' */\n  real_T quat_output[4];               /* '<S8>/MATLAB Function' */\n  real_T Forceagainstdirectionofmotiondu[3];/* '<S40>/Merge' */\n  B_CoreSubsys_multirotor0_T CoreSubsys[4];/* '<S39>/For Each Subsystem' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_multirotor0_T {\n  real_T RateTransition1_Buffer0[4];   /* '<S1>/Rate Transition1' */\n  int_T QIntegrator_IWORK;             /* '<S8>/Q-Integrator' */\n  int8_T If_ActiveSubsystem;           /* '<S40>/If' */\n  DW_CoreSubsys_multirotor0_T CoreSubsys[4];/* '<S39>/For Each Subsystem' */\n};\n\n/* Continuous states (default storage) */\nstruct X_multirotor0_T {\n  real_T QIntegrator_CSTATE[4];        /* '<S8>/Q-Integrator' */\n  real_T V_b_CSTATE[3];                /* '<S2>/V_b' */\n  real_T omega_CSTATE[3];              /* '<S2>/omega' */\n  real_T X_i_CSTATE[3];                /* '<S2>/X_i' */\n  X_CoreSubsys_multirotor0_T CoreSubsys[4];/* '<S57>/CoreSubsys' */\n};\n\n/* State derivatives (default storage) */\nstruct XDot_multirotor0_T {\n  real_T QIntegrator_CSTATE[4];        /* '<S8>/Q-Integrator' */\n  real_T V_b_CSTATE[3];                /* '<S2>/V_b' */\n  real_T omega_CSTATE[3];              /* '<S2>/omega' */\n  real_T X_i_CSTATE[3];                /* '<S2>/X_i' */\n  XDot_CoreSubsys_multirotor0_T CoreSubsys[4];/* '<S57>/CoreSubsys' */\n};\n\n/* State disabled  */\nstruct XDis_multirotor0_T {\n  boolean_T QIntegrator_CSTATE[4];     /* '<S8>/Q-Integrator' */\n  boolean_T V_b_CSTATE[3];             /* '<S2>/V_b' */\n  boolean_T omega_CSTATE[3];           /* '<S2>/omega' */\n  boolean_T X_i_CSTATE[3];             /* '<S2>/X_i' */\n  XDis_CoreSubsys_multirotor0_T CoreSubsys[4];/* '<S57>/CoreSubsys' */\n};\n\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n/* ODE3 Integration Data */\nstruct ODE3_IntgData {\n  real_T *y;                           /* output */\n  real_T *f[3];                        /* derivatives */\n};\n\n#endif\n\n/* External inputs (root inport signals with default storage) */\nstruct ExtU_multirotor0_T {\n  real_T RPMcommands[4];               /* '<Root>/RPM commands' */\n  real_T Wind_i[3];                    /* '<Root>/wind' */\n  real_T Force_disturb[3];             /* '<Root>/force_disturbance' */\n  real_T Moment_disturb[3];            /* '<Root>/moment_disturbance' */\n  real_T arm_length[4];                /* '<Root>/arm_length' */\n  real_T prop_height[4];               /* '<Root>/prop_height' */\n  real_T prop_diameter[4];             /* '<Root>/prop_diameter' */\n  real_T rotation_direction[4];        /* '<Root>/rotation_direction' */\n  real_T max_rpm[4];                   /* '<Root>/max_rpm' */\n  real_T min_rpm[4];                   /* '<Root>/min_rpm' */\n  real_T arm_radius[4];                /* '<Root>/arm_radius' */\n  real_T Motor_arm_angle[4];           /* '<Root>/Motor_arm_angle' */\n  real_T mass_center;                  /* '<Root>/mass_center' */\n  real_T COM_mass_center[3];           /* '<Root>/COM_mass_center' */\n  real_T Surface_params[3];            /* '<Root>/Surface_params' */\n};\n\n/* External outputs (root outports fed by signals with default storage) */\nstruct ExtY_multirotor0_T {\n  real_T X_i[3];                       /* '<Root>/X_i' */\n  real_T V_i[3];                       /* '<Root>/V_i' */\n  real_T V_b[3];                       /* '<Root>/V_b' */\n  real_T a_b[3];                       /* '<Root>/a_b' */\n  real_T a_i[3];                       /* '<Root>/a_i' */\n  real_T DCM_ib[9];                    /* '<Root>/DCM_ib' */\n  real_T Quatq[4];                     /* '<Root>/Quat q' */\n  real_T Euler[3];                     /* '<Root>/Euler' */\n  real_T omega[3];                     /* '<Root>/omega' */\n  real_T omega_dot[3];                 /* '<Root>/omega_dot' */\n  real_T motor_RPM[4];                 /* '<Root>/motor_RPM' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_multirotor0_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n  X_multirotor0_T *contStates;\n  int_T *periodicContStateIndices;\n  real_T *periodicContStateRanges;\n  real_T *derivs;\n  XDis_multirotor0_T *contStateDisabled;\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n  real_T odeY[21];\n  real_T odeF[3][21];\n  ODE3_IntgData intgData;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    int_T numContStates;\n    int_T numPeriodicContStates;\n    int_T numSampTimes;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    boolean_T firstInitCondFlag;\n    struct {\n      uint8_T TID[3];\n      uint8_T cLimit[3];\n    } TaskCounters;\n\n    struct {\n      uint8_T TID1_2;\n    } RateInteraction;\n\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[3];\n  } Timing;\n};\n\n/* Class declaration for model multirotor0 */\nclass multirotor0 final\n{\n  /* public data and function members */\n public:\n  /* Copy Constructor */\n  multirotor0(multirotor0 const&) = delete;\n\n  /* Assignment Operator */\n  multirotor0& operator= (multirotor0 const&) & = delete;\n\n  /* Move Constructor */\n  multirotor0(multirotor0 &&) = delete;\n\n  /* Move Assignment Operator */\n  multirotor0& operator= (multirotor0 &&) = delete;\n\n  /* Real-Time Model get method */\n  RT_MODEL_multirotor0_T * getRTM();\n\n  /* External inputs */\n  ExtU_multirotor0_T multirotor0_U;\n\n  /* External outputs */\n  ExtY_multirotor0_T multirotor0_Y;\n\n  /* model start function */\n  void start();\n\n  /* Initial conditions function */\n  void initialize();\n\n  /* model step function */\n  void step0();\n\n  /* model step function */\n  void step2();\n\n  /* model terminate function */\n  static void terminate();\n\n  /* Constructor */\n  multirotor0();\n\n  /* Destructor */\n  ~multirotor0();\n\n  /* private data and function members */\n private:\n  /* Block signals */\n  B_multirotor0_T multirotor0_B;\n\n  /* Block states */\n  DW_multirotor0_T multirotor0_DW;\n\n  /* Block continuous states */\n  X_multirotor0_T multirotor0_X;\n\n  /* Continuous states update member function*/\n  void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si );\n\n  /* Derivatives member function */\n  void multirotor0_derivatives();\n\n  /* Real-Time Model */\n  RT_MODEL_multirotor0_T multirotor0_M;\n};\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<S67>/Data Type Duplicate' : Unused code path elimination\n * Block '<S67>/Data Type Propagation' : Unused code path elimination\n * Block '<S70>/Data Type Duplicate' : Unused code path elimination\n * Block '<S70>/Data Type Propagation' : Unused code path elimination\n * Block '<S70>/LowerRelop1' : Unused code path elimination\n * Block '<S70>/Switch' : Unused code path elimination\n * Block '<S70>/Switch2' : Unused code path elimination\n * Block '<S70>/UpperRelop' : Unused code path elimination\n * Block '<S39>/To Workspace' : Unused code path elimination\n * Block '<S1>/To Workspace' : Unused code path elimination\n * Block '<S5>/Reshape' : Reshape block reduction\n * Block '<S5>/Reshape1' : Reshape block reduction\n * Block '<S6>/Reshape' : Reshape block reduction\n * Block '<S6>/Reshape1' : Reshape block reduction\n * Block '<S7>/Reshape' : Reshape block reduction\n * Block '<S7>/Reshape ' : Reshape block reduction\n * Block '<S13>/Reshape' : Reshape block reduction\n * Block '<S13>/Reshape1' : Reshape block reduction\n * Block '<S17>/Reshape' : Reshape block reduction\n * Block '<S17>/Reshape1' : Reshape block reduction\n * Block '<S23>/Reshape' : Reshape block reduction\n * Block '<S23>/Reshape1' : Reshape block reduction\n * Block '<S9>/Reshape' : Reshape block reduction\n * Block '<S33>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S49>/Reshape' : Reshape block reduction\n * Block '<S49>/Reshape1' : Reshape block reduction\n * Block '<S53>/Reshape' : Reshape block reduction\n * Block '<S53>/Reshape1' : Reshape block reduction\n * Block '<S54>/Reshape' : Reshape block reduction\n * Block '<S54>/Reshape1' : Reshape block reduction\n * Block '<S55>/Reshape' : Reshape block reduction\n * Block '<S55>/Reshape1' : Reshape block reduction\n * Block '<S56>/Reshape' : Reshape block reduction\n * Block '<S56>/Reshape1' : Reshape block reduction\n * Block '<S41>/Reshape' : Reshape block reduction\n * Block '<S38>/Reshape' : Reshape block reduction\n * Block '<S60>/Reshape' : Reshape block reduction\n * Block '<S61>/Reshape1' : Reshape block reduction\n * Block '<S57>/Rate Transition' : Eliminated since input and output rates are identical\n * Block '<S82>/Reshape3' : Reshape block reduction\n * Block '<S86>/Reshape' : Reshape block reduction\n * Block '<S86>/Reshape1' : Reshape block reduction\n * Block '<S87>/Reshape' : Reshape block reduction\n * Block '<S87>/Reshape1' : Reshape block reduction\n * Block '<S95>/Reshape' : Reshape block reduction\n * Block '<S95>/Reshape1' : Reshape block reduction\n * Block '<S96>/Reshape' : Reshape block reduction\n * Block '<S96>/Reshape1' : Reshape block reduction\n * Block '<S78>/Reshape1' : Reshape block reduction\n * Block '<S78>/Reshape2' : Reshape block reduction\n * Block '<S81>/Reshape5' : Reshape block reduction\n * Block '<S114>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S62>/Reshape' : Reshape block reduction\n * Block '<S39>/Reshape' : Reshape block reduction\n * Block '<S117>/Reshape' : Reshape block reduction\n * Block '<S117>/Reshape1' : Reshape block reduction\n * Block '<S58>/Reshape' : Reshape block reduction\n * Block '<S77>/Constant' : Unused code path elimination\n * Block '<S77>/Constant1' : Unused code path elimination\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Note that this particular code originates from a subsystem build,\n * and has its own system numbers different from the parent model.\n * Refer to the system hierarchy for this subsystem below, and use the\n * MATLAB hilite_system command to trace the generated code back\n * to the parent model.  For example,\n *\n * hilite_system('Sim_Multi/multirotor')    - opens subsystem Sim_Multi/multirotor\n * hilite_system('Sim_Multi/multirotor/Kp') - opens and selects block Kp\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'Sim_Multi'\n * '<S1>'   : 'Sim_Multi/multirotor'\n * '<S2>'   : 'Sim_Multi/multirotor/6DOF model'\n * '<S3>'   : 'Sim_Multi/multirotor/Disturbances & Dynamic Events'\n * '<S4>'   : 'Sim_Multi/multirotor/Force//Moment computation'\n * '<S5>'   : 'Sim_Multi/multirotor/6DOF model/Body to Inertial'\n * '<S6>'   : 'Sim_Multi/multirotor/6DOF model/Body to Inertial1'\n * '<S7>'   : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot'\n * '<S8>'   : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq.'\n * '<S9>'   : 'Sim_Multi/multirotor/6DOF model/Quat to Euler'\n * '<S10>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix'\n * '<S11>'  : 'Sim_Multi/multirotor/6DOF model/omega x V_b'\n * '<S12>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Cross Product omega x (J * omega)'\n * '<S13>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Subsystem'\n * '<S14>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Cross Product omega x (J * omega)/Subsystem'\n * '<S15>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Cross Product omega x (J * omega)/Subsystem1'\n * '<S16>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Cross Product'\n * '<S17>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Dot product'\n * '<S18>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./MATLAB Function'\n * '<S19>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Normalize'\n * '<S20>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Cross Product/Subsystem'\n * '<S21>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Cross Product/Subsystem1'\n * '<S22>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Normalize/norm'\n * '<S23>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Normalize/norm/dot_product'\n * '<S24>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem'\n * '<S25>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem1'\n * '<S26>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem2'\n * '<S27>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem3'\n * '<S28>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem4'\n * '<S29>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem5'\n * '<S30>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem6'\n * '<S31>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem7'\n * '<S32>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem8'\n * '<S33>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem9'\n * '<S34>'  : 'Sim_Multi/multirotor/6DOF model/omega x V_b/Subsystem'\n * '<S35>'  : 'Sim_Multi/multirotor/6DOF model/omega x V_b/Subsystem1'\n * '<S36>'  : 'Sim_Multi/multirotor/Disturbances & Dynamic Events/MATLAB Function'\n * '<S37>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes'\n * '<S38>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute force of gravity in Body axes'\n * '<S39>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers'\n * '<S40>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force'\n * '<S41>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Total airspeed (Body axes)'\n * '<S42>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed'\n * '<S43>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Zero airspeed'\n * '<S44>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/norm'\n * '<S45>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Normalize'\n * '<S46>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation'\n * '<S47>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/u^2'\n * '<S48>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Normalize/norm'\n * '<S49>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Normalize/norm/dot_product'\n * '<S50>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Scaling factor computation'\n * '<S51>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Surface area computation'\n * '<S52>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Surface area computation/norm'\n * '<S53>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Surface area computation/norm/dot_product'\n * '<S54>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/u^2/dot_product'\n * '<S55>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/norm/dot_product'\n * '<S56>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Total airspeed (Body axes)/Inertial to Body'\n * '<S57>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem'\n * '<S58>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/Total airspeed (Body axes)'\n * '<S59>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics'\n * '<S60>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Cross Product'\n * '<S61>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Leverarm vector from real CoG to each propeller (Body axes)'\n * '<S62>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)'\n * '<S63>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits'\n * '<S64>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1'\n * '<S65>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits/Compare To Zero'\n * '<S66>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits/Compare To Zero1'\n * '<S67>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits/Saturation Dynamic'\n * '<S68>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1/Compare To Zero'\n * '<S69>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1/Compare To Zero1'\n * '<S70>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1/Saturation Dynamic'\n * '<S71>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Cross Product/Subsystem'\n * '<S72>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Cross Product/Subsystem1'\n * '<S73>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments'\n * '<S74>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes'\n * '<S75>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Cross Product'\n * '<S76>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations'\n * '<S77>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio'\n * '<S78>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque'\n * '<S79>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Hover moment magnitude'\n * '<S80>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Hover thrust magnitude'\n * '<S81>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Thrust direction in Body axes (without blade flapping)'\n * '<S82>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Nonzero airspeed in rotor plane'\n * '<S83>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Zero airspeed in rotor plane'\n * '<S84>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/norm'\n * '<S85>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Nonzero airspeed in rotor plane/norm'\n * '<S86>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Nonzero airspeed in rotor plane/norm/dot_product'\n * '<S87>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/norm/dot_product'\n * '<S88>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude'\n * '<S89>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Compute the climb speed'\n * '<S90>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller'\n * '<S91>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Nonzero airspeed'\n * '<S92>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Zero airspeed'\n * '<S93>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/norm2'\n * '<S94>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Nonzero airspeed/norm1'\n * '<S95>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Nonzero airspeed/norm1/dot_product'\n * '<S96>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/norm2/dot_product'\n * '<S97>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller/Normal working state vc//vh >= 0'\n * '<S98>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller/Vortex ring state -2 <= vc//vh < 0 '\n * '<S99>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller/Windmill braking state vc//vh < -2'\n * '<S100>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Cross Product'\n * '<S101>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Propeller moment of inertia'\n * '<S102>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Cross Product/Subsystem'\n * '<S103>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Cross Product/Subsystem1'\n * '<S104>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor'\n * '<S105>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem'\n * '<S106>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem1'\n * '<S107>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem2'\n * '<S108>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem3'\n * '<S109>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem4'\n * '<S110>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem5'\n * '<S111>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem6'\n * '<S112>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem7'\n * '<S113>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem8'\n * '<S114>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem9'\n * '<S115>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Cross Product/Subsystem'\n * '<S116>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Cross Product/Subsystem1'\n * '<S117>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/Total airspeed (Body axes)/Inertial to Body'\n */\n#endif                                 /* RTW_HEADER_multirotor0_h_ */\n"},{"name":"multirotor0_private.h","type":"header","group":"model","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * multirotor0_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_multirotor0_private_h_\n#define RTW_HEADER_multirotor0_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"multirotor0_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmSetFirstInitCond\n#define rtmSetFirstInitCond(rtm, val)  ((rtm)->Timing.firstInitCondFlag = (val))\n#endif\n\n#ifndef rtmIsFirstInitCond\n#define rtmIsFirstInitCond(rtm)        ((rtm)->Timing.firstInitCondFlag)\n#endif\n\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\nextern void rt_mldivide_U1d3x3_U2d_JBYZyA3A(const real_T u0[9], const real_T u1\n  [3], real_T y[3]);\n\n/* private model entry point functions */\nextern void multirotor0_derivatives();\n\n#endif                                 /* RTW_HEADER_multirotor0_private_h_ */\n"},{"name":"multirotor0_types.h","type":"header","group":"model","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * multirotor0_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_multirotor0_types_h_\n#define RTW_HEADER_multirotor0_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_multirotor0_T RT_MODEL_multirotor0_T;\n\n#endif                                 /* RTW_HEADER_multirotor0_types_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long int long_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint32_T chunks[2];\n} int64m_T;\n\ntypedef struct {\n  int64m_T re;\n  int64m_T im;\n} cint64m_T;\n\ntypedef struct {\n  uint32_T chunks[2];\n} uint64m_T;\n\ntypedef struct {\n  uint64m_T re;\n  uint64m_T im;\n} cuint64m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} int96m_T;\n\ntypedef struct {\n  int96m_T re;\n  int96m_T im;\n} cint96m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} uint96m_T;\n\ntypedef struct {\n  uint96m_T re;\n  uint96m_T im;\n} cuint96m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} int160m_T;\n\ntypedef struct {\n  int160m_T re;\n  int160m_T im;\n} cint160m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} uint160m_T;\n\ntypedef struct {\n  uint160m_T re;\n  uint160m_T im;\n} cuint160m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} int224m_T;\n\ntypedef struct {\n  int224m_T re;\n  int224m_T im;\n} cint224m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} uint224m_T;\n\ntypedef struct {\n  uint224m_T re;\n  uint224m_T im;\n} cuint224m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint32_T chunks[9];\n} int288m_T;\n\ntypedef struct {\n  int288m_T re;\n  int288m_T im;\n} cint288m_T;\n\ntypedef struct {\n  uint32_T chunks[9];\n} uint288m_T;\n\ntypedef struct {\n  uint288m_T re;\n  uint288m_T im;\n} cuint288m_T;\n\ntypedef struct {\n  uint32_T chunks[10];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint32_T chunks[10];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint32_T chunks[11];\n} int352m_T;\n\ntypedef struct {\n  int352m_T re;\n  int352m_T im;\n} cint352m_T;\n\ntypedef struct {\n  uint32_T chunks[11];\n} uint352m_T;\n\ntypedef struct {\n  uint352m_T re;\n  uint352m_T im;\n} cuint352m_T;\n\ntypedef struct {\n  uint32_T chunks[12];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint32_T chunks[12];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint32_T chunks[13];\n} int416m_T;\n\ntypedef struct {\n  int416m_T re;\n  int416m_T im;\n} cint416m_T;\n\ntypedef struct {\n  uint32_T chunks[13];\n} uint416m_T;\n\ntypedef struct {\n  uint416m_T re;\n  uint416m_T im;\n} cuint416m_T;\n\ntypedef struct {\n  uint32_T chunks[14];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint32_T chunks[14];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint32_T chunks[15];\n} int480m_T;\n\ntypedef struct {\n  int480m_T re;\n  int480m_T im;\n} cint480m_T;\n\ntypedef struct {\n  uint32_T chunks[15];\n} uint480m_T;\n\ntypedef struct {\n  uint480m_T re;\n  uint480m_T im;\n} cuint480m_T;\n\ntypedef struct {\n  uint32_T chunks[16];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint32_T chunks[16];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint32_T chunks[17];\n} int544m_T;\n\ntypedef struct {\n  int544m_T re;\n  int544m_T im;\n} cint544m_T;\n\ntypedef struct {\n  uint32_T chunks[17];\n} uint544m_T;\n\ntypedef struct {\n  uint544m_T re;\n  uint544m_T im;\n} cuint544m_T;\n\ntypedef struct {\n  uint32_T chunks[18];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint32_T chunks[18];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint32_T chunks[19];\n} int608m_T;\n\ntypedef struct {\n  int608m_T re;\n  int608m_T im;\n} cint608m_T;\n\ntypedef struct {\n  uint32_T chunks[19];\n} uint608m_T;\n\ntypedef struct {\n  uint608m_T re;\n  uint608m_T im;\n} cuint608m_T;\n\ntypedef struct {\n  uint32_T chunks[20];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint32_T chunks[20];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint32_T chunks[21];\n} int672m_T;\n\ntypedef struct {\n  int672m_T re;\n  int672m_T im;\n} cint672m_T;\n\ntypedef struct {\n  uint32_T chunks[21];\n} uint672m_T;\n\ntypedef struct {\n  uint672m_T re;\n  uint672m_T im;\n} cuint672m_T;\n\ntypedef struct {\n  uint32_T chunks[22];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint32_T chunks[22];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint32_T chunks[23];\n} int736m_T;\n\ntypedef struct {\n  int736m_T re;\n  int736m_T im;\n} cint736m_T;\n\ntypedef struct {\n  uint32_T chunks[23];\n} uint736m_T;\n\ntypedef struct {\n  uint736m_T re;\n  uint736m_T im;\n} cuint736m_T;\n\ntypedef struct {\n  uint32_T chunks[24];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint32_T chunks[24];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint32_T chunks[25];\n} int800m_T;\n\ntypedef struct {\n  int800m_T re;\n  int800m_T im;\n} cint800m_T;\n\ntypedef struct {\n  uint32_T chunks[25];\n} uint800m_T;\n\ntypedef struct {\n  uint800m_T re;\n  uint800m_T im;\n} cuint800m_T;\n\ntypedef struct {\n  uint32_T chunks[26];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint32_T chunks[26];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint32_T chunks[27];\n} int864m_T;\n\ntypedef struct {\n  int864m_T re;\n  int864m_T im;\n} cint864m_T;\n\ntypedef struct {\n  uint32_T chunks[27];\n} uint864m_T;\n\ntypedef struct {\n  uint864m_T re;\n  uint864m_T im;\n} cuint864m_T;\n\ntypedef struct {\n  uint32_T chunks[28];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint32_T chunks[28];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint32_T chunks[29];\n} int928m_T;\n\ntypedef struct {\n  int928m_T re;\n  int928m_T im;\n} cint928m_T;\n\ntypedef struct {\n  uint32_T chunks[29];\n} uint928m_T;\n\ntypedef struct {\n  uint928m_T re;\n  uint928m_T im;\n} cuint928m_T;\n\ntypedef struct {\n  uint32_T chunks[30];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint32_T chunks[30];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint32_T chunks[31];\n} int992m_T;\n\ntypedef struct {\n  int992m_T re;\n  int992m_T im;\n} cint992m_T;\n\ntypedef struct {\n  uint32_T chunks[31];\n} uint992m_T;\n\ntypedef struct {\n  uint992m_T re;\n  uint992m_T im;\n} cuint992m_T;\n\ntypedef struct {\n  uint32_T chunks[32];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint32_T chunks[32];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint32_T chunks[33];\n} int1056m_T;\n\ntypedef struct {\n  int1056m_T re;\n  int1056m_T im;\n} cint1056m_T;\n\ntypedef struct {\n  uint32_T chunks[33];\n} uint1056m_T;\n\ntypedef struct {\n  uint1056m_T re;\n  uint1056m_T im;\n} cuint1056m_T;\n\ntypedef struct {\n  uint32_T chunks[34];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint32_T chunks[34];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint32_T chunks[35];\n} int1120m_T;\n\ntypedef struct {\n  int1120m_T re;\n  int1120m_T im;\n} cint1120m_T;\n\ntypedef struct {\n  uint32_T chunks[35];\n} uint1120m_T;\n\ntypedef struct {\n  uint1120m_T re;\n  uint1120m_T im;\n} cuint1120m_T;\n\ntypedef struct {\n  uint32_T chunks[36];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint32_T chunks[36];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint32_T chunks[37];\n} int1184m_T;\n\ntypedef struct {\n  int1184m_T re;\n  int1184m_T im;\n} cint1184m_T;\n\ntypedef struct {\n  uint32_T chunks[37];\n} uint1184m_T;\n\ntypedef struct {\n  uint1184m_T re;\n  uint1184m_T im;\n} cuint1184m_T;\n\ntypedef struct {\n  uint32_T chunks[38];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint32_T chunks[38];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint32_T chunks[39];\n} int1248m_T;\n\ntypedef struct {\n  int1248m_T re;\n  int1248m_T im;\n} cint1248m_T;\n\ntypedef struct {\n  uint32_T chunks[39];\n} uint1248m_T;\n\ntypedef struct {\n  uint1248m_T re;\n  uint1248m_T im;\n} cuint1248m_T;\n\ntypedef struct {\n  uint32_T chunks[40];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint32_T chunks[40];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint32_T chunks[41];\n} int1312m_T;\n\ntypedef struct {\n  int1312m_T re;\n  int1312m_T im;\n} cint1312m_T;\n\ntypedef struct {\n  uint32_T chunks[41];\n} uint1312m_T;\n\ntypedef struct {\n  uint1312m_T re;\n  uint1312m_T im;\n} cuint1312m_T;\n\ntypedef struct {\n  uint32_T chunks[42];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint32_T chunks[42];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint32_T chunks[43];\n} int1376m_T;\n\ntypedef struct {\n  int1376m_T re;\n  int1376m_T im;\n} cint1376m_T;\n\ntypedef struct {\n  uint32_T chunks[43];\n} uint1376m_T;\n\ntypedef struct {\n  uint1376m_T re;\n  uint1376m_T im;\n} cuint1376m_T;\n\ntypedef struct {\n  uint32_T chunks[44];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint32_T chunks[44];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint32_T chunks[45];\n} int1440m_T;\n\ntypedef struct {\n  int1440m_T re;\n  int1440m_T im;\n} cint1440m_T;\n\ntypedef struct {\n  uint32_T chunks[45];\n} uint1440m_T;\n\ntypedef struct {\n  uint1440m_T re;\n  uint1440m_T im;\n} cuint1440m_T;\n\ntypedef struct {\n  uint32_T chunks[46];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint32_T chunks[46];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint32_T chunks[47];\n} int1504m_T;\n\ntypedef struct {\n  int1504m_T re;\n  int1504m_T im;\n} cint1504m_T;\n\ntypedef struct {\n  uint32_T chunks[47];\n} uint1504m_T;\n\ntypedef struct {\n  uint1504m_T re;\n  uint1504m_T im;\n} cuint1504m_T;\n\ntypedef struct {\n  uint32_T chunks[48];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint32_T chunks[48];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint32_T chunks[49];\n} int1568m_T;\n\ntypedef struct {\n  int1568m_T re;\n  int1568m_T im;\n} cint1568m_T;\n\ntypedef struct {\n  uint32_T chunks[49];\n} uint1568m_T;\n\ntypedef struct {\n  uint1568m_T re;\n  uint1568m_T im;\n} cuint1568m_T;\n\ntypedef struct {\n  uint32_T chunks[50];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint32_T chunks[50];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint32_T chunks[51];\n} int1632m_T;\n\ntypedef struct {\n  int1632m_T re;\n  int1632m_T im;\n} cint1632m_T;\n\ntypedef struct {\n  uint32_T chunks[51];\n} uint1632m_T;\n\ntypedef struct {\n  uint1632m_T re;\n  uint1632m_T im;\n} cuint1632m_T;\n\ntypedef struct {\n  uint32_T chunks[52];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint32_T chunks[52];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint32_T chunks[53];\n} int1696m_T;\n\ntypedef struct {\n  int1696m_T re;\n  int1696m_T im;\n} cint1696m_T;\n\ntypedef struct {\n  uint32_T chunks[53];\n} uint1696m_T;\n\ntypedef struct {\n  uint1696m_T re;\n  uint1696m_T im;\n} cuint1696m_T;\n\ntypedef struct {\n  uint32_T chunks[54];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint32_T chunks[54];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint32_T chunks[55];\n} int1760m_T;\n\ntypedef struct {\n  int1760m_T re;\n  int1760m_T im;\n} cint1760m_T;\n\ntypedef struct {\n  uint32_T chunks[55];\n} uint1760m_T;\n\ntypedef struct {\n  uint1760m_T re;\n  uint1760m_T im;\n} cuint1760m_T;\n\ntypedef struct {\n  uint32_T chunks[56];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint32_T chunks[56];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint32_T chunks[57];\n} int1824m_T;\n\ntypedef struct {\n  int1824m_T re;\n  int1824m_T im;\n} cint1824m_T;\n\ntypedef struct {\n  uint32_T chunks[57];\n} uint1824m_T;\n\ntypedef struct {\n  uint1824m_T re;\n  uint1824m_T im;\n} cuint1824m_T;\n\ntypedef struct {\n  uint32_T chunks[58];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint32_T chunks[58];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint32_T chunks[59];\n} int1888m_T;\n\ntypedef struct {\n  int1888m_T re;\n  int1888m_T im;\n} cint1888m_T;\n\ntypedef struct {\n  uint32_T chunks[59];\n} uint1888m_T;\n\ntypedef struct {\n  uint1888m_T re;\n  uint1888m_T im;\n} cuint1888m_T;\n\ntypedef struct {\n  uint32_T chunks[60];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint32_T chunks[60];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint32_T chunks[61];\n} int1952m_T;\n\ntypedef struct {\n  int1952m_T re;\n  int1952m_T im;\n} cint1952m_T;\n\ntypedef struct {\n  uint32_T chunks[61];\n} uint1952m_T;\n\ntypedef struct {\n  uint1952m_T re;\n  uint1952m_T im;\n} cuint1952m_T;\n\ntypedef struct {\n  uint32_T chunks[62];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint32_T chunks[62];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint32_T chunks[63];\n} int2016m_T;\n\ntypedef struct {\n  int2016m_T re;\n  int2016m_T im;\n} cint2016m_T;\n\ntypedef struct {\n  uint32_T chunks[63];\n} uint2016m_T;\n\ntypedef struct {\n  uint2016m_T re;\n  uint2016m_T im;\n} cuint2016m_T;\n\ntypedef struct {\n  uint32_T chunks[64];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint32_T chunks[64];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T inf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T minf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T nan{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF{ { 0.0F } };\n\n    uint16_T one{ 1U };\n\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder\n{\n      (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n    };\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_defines.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_defines_h_\n#define RTW_HEADER_rt_defines_h_\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result{ (boolean_T) 0 };\n\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.fltVal = value;\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                               0x7FF00000 &&\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                                (tmpVal.bitVal.words.wordL != 0) ));\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.fltVal = value;\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                               0x7FF00000 &&\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                                (tmpVal.bitVal.words.wordL != 0) ));\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.cpp","type":"source","group":"interface","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.cpp:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtmodel.h\"\n\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\nvoid multirotor0_step(multirotor0 & multirotor0_Obj, int_T tid)\n{\n  switch (tid) {\n   case 0 :\n    multirotor0_Obj.step0();\n    break;\n\n   case 2 :\n    multirotor0_Obj.step2();\n    break;\n\n   default :\n    /* do nothing */\n    break;\n  }\n}\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/divij/Documents/quadopter/MultirotorSim_Vervoorst/multirotor0_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"multirotor0\".\n *\n * Model version              : 14.51\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Aug 28 00:36:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"multirotor0.h\"\n#define MODEL_CLASSNAME                multirotor0\n#define MODEL_STEPNAME                 multirotor0_step\n#define GRTINTERFACE                   0\n\n/*\n * ROOT_IO_FORMAT: 0 (Individual arguments)\n * ROOT_IO_FORMAT: 1 (Structure reference)\n * ROOT_IO_FORMAT: 2 (Part of model data structure)\n */\n#define ROOT_IO_FORMAT                 2\n\n/* Model wrapper function */\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\nextern void multirotor0_step(multirotor0 & multirotor0_Obj, int_T tid);\n\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};