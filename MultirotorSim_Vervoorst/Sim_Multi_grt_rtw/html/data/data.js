var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"Sim_Multi","ref":false,"files":[{"name":"Sim_Multi.cpp","type":"source","group":"model","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Sim_Multi.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"Sim_Multi.h\"\n#include \"rtwtypes.h\"\n#include \"Sim_Multi_private.h\"\n#include <cmath>\n#include <cstring>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/*\n * This function updates continuous states using the ODE3 fixed-step\n * solver algorithm\n */\nvoid Sim_Multi::rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  /* Solver Matrices */\n  static const real_T rt_ODE3_A[3]{\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3]{\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t { rtsiGetT(si) };\n\n  time_T tnew { rtsiGetSolverStopTime(si) };\n\n  time_T h { rtsiGetStepSize(si) };\n\n  real_T *x { rtsiGetContStates(si) };\n\n  ODE3_IntgData *id { static_cast<ODE3_IntgData *>(rtsiGetSolverData(si)) };\n\n  real_T *y { id->y };\n\n  real_T *f0 { id->f[0] };\n\n  real_T *f1 { id->f[1] };\n\n  real_T *f2 { id->f[2] };\n\n  real_T hB[3];\n  int_T i;\n  int_T nXc { 29 };\n\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  /* Save the state values at time t in y, we'll use x as ynew. */\n  (void) std::memcpy(y, x,\n                     static_cast<uint_T>(nXc)*sizeof(real_T));\n\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n  /* f0 = f(t,y) */\n  rtsiSetdX(si, f0);\n  Sim_Multi_derivatives();\n\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  this->step0();\n  Sim_Multi_derivatives();\n\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  this->step0();\n  Sim_Multi_derivatives();\n\n  /* tnew = t + hA(3);\n     ynew = y + f*hB(:,3); */\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\nreal_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u)\n{\n  uint32_T hi;\n  uint32_T lo;\n\n  /* Uniform random number generator (random number between 0 and 1)\n\n     #define IA      16807                      magic multiplier = 7^5\n     #define IM      2147483647                 modulus = 2^31-1\n     #define IQ      127773                     IM div IA\n     #define IR      2836                       IM modulo IA\n     #define S       4.656612875245797e-10      reciprocal of 2^31-1\n     test = IA * (seed % IQ) - IR * (seed/IQ)\n     seed = test < 0 ? (test + IM) : test\n     return (seed*S)\n   */\n  lo = *u % 127773U * 16807U;\n  hi = *u / 127773U * 2836U;\n  if (lo < hi) {\n    *u = 2147483647U - (hi - lo);\n  } else {\n    *u = lo - hi;\n  }\n\n  return static_cast<real_T>(*u) * 4.6566128752457969E-10;\n}\n\nvoid rt_mldivide_U1d3x3_U2d_JBYZyA3A(const real_T u0[9], const real_T u1[3],\n  real_T y[3])\n{\n  real_T A[9];\n  real_T a21;\n  real_T maxval;\n  int32_T r1;\n  int32_T r2;\n  int32_T r3;\n  std::memcpy(&A[0], &u0[0], 9U * sizeof(real_T));\n  r1 = 0;\n  r2 = 1;\n  r3 = 2;\n  maxval = std::abs(u0[0]);\n  a21 = std::abs(u0[1]);\n  if (a21 > maxval) {\n    maxval = a21;\n    r1 = 1;\n    r2 = 0;\n  }\n\n  if (std::abs(u0[2]) > maxval) {\n    r1 = 2;\n    r2 = 1;\n    r3 = 0;\n  }\n\n  A[r2] = u0[r2] / u0[r1];\n  A[r3] /= A[r1];\n  A[r2 + 3] -= A[r1 + 3] * A[r2];\n  A[r3 + 3] -= A[r1 + 3] * A[r3];\n  A[r2 + 6] -= A[r1 + 6] * A[r2];\n  A[r3 + 6] -= A[r1 + 6] * A[r3];\n  if (std::abs(A[r3 + 3]) > std::abs(A[r2 + 3])) {\n    int32_T rtemp;\n    rtemp = r2 + 1;\n    r2 = r3;\n    r3 = rtemp - 1;\n  }\n\n  A[r3 + 3] /= A[r2 + 3];\n  A[r3 + 6] -= A[r3 + 3] * A[r2 + 6];\n  y[1] = u1[r2] - u1[r1] * A[r2];\n  y[2] = (u1[r3] - u1[r1] * A[r3]) - A[r3 + 3] * y[1];\n  y[2] /= A[r3 + 6];\n  y[0] = u1[r1] - A[r1 + 6] * y[2];\n  y[1] -= A[r2 + 6] * y[2];\n  y[1] /= A[r2 + 3];\n  y[0] -= A[r1 + 3] * y[1];\n  y[0] /= A[r1];\n}\n\n/* Model step function for TID0 */\nvoid Sim_Multi::step0()                /* Sample time: [0.0s, 0.0s] */\n{\n  /* local scratch DWork variables */\n  int32_T ForEach_itr;\n  real_T rtb_ImpAsg_InsertedFor_Motor_fo[12];\n  real_T rtb_ImpAsg_InsertedFor_Motor_mo[12];\n  real_T rtb_VectorConcatenate_k[9];\n  real_T rtb_Sum_k1[3];\n  real_T rtb_TrueairspeedBodyaxes[3];\n  real_T rtb_TrueairspeedBodyaxes_b[3];\n  real_T rtb_TrueairspeedatpropMotoraxes[3];\n  real_T VectorConcatenate;\n  real_T VectorConcatenate_tmp;\n  real_T VectorConcatenate_tmp_0;\n  real_T cphi;\n  real_T cpsi;\n  real_T ctheta;\n  real_T phi;\n  real_T phi_tmp;\n  real_T rtb_Divide_idx_0;\n  real_T rtb_Divide_idx_1;\n  real_T rtb_Divide_idx_2;\n  real_T rtb_Divide_idx_3;\n  real_T rtb_Memory3_idx_0;\n  real_T rtb_Memory3_idx_1;\n  real_T rtb_Memory3_idx_2;\n  real_T rtb_Memory_idx_0;\n  real_T rtb_Memory_idx_1;\n  real_T rtb_Memory_idx_2;\n  real_T rtb_Memory_idx_3;\n  real_T rtb_VectorConcatenate_g_tmp;\n  real_T rtb_VectorConcatenate_g_tmp_0;\n  real_T rtb_VectorConcatenate_g_tmp_1;\n  real_T rtb_VectorConcatenate_g_tmp_2;\n  real_T rtb_VectorConcatenate_g_tmp_3;\n  real_T rtb_VectorConcatenate_g_tmp_4;\n  real_T theta;\n  int32_T i;\n  int8_T rtAction;\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    /* set solver stop time */\n    rtsiSetSolverStopTime(&(&Sim_Multi_M)->solverInfo,(((&Sim_Multi_M)\n      ->Timing.clockTick0+1)*(&Sim_Multi_M)->Timing.stepSize0));\n\n    /* Update the flag to indicate when data transfers from\n     *  Sample time: [0.001s, 0.0s] to Sample time: [0.002s, 0.0s]  */\n    ((&Sim_Multi_M)->Timing.RateInteraction.TID1_2)++;\n    if (((&Sim_Multi_M)->Timing.RateInteraction.TID1_2) > 1) {\n      (&Sim_Multi_M)->Timing.RateInteraction.TID1_2 = 0;\n    }\n  }                                    /* end MajorTimeStep */\n\n  /* Update absolute time of base rate at minor time step */\n  if (rtmIsMinorTimeStep((&Sim_Multi_M))) {\n    (&Sim_Multi_M)->Timing.t[0] = rtsiGetT(&(&Sim_Multi_M)->solverInfo);\n  }\n\n  /* TransferFcn: '<S31>/Transfer Fcn1' */\n  Sim_Multi_B.TransferFcn1 = 100.0 * Sim_Multi_X.TransferFcn1_CSTATE;\n\n  /* TransferFcn: '<S31>/Transfer Fcn6' */\n  Sim_Multi_B.TransferFcn6 = 100.0 * Sim_Multi_X.TransferFcn6_CSTATE;\n\n  /* TransferFcn: '<S31>/Transfer Fcn4' */\n  Sim_Multi_B.TransferFcn4 = 100.0 * Sim_Multi_X.TransferFcn4_CSTATE;\n\n  /* TransferFcn: '<S31>/Transfer Fcn5' */\n  Sim_Multi_B.TransferFcn5 = 100.0 * Sim_Multi_X.TransferFcn5_CSTATE;\n\n  /* TransferFcn: '<S31>/Transfer Fcn2' */\n  Sim_Multi_B.TransferFcn2 = 100.0 * Sim_Multi_X.TransferFcn2_CSTATE;\n\n  /* TransferFcn: '<S31>/Transfer Fcn3' */\n  Sim_Multi_B.TransferFcn3 = 100.0 * Sim_Multi_X.TransferFcn3_CSTATE;\n\n  /* Step: '<S32>/Step2' incorporates:\n   *  Step: '<S32>/Step1'\n   *  Step: '<S32>/Step6'\n   *  Step: '<S33>/Step'\n   *  Step: '<S33>/Step1'\n   *  Step: '<S33>/Step2'\n   */\n  phi_tmp = (&Sim_Multi_M)->Timing.t[0];\n  if (phi_tmp < 2.0) {\n    i = 0;\n  } else {\n    i = -2;\n  }\n\n  /* Gain: '<S32>/Gain2' incorporates:\n   *  Gain: '<S32>/Gain1'\n   *  Step: '<S32>/Step1'\n   *  Step: '<S32>/Step2'\n   *  Step: '<S32>/Step6'\n   *  Sum: '<S32>/Add2'\n   */\n  Sim_Multi_B.Gain2 = ((static_cast<real_T>(!(phi_tmp < 1.0)) +\n                        static_cast<real_T>(i)) + static_cast<real_T>(!(phi_tmp <\n    3.0))) * 0.1 * 500.0;\n\n  /* RateTransition: '<S30>/Rate Transition' */\n  if (rtmIsMajorTimeStep((&Sim_Multi_M)) && ((&Sim_Multi_M)\n       ->Timing.RateInteraction.TID1_2 == 1)) {\n    Sim_Multi_DW.RateTransition_Buffer[0] = Sim_Multi_B.TransferFcn1;\n    Sim_Multi_DW.RateTransition_Buffer[1] = Sim_Multi_B.TransferFcn5;\n    Sim_Multi_DW.RateTransition_Buffer[2] = Sim_Multi_B.TransferFcn3;\n  }\n\n  /* End of RateTransition: '<S30>/Rate Transition' */\n\n  /* Step: '<S33>/Step1' */\n  if (phi_tmp < 1.5) {\n    i = 0;\n  } else {\n    i = -2;\n  }\n\n  /* Gain: '<S33>/Gain2' incorporates:\n   *  Gain: '<S33>/Gain'\n   *  Step: '<S33>/Step'\n   *  Step: '<S33>/Step1'\n   *  Step: '<S33>/Step2'\n   *  Sum: '<S33>/Add'\n   */\n  Sim_Multi_B.Gain2_i = ((static_cast<real_T>(!(phi_tmp < 0.5)) +\n    static_cast<real_T>(i)) + static_cast<real_T>(!(phi_tmp < 2.5))) * 0.1 *\n    500.0;\n\n  /* Gain: '<S34>/Gain2' incorporates:\n   *  Constant: '<S34>/Constant'\n   */\n  Sim_Multi_B.Gain2_g = 0.0;\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    /* Memory: '<S36>/Memory' */\n    rtb_Memory_idx_0 = Sim_Multi_DW.Memory_PreviousInput[0];\n    rtb_Memory_idx_1 = Sim_Multi_DW.Memory_PreviousInput[1];\n    rtb_Memory_idx_2 = Sim_Multi_DW.Memory_PreviousInput[2];\n    rtb_Memory_idx_3 = Sim_Multi_DW.Memory_PreviousInput[3];\n\n    /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n    /* MATLAB Function: '<S64>/MATLAB Function' */\n    Sim_Multi_B.quat_output[0] = 1.0;\n    Sim_Multi_B.quat_output[1] = 0.0;\n    Sim_Multi_B.quat_output[2] = 0.0;\n    Sim_Multi_B.quat_output[3] = 0.0;\n\n    /* End of Outputs for SubSystem: '<Root>/multirotor' */\n  }\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  /* Integrator: '<S64>/Q-Integrator' */\n  if (Sim_Multi_DW.QIntegrator_IWORK != 0) {\n    Sim_Multi_X.QIntegrator_CSTATE[0] = Sim_Multi_B.quat_output[0];\n    Sim_Multi_X.QIntegrator_CSTATE[1] = Sim_Multi_B.quat_output[1];\n    Sim_Multi_X.QIntegrator_CSTATE[2] = Sim_Multi_B.quat_output[2];\n    Sim_Multi_X.QIntegrator_CSTATE[3] = Sim_Multi_B.quat_output[3];\n  }\n\n  /* Sqrt: '<S78>/Sqrt' incorporates:\n   *  Integrator: '<S64>/Q-Integrator'\n   *  Product: '<S79>/Product'\n   */\n  cphi = std::sqrt(((Sim_Multi_X.QIntegrator_CSTATE[0] *\n                     Sim_Multi_X.QIntegrator_CSTATE[0] +\n                     Sim_Multi_X.QIntegrator_CSTATE[1] *\n                     Sim_Multi_X.QIntegrator_CSTATE[1]) +\n                    Sim_Multi_X.QIntegrator_CSTATE[2] *\n                    Sim_Multi_X.QIntegrator_CSTATE[2]) +\n                   Sim_Multi_X.QIntegrator_CSTATE[3] *\n                   Sim_Multi_X.QIntegrator_CSTATE[3]);\n\n  /* Product: '<S75>/Divide' incorporates:\n   *  Integrator: '<S64>/Q-Integrator'\n   */\n  rtb_Divide_idx_0 = Sim_Multi_X.QIntegrator_CSTATE[0] / cphi;\n  rtb_Divide_idx_1 = Sim_Multi_X.QIntegrator_CSTATE[1] / cphi;\n  rtb_Divide_idx_2 = Sim_Multi_X.QIntegrator_CSTATE[2] / cphi;\n  rtb_Divide_idx_3 = Sim_Multi_X.QIntegrator_CSTATE[3] / cphi;\n\n  /* Product: '<S80>/Product' incorporates:\n   *  Product: '<S81>/Product'\n   */\n  cphi = rtb_Divide_idx_0 * rtb_Divide_idx_0;\n\n  /* Product: '<S80>/Product2' incorporates:\n   *  Product: '<S81>/Product2'\n   */\n  rtb_VectorConcatenate_g_tmp_1 = rtb_Divide_idx_1 * rtb_Divide_idx_1;\n\n  /* Product: '<S80>/Product3' incorporates:\n   *  Product: '<S81>/Product3'\n   *  Product: '<S82>/Product3'\n   */\n  rtb_VectorConcatenate_g_tmp_2 = rtb_Divide_idx_2 * rtb_Divide_idx_2;\n\n  /* Product: '<S80>/Product4' incorporates:\n   *  Product: '<S81>/Product4'\n   *  Product: '<S82>/Product4'\n   */\n  rtb_VectorConcatenate_g_tmp_3 = rtb_Divide_idx_3 * rtb_Divide_idx_3;\n\n  /* Sum: '<S80>/Add' incorporates:\n   *  Product: '<S80>/Product'\n   *  Product: '<S80>/Product2'\n   *  Product: '<S80>/Product3'\n   *  Product: '<S80>/Product4'\n   */\n  rtb_VectorConcatenate_k[0] = ((cphi + rtb_VectorConcatenate_g_tmp_1) -\n    rtb_VectorConcatenate_g_tmp_2) - rtb_VectorConcatenate_g_tmp_3;\n\n  /* Product: '<S85>/Product' incorporates:\n   *  Product: '<S83>/Product'\n   */\n  rtb_VectorConcatenate_g_tmp = rtb_Divide_idx_1 * rtb_Divide_idx_2;\n\n  /* Product: '<S85>/Product2' incorporates:\n   *  Product: '<S83>/Product2'\n   */\n  rtb_VectorConcatenate_g_tmp_0 = rtb_Divide_idx_0 * rtb_Divide_idx_3;\n\n  /* Gain: '<S85>/Gain' incorporates:\n   *  Product: '<S85>/Product'\n   *  Product: '<S85>/Product2'\n   *  Sum: '<S85>/Add'\n   */\n  rtb_VectorConcatenate_k[1] = (rtb_VectorConcatenate_g_tmp -\n    rtb_VectorConcatenate_g_tmp_0) * 2.0;\n\n  /* Product: '<S87>/Product' incorporates:\n   *  Product: '<S84>/Product'\n   */\n  rtb_VectorConcatenate_g_tmp_4 = rtb_Divide_idx_1 * rtb_Divide_idx_3;\n\n  /* Product: '<S87>/Product2' incorporates:\n   *  Product: '<S84>/Product2'\n   */\n  phi = rtb_Divide_idx_0 * rtb_Divide_idx_2;\n\n  /* Gain: '<S87>/Gain' incorporates:\n   *  Product: '<S87>/Product'\n   *  Product: '<S87>/Product2'\n   *  Sum: '<S87>/Add'\n   */\n  rtb_VectorConcatenate_k[2] = (rtb_VectorConcatenate_g_tmp_4 + phi) * 2.0;\n\n  /* Gain: '<S83>/Gain' incorporates:\n   *  Sum: '<S83>/Add'\n   */\n  rtb_VectorConcatenate_k[3] = (rtb_VectorConcatenate_g_tmp +\n    rtb_VectorConcatenate_g_tmp_0) * 2.0;\n\n  /* Sum: '<S81>/Add' incorporates:\n   *  Sum: '<S82>/Add'\n   */\n  cphi -= rtb_VectorConcatenate_g_tmp_1;\n  rtb_VectorConcatenate_k[4] = (cphi + rtb_VectorConcatenate_g_tmp_2) -\n    rtb_VectorConcatenate_g_tmp_3;\n\n  /* Product: '<S88>/Product' incorporates:\n   *  Product: '<S86>/Product'\n   */\n  rtb_VectorConcatenate_g_tmp_1 = rtb_Divide_idx_2 * rtb_Divide_idx_3;\n\n  /* Product: '<S88>/Product2' incorporates:\n   *  Product: '<S86>/Product2'\n   */\n  rtb_VectorConcatenate_g_tmp = rtb_Divide_idx_0 * rtb_Divide_idx_1;\n\n  /* Gain: '<S88>/Gain' incorporates:\n   *  Product: '<S88>/Product'\n   *  Product: '<S88>/Product2'\n   *  Sum: '<S88>/Add'\n   */\n  rtb_VectorConcatenate_k[5] = (rtb_VectorConcatenate_g_tmp_1 -\n    rtb_VectorConcatenate_g_tmp) * 2.0;\n\n  /* Gain: '<S84>/Gain' incorporates:\n   *  Sum: '<S84>/Add'\n   */\n  rtb_VectorConcatenate_k[6] = (rtb_VectorConcatenate_g_tmp_4 - phi) * 2.0;\n\n  /* Gain: '<S86>/Gain' incorporates:\n   *  Sum: '<S86>/Add'\n   */\n  rtb_VectorConcatenate_k[7] = (rtb_VectorConcatenate_g_tmp_1 +\n    rtb_VectorConcatenate_g_tmp) * 2.0;\n\n  /* Sum: '<S82>/Add' */\n  rtb_VectorConcatenate_k[8] = (cphi - rtb_VectorConcatenate_g_tmp_2) +\n    rtb_VectorConcatenate_g_tmp_3;\n\n  /* Integrator: '<S58>/omega' incorporates:\n   *  Constant: '<S59>/Constant3'\n   *  Product: '<S69>/Product'\n   */\n  cphi = Sim_Multi_X.omega_CSTATE[1];\n  rtb_VectorConcatenate_g_tmp_1 = Sim_Multi_X.omega_CSTATE[0];\n  rtb_VectorConcatenate_g_tmp_2 = Sim_Multi_X.omega_CSTATE[2];\n\n  /* Integrator: '<S58>/V_b' incorporates:\n   *  Math: '<S61>/Math Function2'\n   */\n  rtb_VectorConcatenate_g_tmp_3 = Sim_Multi_X.V_b_CSTATE[1];\n  rtb_VectorConcatenate_g_tmp = Sim_Multi_X.V_b_CSTATE[0];\n  rtb_VectorConcatenate_g_tmp_0 = Sim_Multi_X.V_b_CSTATE[2];\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S69>/Product' incorporates:\n     *  Constant: '<S59>/Constant3'\n     *  Integrator: '<S58>/omega'\n     *  Sum: '<S72>/Sum'\n     */\n    rtb_Sum_k1[i] = (Sim_Multi_ConstP.pooled11[i + 3] * cphi +\n                     Sim_Multi_ConstP.pooled11[i] *\n                     rtb_VectorConcatenate_g_tmp_1) +\n      Sim_Multi_ConstP.pooled11[i + 6] * rtb_VectorConcatenate_g_tmp_2;\n\n    /* Product: '<S61>/Product' incorporates:\n     *  Concatenate: '<S89>/Vector Concatenate'\n     *  Integrator: '<S58>/V_b'\n     *  Math: '<S61>/Math Function2'\n     */\n    Sim_Multi_B.Product[i] = (rtb_VectorConcatenate_k[3 * i + 1] *\n      rtb_VectorConcatenate_g_tmp_3 + rtb_VectorConcatenate_k[3 * i] *\n      rtb_VectorConcatenate_g_tmp) + rtb_VectorConcatenate_k[3 * i + 2] *\n      rtb_VectorConcatenate_g_tmp_0;\n  }\n\n  /* Sum: '<S68>/Sum' incorporates:\n   *  Integrator: '<S58>/omega'\n   *  Product: '<S70>/Product'\n   *  Product: '<S70>/Product1'\n   *  Product: '<S70>/Product2'\n   *  Product: '<S71>/Product'\n   *  Product: '<S71>/Product1'\n   *  Product: '<S71>/Product2'\n   */\n  rtb_VectorConcatenate_g_tmp_1 = Sim_Multi_X.omega_CSTATE[1] * rtb_Sum_k1[2];\n  rtb_VectorConcatenate_g_tmp_2 = rtb_Sum_k1[0] * Sim_Multi_X.omega_CSTATE[2];\n  rtb_VectorConcatenate_g_tmp_3 = Sim_Multi_X.omega_CSTATE[0] * rtb_Sum_k1[1];\n  rtb_VectorConcatenate_g_tmp = rtb_Sum_k1[1] * Sim_Multi_X.omega_CSTATE[2];\n  rtb_VectorConcatenate_g_tmp_0 = Sim_Multi_X.omega_CSTATE[0] * rtb_Sum_k1[2];\n  rtb_VectorConcatenate_g_tmp_4 = rtb_Sum_k1[0] * Sim_Multi_X.omega_CSTATE[1];\n\n  /* RateTransition: '<S5>/Rate Transition1' */\n  if (rtmIsMajorTimeStep((&Sim_Multi_M)) && ((&Sim_Multi_M)\n       ->Timing.RateInteraction.TID1_2 == 1)) {\n    /* RateTransition: '<S5>/Rate Transition1' */\n    Sim_Multi_B.RateTransition1[0] = Sim_Multi_DW.RateTransition1_Buffer0[0];\n    Sim_Multi_B.RateTransition1[1] = Sim_Multi_DW.RateTransition1_Buffer0[1];\n    Sim_Multi_B.RateTransition1[2] = Sim_Multi_DW.RateTransition1_Buffer0[2];\n    Sim_Multi_B.RateTransition1[3] = Sim_Multi_DW.RateTransition1_Buffer0[3];\n  }\n\n  /* End of RateTransition: '<S5>/Rate Transition1' */\n  for (i = 0; i < 3; i++) {\n    /* Product: '<S172>/Product' incorporates:\n     *  Concatenate: '<S89>/Vector Concatenate'\n     *  Constant: '<S59>/Wind vector'\n     *  Product: '<S111>/Product'\n     */\n    cphi = (rtb_VectorConcatenate_k[i + 3] * 0.0 + rtb_VectorConcatenate_k[i] *\n            0.0) + rtb_VectorConcatenate_k[i + 6] * 0.0;\n    rtb_TrueairspeedBodyaxes_b[i] = cphi;\n\n    /* Sum: '<S113>/Sum1' incorporates:\n     *  Integrator: '<S58>/V_b'\n     */\n    rtb_TrueairspeedBodyaxes[i] = Sim_Multi_X.V_b_CSTATE[i] - cphi;\n  }\n\n  /* Outputs for Iterator SubSystem: '<S94>/For Each Subsystem' incorporates:\n   *  ForEach: '<S112>/For Each'\n   */\n  for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n    /* ForEachSliceSelector generated from: '<S112>/MotorMatrix_real' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  RelationalOperator: '<S118>/Relational Operator'\n     *  RelationalOperator: '<S122>/LowerRelop1'\n     */\n    phi_tmp = Sim_Multi_ConstP.pooled10[ForEach_itr + 44];\n\n    /* Switch: '<S122>/Switch2' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n     *  Integrator: '<S118>/Integrator'\n     *  RelationalOperator: '<S122>/LowerRelop1'\n     */\n    if (Sim_Multi_X.CoreSubsys_p[ForEach_itr].Integrator_CSTATE_e > phi_tmp) {\n      cphi = Sim_Multi_ConstP.pooled10[ForEach_itr + 44];\n    } else {\n      /* RelationalOperator: '<S122>/UpperRelop' incorporates:\n       *  Switch: '<S122>/Switch'\n       */\n      cphi = Sim_Multi_ConstP.pooled10[ForEach_itr + 40];\n\n      /* Switch: '<S122>/Switch' incorporates:\n       *  RelationalOperator: '<S122>/UpperRelop'\n       */\n      if (!(Sim_Multi_X.CoreSubsys_p[ForEach_itr].Integrator_CSTATE_e < cphi)) {\n        cphi = Sim_Multi_X.CoreSubsys_p[ForEach_itr].Integrator_CSTATE_e;\n      }\n    }\n\n    /* End of Switch: '<S122>/Switch2' */\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      /* Product: '<S114>/Product' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       *  ForEachSliceSelector generated from: '<S112>/RPM_commands'\n       *  RateTransition: '<S5>/Rate Transition1'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Product =\n        Sim_Multi_ConstP.pooled10[ForEach_itr + 16] *\n        Sim_Multi_B.RateTransition1[ForEach_itr];\n    }\n\n    /* Product: '<S114>/Divide' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n     *  Sum: '<S114>/Sum1'\n     */\n    phi = (Sim_Multi_B.CoreSubsys_p[ForEach_itr].Product - cphi) /\n      Sim_Multi_ConstP.pooled10[ForEach_itr + 20];\n\n    /* Switch: '<S118>/Switch' incorporates:\n     *  Constant: '<S120>/Constant'\n     *  Constant: '<S121>/Constant'\n     *  Constant: '<S59>/Constant'\n     *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n     *  Integrator: '<S118>/Integrator'\n     *  Logic: '<S118>/Logical Operator'\n     *  Logic: '<S118>/Logical Operator1'\n     *  Logic: '<S118>/Logical Operator2'\n     *  RelationalOperator: '<S118>/Relational Operator'\n     *  RelationalOperator: '<S118>/Relational Operator1'\n     *  RelationalOperator: '<S120>/Compare'\n     *  RelationalOperator: '<S121>/Compare'\n     */\n    if (((Sim_Multi_X.CoreSubsys_p[ForEach_itr].Integrator_CSTATE_e <= phi_tmp) ||\n         (phi < 0.0)) && ((phi > 0.0) || (Sim_Multi_X.CoreSubsys_p[ForEach_itr].\n          Integrator_CSTATE_e >= Sim_Multi_ConstP.pooled10[ForEach_itr + 40])))\n    {\n      /* Switch: '<S118>/Switch' */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Switch = phi;\n    } else {\n      /* Switch: '<S118>/Switch' incorporates:\n       *  Constant: '<S118>/Constant'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Switch = 0.0;\n    }\n\n    /* End of Switch: '<S118>/Switch' */\n\n    /* Switch: '<S119>/Switch' */\n    Sim_Multi_B.CoreSubsys_p[ForEach_itr].Switch_a = 0.0;\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      /* Gain: '<S116>/Conversion deg to rad' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       */\n      phi = 0.017453292519943295 * Sim_Multi_ConstP.pooled10[ForEach_itr];\n\n      /* Abs: '<S116>/Abs' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       */\n      ctheta = std::abs(Sim_Multi_ConstP.pooled10[ForEach_itr + 4]);\n\n      /* Sum: '<S116>/Subtract' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  Constant: '<S59>/Constant1'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       *  Product: '<S116>/Product4'\n       *  Reshape: '<S116>/Reshape'\n       *  Trigonometry: '<S116>/Trigonometric Function'\n       *  Trigonometry: '<S116>/Trigonometric Function1'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorfromrealCoGtopropellerBod[0] =\n        std::cos(phi) * ctheta;\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorfromrealCoGtopropellerBod[1] =\n        std::sin(phi) * ctheta;\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorfromrealCoGtopropellerBod[2] =\n        Sim_Multi_ConstP.pooled10[ForEach_itr + 8] - 0.001;\n    }\n\n    /* Product: '<S135>/Product5' incorporates:\n     *  Product: '<S134>/Product1'\n     */\n    phi_tmp = cphi * cphi;\n\n    /* Product: '<S128>/Product7' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n     *  Product: '<S135>/Product4'\n     *  Product: '<S135>/Product5'\n     *  Product: '<S135>/Product6'\n     *  Sum: '<S135>/Sum1'\n     */\n    phi = Sim_Multi_ConstP.pooled10[ForEach_itr + 24] * cphi +\n      Sim_Multi_ConstP.pooled10[ForEach_itr + 28] * phi_tmp;\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      /* Gain: '<S129>/Conversion deg to rad' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       *  Memory: '<S36>/Memory3'\n       */\n      rtb_Memory3_idx_0 = Sim_Multi_ConstP.pooled10[ForEach_itr + 48] *\n        0.017453292519943295;\n      rtb_Memory3_idx_1 = Sim_Multi_ConstP.pooled10[ForEach_itr + 52] *\n        0.017453292519943295;\n      rtb_Memory3_idx_2 = Sim_Multi_ConstP.pooled10[ForEach_itr + 56] *\n        0.017453292519943295;\n\n      /* Trigonometry: '<S160>/Trigonometric Function3' incorporates:\n       *  Trigonometry: '<S163>/Trigonometric Function3'\n       *  Trigonometry: '<S164>/Trigonometric Function'\n       *  Trigonometry: '<S166>/Trigonometric Function4'\n       *  Trigonometry: '<S167>/Trigonometric Function'\n       */\n      ctheta = std::cos(rtb_Memory3_idx_2);\n\n      /* Trigonometry: '<S160>/Trigonometric Function1' incorporates:\n       *  Trigonometry: '<S161>/Trigonometric Function1'\n       *  Trigonometry: '<S165>/Trigonometric Function1'\n       *  Trigonometry: '<S168>/Trigonometric Function1'\n       */\n      theta = std::cos(rtb_Memory3_idx_1);\n\n      /* Product: '<S160>/Product' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       *  Trigonometry: '<S160>/Trigonometric Function1'\n       *  Trigonometry: '<S160>/Trigonometric Function3'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[0] = theta *\n        ctheta;\n\n      /* Trigonometry: '<S163>/Trigonometric Function5' incorporates:\n       *  Trigonometry: '<S164>/Trigonometric Function5'\n       *  Trigonometry: '<S166>/Trigonometric Function12'\n       *  Trigonometry: '<S168>/Trigonometric Function3'\n       */\n      cpsi = std::cos(rtb_Memory3_idx_0);\n\n      /* Trigonometry: '<S163>/Trigonometric Function1' incorporates:\n       *  Trigonometry: '<S162>/Trigonometric Function1'\n       *  Trigonometry: '<S166>/Trigonometric Function2'\n       */\n      rtb_Memory3_idx_1 = std::sin(rtb_Memory3_idx_1);\n\n      /* Trigonometry: '<S163>/Trigonometric Function12' incorporates:\n       *  Trigonometry: '<S165>/Trigonometric Function3'\n       *  Trigonometry: '<S166>/Trigonometric Function5'\n       *  Trigonometry: '<S167>/Trigonometric Function5'\n       */\n      rtb_Memory3_idx_0 = std::sin(rtb_Memory3_idx_0);\n\n      /* Trigonometry: '<S163>/Trigonometric Function' incorporates:\n       *  Trigonometry: '<S161>/Trigonometric Function3'\n       *  Trigonometry: '<S164>/Trigonometric Function4'\n       *  Trigonometry: '<S166>/Trigonometric Function'\n       *  Trigonometry: '<S167>/Trigonometric Function3'\n       */\n      rtb_Memory3_idx_2 = std::sin(rtb_Memory3_idx_2);\n\n      /* Product: '<S163>/Product' incorporates:\n       *  Product: '<S164>/Product1'\n       *  Trigonometry: '<S163>/Trigonometric Function1'\n       *  Trigonometry: '<S163>/Trigonometric Function12'\n       */\n      VectorConcatenate_tmp = rtb_Memory3_idx_0 * rtb_Memory3_idx_1;\n\n      /* Sum: '<S163>/Sum' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       *  Product: '<S163>/Product'\n       *  Product: '<S163>/Product1'\n       *  Trigonometry: '<S163>/Trigonometric Function'\n       *  Trigonometry: '<S163>/Trigonometric Function5'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[1] =\n        VectorConcatenate_tmp * ctheta - cpsi * rtb_Memory3_idx_2;\n\n      /* Product: '<S166>/Product1' incorporates:\n       *  Product: '<S167>/Product'\n       */\n      VectorConcatenate_tmp_0 = cpsi * rtb_Memory3_idx_1;\n\n      /* Sum: '<S166>/Sum' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       *  Product: '<S166>/Product1'\n       *  Product: '<S166>/Product2'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[2] =\n        VectorConcatenate_tmp_0 * ctheta + rtb_Memory3_idx_0 * rtb_Memory3_idx_2;\n\n      /* Product: '<S161>/Product' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[3] = theta *\n        rtb_Memory3_idx_2;\n\n      /* Sum: '<S164>/Sum' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       *  Product: '<S164>/Product1'\n       *  Product: '<S164>/Product2'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[4] =\n        VectorConcatenate_tmp * rtb_Memory3_idx_2 + cpsi * ctheta;\n\n      /* Sum: '<S167>/Sum' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       *  Product: '<S167>/Product'\n       *  Product: '<S167>/Product1'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[5] =\n        VectorConcatenate_tmp_0 * rtb_Memory3_idx_2 - rtb_Memory3_idx_0 * ctheta;\n\n      /* Gain: '<S162>/Gain' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[6] =\n        -rtb_Memory3_idx_1;\n\n      /* Product: '<S165>/Product' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[7] =\n        rtb_Memory3_idx_0 * theta;\n\n      /* Product: '<S168>/Product' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[8] = cpsi * theta;\n    }\n\n    /* Sum: '<S112>/Sum1' incorporates:\n     *  Integrator: '<S58>/omega'\n     *  Product: '<S126>/Product'\n     *  Product: '<S126>/Product1'\n     *  Product: '<S126>/Product2'\n     *  Product: '<S127>/Product'\n     *  Product: '<S127>/Product1'\n     *  Product: '<S127>/Product2'\n     *  Sum: '<S113>/Sum1'\n     *  Sum: '<S115>/Sum'\n     */\n    rtb_Memory3_idx_1 = (Sim_Multi_X.omega_CSTATE[1] *\n                         Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                         VectorfromrealCoGtopropellerBod[2] -\n                         Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                         VectorfromrealCoGtopropellerBod[1] *\n                         Sim_Multi_X.omega_CSTATE[2]) +\n      rtb_TrueairspeedBodyaxes[0];\n    cpsi = (Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n            VectorfromrealCoGtopropellerBod[0] * Sim_Multi_X.omega_CSTATE[2] -\n            Sim_Multi_X.omega_CSTATE[0] * Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n            VectorfromrealCoGtopropellerBod[2]) + rtb_TrueairspeedBodyaxes[1];\n    theta = (Sim_Multi_X.omega_CSTATE[0] * Sim_Multi_B.CoreSubsys_p[ForEach_itr]\n             .VectorfromrealCoGtopropellerBod[1] -\n             Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n             VectorfromrealCoGtopropellerBod[0] * Sim_Multi_X.omega_CSTATE[1]) +\n      rtb_TrueairspeedBodyaxes[2];\n\n    /* Product: '<S129>/Product' */\n    for (i = 0; i < 3; i++) {\n      /* Product: '<S129>/Product' incorporates:\n       *  Concatenate: '<S169>/Vector Concatenate'\n       */\n      rtb_TrueairspeedatpropMotoraxes[i] = (Sim_Multi_B.CoreSubsys_p[ForEach_itr]\n        .VectorConcatenate[i + 3] * cpsi + Sim_Multi_B.CoreSubsys_p[ForEach_itr]\n        .VectorConcatenate[i] * rtb_Memory3_idx_1) +\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[i + 6] * theta;\n    }\n\n    /* End of Product: '<S129>/Product' */\n\n    /* If: '<S131>/If' incorporates:\n     *  Math: '<S142>/transpose'\n     *  Product: '<S142>/Product'\n     *  Sqrt: '<S139>/Sqrt'\n     */\n    if (rtsiIsModeUpdateTimeStep(&(&Sim_Multi_M)->solverInfo)) {\n      rtAction = static_cast<int8_T>(!(std::sqrt\n        (rtb_TrueairspeedatpropMotoraxes[0] * rtb_TrueairspeedatpropMotoraxes[0]\n         + rtb_TrueairspeedatpropMotoraxes[1] * rtb_TrueairspeedatpropMotoraxes\n         [1]) == 0.0));\n      Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem = rtAction;\n    } else {\n      rtAction = Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S131>/Zero airspeed in rotor plane' incorporates:\n       *  ActionPort: '<S138>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n        /* Merge: '<S131>/Merge' incorporates:\n         *  Constant: '<S138>/Constant'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[0]\n          = 0.0;\n\n        /* Merge: '<S131>/Merge1' incorporates:\n         *  Constant: '<S138>/Constant1'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[0]\n          = 0.0;\n\n        /* Merge: '<S131>/Merge' incorporates:\n         *  Constant: '<S138>/Constant'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[1]\n          = 0.0;\n\n        /* Merge: '<S131>/Merge1' incorporates:\n         *  Constant: '<S138>/Constant1'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[1]\n          = 0.0;\n\n        /* Merge: '<S131>/Merge' incorporates:\n         *  Constant: '<S138>/Constant'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[2]\n          = -1.0;\n\n        /* Merge: '<S131>/Merge1' incorporates:\n         *  Constant: '<S138>/Constant1'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[2]\n          = 0.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S131>/Zero airspeed in rotor plane' */\n    } else {\n      /* Outputs for IfAction SubSystem: '<S131>/Nonzero airspeed in rotor plane' incorporates:\n       *  ActionPort: '<S137>/Action Port'\n       */\n      /* Sqrt: '<S140>/Sqrt' incorporates:\n       *  Math: '<S141>/transpose'\n       *  Product: '<S141>/Product'\n       */\n      ctheta = std::sqrt(rtb_TrueairspeedatpropMotoraxes[0] *\n                         rtb_TrueairspeedatpropMotoraxes[0] +\n                         rtb_TrueairspeedatpropMotoraxes[1] *\n                         rtb_TrueairspeedatpropMotoraxes[1]);\n\n      /* Gain: '<S137>/Conversion deg to rad' incorporates:\n       *  Product: '<S137>/Product4'\n       */\n      theta = ctheta * 0.0 * 0.017453292519943295;\n\n      /* Trigonometry: '<S137>/Trigonometric Function' */\n      cpsi = std::sin(theta);\n\n      /* Product: '<S137>/Divide' */\n      rtb_Memory3_idx_0 = rtb_TrueairspeedatpropMotoraxes[0] / ctheta;\n      rtb_Memory3_idx_2 = rtb_Memory3_idx_0;\n\n      /* Product: '<S137>/Product2' incorporates:\n       *  Gain: '<S137>/Gain'\n       *  Product: '<S137>/Divide'\n       *  Product: '<S137>/Product'\n       */\n      rtb_Memory3_idx_1 = -rtb_Memory3_idx_0 * cpsi;\n\n      /* Product: '<S137>/Divide' */\n      rtb_Memory3_idx_0 = rtb_TrueairspeedatpropMotoraxes[1] / ctheta;\n\n      /* Product: '<S137>/Product2' incorporates:\n       *  Gain: '<S137>/Gain'\n       *  Product: '<S137>/Divide'\n       *  Product: '<S137>/Product'\n       */\n      cpsi *= -rtb_Memory3_idx_0;\n\n      /* Gain: '<S137>/Gain1' incorporates:\n       *  Trigonometry: '<S137>/Trigonometric Function1'\n       */\n      ctheta = -std::cos(theta);\n\n      /* Product: '<S137>/Product3' incorporates:\n       *  Constant: '<S137>/Constant'\n       *  Constant: '<S137>/Constant1'\n       *  Gain: '<S137>/Gain2'\n       *  Product: '<S137>/Divide'\n       *  Product: '<S137>/Product1'\n       */\n      rtb_Memory3_idx_0 = -rtb_Memory3_idx_0 * 0.23 * theta;\n      rtb_Memory3_idx_2 = rtb_Memory3_idx_2 * 0.23 * theta;\n      theta *= 0.0;\n      for (i = 0; i < 3; i++) {\n        /* Product: '<S137>/Product2' incorporates:\n         *  Concatenate: '<S169>/Vector Concatenate'\n         */\n        VectorConcatenate_tmp = Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n          VectorConcatenate[3 * i];\n        VectorConcatenate_tmp_0 = Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n          VectorConcatenate[3 * i + 1];\n        VectorConcatenate = Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n          VectorConcatenate[3 * i + 2];\n\n        /* Merge: '<S131>/Merge' incorporates:\n         *  Product: '<S137>/Product2'\n         *  Reshape: '<S137>/Reshape1'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[i]\n          = (VectorConcatenate_tmp_0 * cpsi + VectorConcatenate_tmp *\n             rtb_Memory3_idx_1) + VectorConcatenate * ctheta;\n\n        /* Merge: '<S131>/Merge1' incorporates:\n         *  Product: '<S137>/Product3'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[i]\n          = (VectorConcatenate_tmp_0 * rtb_Memory3_idx_2 + VectorConcatenate_tmp\n             * rtb_Memory3_idx_0) + VectorConcatenate * theta;\n      }\n\n      /* End of Outputs for SubSystem: '<S131>/Nonzero airspeed in rotor plane' */\n    }\n\n    /* End of If: '<S131>/If' */\n\n    /* Product: '<S128>/Product9' incorporates:\n     *  Merge: '<S131>/Merge'\n     */\n    theta = phi * Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[0];\n    rtb_Memory3_idx_1 = phi * Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[1];\n    cpsi = phi * Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n      NewtiltedthrustdirectionBodyaxe[2];\n\n    /* Sum: '<S134>/Sum' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n     *  Product: '<S134>/Product'\n     *  Product: '<S134>/Product1'\n     */\n    phi = Sim_Multi_ConstP.pooled10[ForEach_itr + 32] * cphi +\n      Sim_Multi_ConstP.pooled10[ForEach_itr + 36] * phi_tmp;\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      for (i = 0; i < 3; i++) {\n        /* Product: '<S136>/Product9' incorporates:\n         *  Concatenate: '<S169>/Vector Concatenate'\n         *  Constant: '<S136>/Constant'\n         *  Math: '<S136>/Math Function'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].Product9[i] =\n          (Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[3 * i + 1] *\n           0.0 + Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[3 * i] *\n           0.0) - Sim_Multi_B.CoreSubsys_p[ForEach_itr].VectorConcatenate[3 * i\n          + 2];\n      }\n\n      /* Gain: '<S156>/Gain' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       */\n      ctheta = Sim_Multi_ConstP.pooled10[ForEach_itr + 60] * 0.5;\n\n      /* Gain: '<S156>/Gain1' incorporates:\n       *  Constant: '<S59>/Constant'\n       *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n       *  Product: '<S156>/Product7'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Gain1 = ctheta * ctheta *\n        Sim_Multi_ConstP.pooled10[ForEach_itr + 64] * 0.58333333333333337;\n    }\n\n    /* Gain: '<S133>/Conversion rpm to rad//s' */\n    cphi *= 0.10471975511965977;\n\n    /* ForEachSliceSelector generated from: '<S112>/MotorMatrix_real' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  Product: '<S128>/Product3'\n     *  Product: '<S133>/Product5'\n     */\n    phi_tmp = Sim_Multi_ConstP.pooled10[ForEach_itr + 12];\n\n    /* Product: '<S133>/Product5' incorporates:\n     *  Constant: '<S59>/Constant'\n     *  ForEachSliceSelector generated from: '<S112>/MotorMatrix_real'\n     *  Integrator: '<S58>/omega'\n     *  Product: '<S157>/Product'\n     *  Product: '<S157>/Product1'\n     *  Product: '<S157>/Product2'\n     *  Product: '<S158>/Product'\n     *  Product: '<S158>/Product1'\n     *  Product: '<S158>/Product2'\n     *  Sum: '<S155>/Sum'\n     */\n    ctheta = phi_tmp * Sim_Multi_B.CoreSubsys_p[ForEach_itr].Gain1;\n    rtb_Sum_k1[0] = (Sim_Multi_X.omega_CSTATE[1] *\n                     Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                     NewtiltedthrustdirectionBodyaxe[2] -\n                     Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                     NewtiltedthrustdirectionBodyaxe[1] *\n                     Sim_Multi_X.omega_CSTATE[2]) * ctheta * cphi;\n    rtb_Sum_k1[1] = (Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                     NewtiltedthrustdirectionBodyaxe[0] *\n                     Sim_Multi_X.omega_CSTATE[2] - Sim_Multi_X.omega_CSTATE[0] *\n                     Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                     NewtiltedthrustdirectionBodyaxe[2]) * ctheta * cphi;\n    rtb_Sum_k1[2] = (Sim_Multi_X.omega_CSTATE[0] *\n                     Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                     NewtiltedthrustdirectionBodyaxe[1] -\n                     Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                     NewtiltedthrustdirectionBodyaxe[0] *\n                     Sim_Multi_X.omega_CSTATE[1]) * ctheta * cphi;\n\n    /* If: '<S143>/If' incorporates:\n     *  Math: '<S151>/transpose'\n     *  Product: '<S129>/Product'\n     *  Product: '<S151>/Product'\n     *  Sqrt: '<S148>/Sqrt'\n     */\n    if (rtsiIsModeUpdateTimeStep(&(&Sim_Multi_M)->solverInfo)) {\n      rtAction = static_cast<int8_T>(!(std::sqrt\n        ((rtb_TrueairspeedatpropMotoraxes[0] * rtb_TrueairspeedatpropMotoraxes[0]\n          + rtb_TrueairspeedatpropMotoraxes[1] *\n          rtb_TrueairspeedatpropMotoraxes[1]) + rtb_TrueairspeedatpropMotoraxes\n         [2] * rtb_TrueairspeedatpropMotoraxes[2]) == 0.0));\n      Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_l = rtAction;\n    } else {\n      rtAction = Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_l;\n    }\n\n    if (rtAction == 0) {\n      /* Outputs for IfAction SubSystem: '<S143>/Zero airspeed' incorporates:\n       *  ActionPort: '<S147>/Action Port'\n       */\n      if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n        /* Merge: '<S143>/Merge' incorporates:\n         *  Constant: '<S147>/Constant'\n         */\n        Sim_Multi_B.CoreSubsys_p[ForEach_itr].Angleofattackrad = 0.0;\n      }\n\n      /* End of Outputs for SubSystem: '<S143>/Zero airspeed' */\n    } else {\n      /* Outputs for IfAction SubSystem: '<S143>/Nonzero airspeed' incorporates:\n       *  ActionPort: '<S146>/Action Port'\n       */\n      /* Merge: '<S143>/Merge' incorporates:\n       *  Math: '<S150>/transpose'\n       *  Product: '<S146>/Divide1'\n       *  Product: '<S150>/Product'\n       *  Sqrt: '<S149>/Sqrt'\n       *  Trigonometry: '<S146>/Trigonometric Function'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Angleofattackrad = std::atan(1.0 /\n        std::sqrt(rtb_TrueairspeedatpropMotoraxes[0] *\n                  rtb_TrueairspeedatpropMotoraxes[0] +\n                  rtb_TrueairspeedatpropMotoraxes[1] *\n                  rtb_TrueairspeedatpropMotoraxes[1]) *\n        rtb_TrueairspeedatpropMotoraxes[2]);\n\n      /* End of Outputs for SubSystem: '<S143>/Nonzero airspeed' */\n    }\n\n    /* End of If: '<S143>/If' */\n\n    /* Gain: '<S144>/Gain' */\n    Sim_Multi_B.CoreSubsys_p[ForEach_itr].Climbspeedv_c =\n      -rtb_TrueairspeedatpropMotoraxes[2];\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      /* Product: '<S145>/Divide' incorporates:\n       *  Constant: '<S132>/Induced velocity at hover'\n       */\n      cphi = Sim_Multi_B.CoreSubsys_p[ForEach_itr].Climbspeedv_c / 4.0;\n\n      /* If: '<S145>/If' */\n      if (rtsiIsModeUpdateTimeStep(&(&Sim_Multi_M)->solverInfo)) {\n        if (cphi >= 0.0) {\n          Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_g = 0;\n        } else if (cphi >= -2.0) {\n          Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_g = 1;\n        } else {\n          Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_g = 2;\n        }\n      }\n\n      /* End of If: '<S145>/If' */\n    }\n\n    /* Product: '<S128>/Product3' */\n    phi *= phi_tmp;\n\n    /* ForEachSliceAssignment generated from: '<S112>/Motor_moment' incorporates:\n     *  Merge: '<S131>/Merge1'\n     *  Product: '<S128>/Product3'\n     *  Product: '<S136>/Product9'\n     *  Product: '<S170>/Product'\n     *  Product: '<S171>/Product'\n     *  Sum: '<S117>/Add'\n     *  Sum: '<S130>/Sum'\n     *  Sum: '<S67>/Sum'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_mo[3 * ForEach_itr] = ((phi *\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Product9[0] +\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[0])\n      + rtb_Sum_k1[0]) + (Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                          VectorfromrealCoGtopropellerBod[1] * cpsi -\n                          rtb_Memory3_idx_1 *\n                          Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                          VectorfromrealCoGtopropellerBod[2]);\n\n    /* ForEachSliceAssignment generated from: '<S112>/Motor_force' incorporates:\n     *  Product: '<S128>/Product9'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_fo[3 * ForEach_itr] = theta;\n\n    /* ForEachSliceAssignment generated from: '<S112>/Motor_moment' incorporates:\n     *  ForEachSliceAssignment generated from: '<S112>/Motor_force'\n     *  Merge: '<S131>/Merge1'\n     *  Product: '<S128>/Product3'\n     *  Product: '<S136>/Product9'\n     *  Product: '<S170>/Product1'\n     *  Product: '<S171>/Product1'\n     *  Sum: '<S117>/Add'\n     *  Sum: '<S130>/Sum'\n     *  Sum: '<S67>/Sum'\n     */\n    i = 3 * ForEach_itr + 1;\n    rtb_ImpAsg_InsertedFor_Motor_mo[i] = ((phi *\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Product9[1] +\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[1])\n      + rtb_Sum_k1[1]) + (theta * Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                          VectorfromrealCoGtopropellerBod[2] -\n                          Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                          VectorfromrealCoGtopropellerBod[0] * cpsi);\n\n    /* ForEachSliceAssignment generated from: '<S112>/Motor_force' incorporates:\n     *  Product: '<S128>/Product9'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_fo[i] = rtb_Memory3_idx_1;\n\n    /* ForEachSliceAssignment generated from: '<S112>/Motor_moment' incorporates:\n     *  ForEachSliceAssignment generated from: '<S112>/Motor_force'\n     *  Merge: '<S131>/Merge1'\n     *  Product: '<S128>/Product3'\n     *  Product: '<S136>/Product9'\n     *  Product: '<S170>/Product2'\n     *  Product: '<S171>/Product2'\n     *  Sum: '<S117>/Add'\n     *  Sum: '<S130>/Sum'\n     *  Sum: '<S67>/Sum'\n     */\n    i = 3 * ForEach_itr + 2;\n    rtb_ImpAsg_InsertedFor_Motor_mo[i] = ((phi *\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Product9[2] +\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Momentinthemotorhubduetobending[2])\n      + rtb_Sum_k1[2]) + (Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                          VectorfromrealCoGtopropellerBod[0] * rtb_Memory3_idx_1\n                          - theta * Sim_Multi_B.CoreSubsys_p[ForEach_itr].\n                          VectorfromrealCoGtopropellerBod[1]);\n\n    /* ForEachSliceAssignment generated from: '<S112>/Motor_force' incorporates:\n     *  Product: '<S128>/Product9'\n     */\n    rtb_ImpAsg_InsertedFor_Motor_fo[i] = cpsi;\n  }\n\n  /* End of Outputs for SubSystem: '<S94>/For Each Subsystem' */\n\n  /* Sum: '<S94>/Sum of Elements1' incorporates:\n   *  ForEachSliceAssignment generated from: '<S112>/Motor_moment'\n   *  Sum: '<S67>/Sum'\n   */\n  for (i = 0; i < 3; i++) {\n    rtb_Sum_k1[i] = ((rtb_ImpAsg_InsertedFor_Motor_mo[i + 3] +\n                      rtb_ImpAsg_InsertedFor_Motor_mo[i]) +\n                     rtb_ImpAsg_InsertedFor_Motor_mo[i + 6]) +\n      rtb_ImpAsg_InsertedFor_Motor_mo[i + 9];\n  }\n\n  /* End of Sum: '<S94>/Sum of Elements1' */\n\n  /* Sum: '<S63>/Sum1' incorporates:\n   *  Sum: '<S60>/Sum2'\n   *  Sum: '<S67>/Sum'\n   *  Sum: '<S68>/Sum'\n   */\n  rtb_TrueairspeedBodyaxes[0] = rtb_Sum_k1[0] - (rtb_VectorConcatenate_g_tmp_1 -\n    rtb_VectorConcatenate_g_tmp);\n  rtb_TrueairspeedBodyaxes[1] = rtb_Sum_k1[1] - (rtb_VectorConcatenate_g_tmp_2 -\n    rtb_VectorConcatenate_g_tmp_0);\n  rtb_TrueairspeedBodyaxes[2] = rtb_Sum_k1[2] - (rtb_VectorConcatenate_g_tmp_3 -\n    rtb_VectorConcatenate_g_tmp_4);\n\n  /* Product: '<S63>/Product' incorporates:\n   *  Constant: '<S59>/Constant3'\n   */\n  rt_mldivide_U1d3x3_U2d_JBYZyA3A(Sim_Multi_ConstP.pooled11,\n    rtb_TrueairspeedBodyaxes, Sim_Multi_B.Product_l);\n\n  /* Sum: '<S94>/Sum of Elements' incorporates:\n   *  ForEachSliceAssignment generated from: '<S112>/Motor_force'\n   *  Sum: '<S67>/Sum'\n   */\n  for (i = 0; i < 3; i++) {\n    rtb_Sum_k1[i] = ((rtb_ImpAsg_InsertedFor_Motor_fo[i + 3] +\n                      rtb_ImpAsg_InsertedFor_Motor_fo[i]) +\n                     rtb_ImpAsg_InsertedFor_Motor_fo[i + 6]) +\n      rtb_ImpAsg_InsertedFor_Motor_fo[i + 9];\n  }\n\n  /* End of Sum: '<S94>/Sum of Elements' */\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    /* Product: '<S93>/Product1' incorporates:\n     *  Constant: '<S59>/Constant2'\n     *  Constant: '<S93>/Gravity (Inertial axes)'\n     */\n    Sim_Multi_B.ForceofgravityInertialaxes[0] = 0.0;\n    Sim_Multi_B.ForceofgravityInertialaxes[1] = 0.0;\n    Sim_Multi_B.ForceofgravityInertialaxes[2] = 5.3936575;\n  }\n\n  /* Sum: '<S96>/Sum1' incorporates:\n   *  Integrator: '<S58>/V_b'\n   *  Product: '<S111>/Product'\n   */\n  rtb_TrueairspeedBodyaxes_b[0] = Sim_Multi_X.V_b_CSTATE[0] -\n    rtb_TrueairspeedBodyaxes_b[0];\n  rtb_TrueairspeedBodyaxes_b[1] = Sim_Multi_X.V_b_CSTATE[1] -\n    rtb_TrueairspeedBodyaxes_b[1];\n  rtb_TrueairspeedBodyaxes_b[2] = Sim_Multi_X.V_b_CSTATE[2] -\n    rtb_TrueairspeedBodyaxes_b[2];\n\n  /* If: '<S95>/If' incorporates:\n   *  Math: '<S110>/transpose'\n   *  Product: '<S110>/Product'\n   *  Sqrt: '<S99>/Sqrt'\n   *  Sum: '<S96>/Sum1'\n   */\n  if (rtsiIsModeUpdateTimeStep(&(&Sim_Multi_M)->solverInfo)) {\n    rtAction = static_cast<int8_T>(!(std::sqrt((rtb_TrueairspeedBodyaxes_b[0] *\n      rtb_TrueairspeedBodyaxes_b[0] + rtb_TrueairspeedBodyaxes_b[1] *\n      rtb_TrueairspeedBodyaxes_b[1]) + rtb_TrueairspeedBodyaxes_b[2] *\n      rtb_TrueairspeedBodyaxes_b[2]) == 0.0));\n    Sim_Multi_DW.If_ActiveSubsystem = rtAction;\n  } else {\n    rtAction = Sim_Multi_DW.If_ActiveSubsystem;\n  }\n\n  if (rtAction == 0) {\n    /* Outputs for IfAction SubSystem: '<S95>/Zero airspeed' incorporates:\n     *  ActionPort: '<S98>/Action Port'\n     */\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      /* Merge: '<S95>/Merge' incorporates:\n       *  Constant: '<S98>/Constant'\n       */\n      Sim_Multi_B.Forceagainstdirectionofmotiondu[0] = 0.0;\n      Sim_Multi_B.Forceagainstdirectionofmotiondu[1] = 0.0;\n      Sim_Multi_B.Forceagainstdirectionofmotiondu[2] = 0.0;\n    }\n\n    /* End of Outputs for SubSystem: '<S95>/Zero airspeed' */\n  } else {\n    /* Outputs for IfAction SubSystem: '<S95>/Nonzero airspeed' incorporates:\n     *  ActionPort: '<S97>/Action Port'\n     */\n    /* Product: '<S105>/Divide' incorporates:\n     *  Constant: '<S59>/Surface area params'\n     */\n    cphi = rtb_TrueairspeedBodyaxes_b[0] / 0.06;\n\n    /* Product: '<S105>/Product' */\n    phi = cphi * cphi;\n\n    /* Product: '<S105>/Divide1' incorporates:\n     *  Constant: '<S59>/Surface area params'\n     */\n    cphi = rtb_TrueairspeedBodyaxes_b[1] / 0.06;\n\n    /* Product: '<S105>/Product1' */\n    ctheta = cphi * cphi;\n\n    /* Product: '<S105>/Divide2' incorporates:\n     *  Constant: '<S59>/Surface area params'\n     */\n    cphi = rtb_TrueairspeedBodyaxes_b[2] / 0.06;\n\n    /* Sum: '<S105>/Add' incorporates:\n     *  Product: '<S105>/Product2'\n     */\n    cphi = (phi + ctheta) + cphi * cphi;\n\n    /* Sqrt: '<S105>/Reciprocal Sqrt' */\n    if (cphi > 0.0) {\n      if (std::isinf(cphi)) {\n        cphi = 0.0;\n      } else {\n        cphi = 1.0 / std::sqrt(cphi);\n      }\n    } else if (cphi == 0.0) {\n      cphi = (rtInf);\n    } else {\n      cphi = (rtNaN);\n    }\n\n    /* End of Sqrt: '<S105>/Reciprocal Sqrt' */\n\n    /* Product: '<S106>/Product' incorporates:\n     *  Sum: '<S96>/Sum1'\n     */\n    rtb_VectorConcatenate_g_tmp_1 = rtb_TrueairspeedBodyaxes_b[0] * cphi;\n\n    /* Product: '<S108>/Product' incorporates:\n     *  Math: '<S108>/transpose'\n     *  Product: '<S106>/Product'\n     */\n    rtb_VectorConcatenate_g_tmp_2 = rtb_VectorConcatenate_g_tmp_1 *\n      rtb_VectorConcatenate_g_tmp_1;\n\n    /* Product: '<S106>/Product' incorporates:\n     *  Sum: '<S96>/Sum1'\n     */\n    rtb_VectorConcatenate_g_tmp_1 = rtb_TrueairspeedBodyaxes_b[1] * cphi;\n\n    /* Product: '<S108>/Product' incorporates:\n     *  Math: '<S108>/transpose'\n     *  Product: '<S106>/Product'\n     */\n    rtb_VectorConcatenate_g_tmp_2 += rtb_VectorConcatenate_g_tmp_1 *\n      rtb_VectorConcatenate_g_tmp_1;\n\n    /* Product: '<S106>/Product' incorporates:\n     *  Sum: '<S96>/Sum1'\n     */\n    rtb_VectorConcatenate_g_tmp_1 = rtb_TrueairspeedBodyaxes_b[2] * cphi;\n\n    /* Product: '<S109>/Product' incorporates:\n     *  Product: '<S104>/Product'\n     *  Product: '<S106>/Product'\n     *  Sum: '<S96>/Sum1'\n     */\n    phi_tmp = (rtb_TrueairspeedBodyaxes_b[0] * rtb_TrueairspeedBodyaxes_b[0] +\n               rtb_TrueairspeedBodyaxes_b[1] * rtb_TrueairspeedBodyaxes_b[1]) +\n      rtb_TrueairspeedBodyaxes_b[2] * rtb_TrueairspeedBodyaxes_b[2];\n\n    /* Abs: '<S97>/Abs' incorporates:\n     *  Constant: '<S97>/Constant'\n     *  Constant: '<S97>/Constant1'\n     *  Constant: '<S97>/Constant2'\n     *  Math: '<S108>/transpose'\n     *  Product: '<S106>/Product'\n     *  Product: '<S108>/Product'\n     *  Product: '<S109>/Product'\n     *  Product: '<S97>/Product'\n     *  Sqrt: '<S107>/Sqrt'\n     */\n    phi = std::abs(phi_tmp * 0.6125 * 0.4 * std::sqrt\n                   (rtb_VectorConcatenate_g_tmp_1 *\n                    rtb_VectorConcatenate_g_tmp_1 +\n                    rtb_VectorConcatenate_g_tmp_2));\n\n    /* Sqrt: '<S103>/Sqrt' */\n    cphi = std::sqrt(phi_tmp);\n\n    /* Merge: '<S95>/Merge' incorporates:\n     *  Gain: '<S97>/Drag force opposes direction of airspeed'\n     *  Product: '<S100>/Divide'\n     *  Product: '<S97>/Product1'\n     *  Sum: '<S96>/Sum1'\n     */\n    Sim_Multi_B.Forceagainstdirectionofmotiondu[0] =\n      -(rtb_TrueairspeedBodyaxes_b[0] / cphi * phi);\n    Sim_Multi_B.Forceagainstdirectionofmotiondu[1] =\n      -(rtb_TrueairspeedBodyaxes_b[1] / cphi * phi);\n    Sim_Multi_B.Forceagainstdirectionofmotiondu[2] =\n      -(rtb_TrueairspeedBodyaxes_b[2] / cphi * phi);\n\n    /* End of Outputs for SubSystem: '<S95>/Nonzero airspeed' */\n  }\n\n  /* End of If: '<S95>/If' */\n\n  /* SignalConversion generated from: '<S64>/Q-Integrator' incorporates:\n   *  Gain: '<S64>/-1//2'\n   *  Gain: '<S64>/1//2'\n   *  Integrator: '<S58>/omega'\n   *  Product: '<S64>/Product'\n   *  Product: '<S73>/Product'\n   *  Product: '<S76>/Product'\n   *  Product: '<S76>/Product1'\n   *  Product: '<S76>/Product2'\n   *  Product: '<S77>/Product'\n   *  Product: '<S77>/Product1'\n   *  Product: '<S77>/Product2'\n   *  Sum: '<S64>/Subtract'\n   *  Sum: '<S72>/Sum'\n   */\n  Sim_Multi_B.TmpSignalConversionAtQIntegrato[0] = ((Sim_Multi_X.omega_CSTATE[0]\n    * rtb_Divide_idx_1 + Sim_Multi_X.omega_CSTATE[1] * rtb_Divide_idx_2) +\n    Sim_Multi_X.omega_CSTATE[2] * rtb_Divide_idx_3) * -0.5;\n  Sim_Multi_B.TmpSignalConversionAtQIntegrato[1] = (rtb_Divide_idx_0 *\n    Sim_Multi_X.omega_CSTATE[0] - (Sim_Multi_X.omega_CSTATE[1] *\n    rtb_Divide_idx_3 - Sim_Multi_X.omega_CSTATE[2] * rtb_Divide_idx_2)) * 0.5;\n  Sim_Multi_B.TmpSignalConversionAtQIntegrato[2] = (rtb_Divide_idx_0 *\n    Sim_Multi_X.omega_CSTATE[1] - (rtb_Divide_idx_1 * Sim_Multi_X.omega_CSTATE[2]\n    - Sim_Multi_X.omega_CSTATE[0] * rtb_Divide_idx_3)) * 0.5;\n  Sim_Multi_B.TmpSignalConversionAtQIntegrato[3] = (rtb_Divide_idx_0 *\n    Sim_Multi_X.omega_CSTATE[2] - (Sim_Multi_X.omega_CSTATE[0] *\n    rtb_Divide_idx_2 - Sim_Multi_X.omega_CSTATE[1] * rtb_Divide_idx_1)) * 0.5;\n\n  /* Sum: '<S67>/Sum' incorporates:\n   *  Integrator: '<S58>/V_b'\n   *  Integrator: '<S58>/omega'\n   *  Product: '<S90>/Product'\n   *  Product: '<S90>/Product1'\n   *  Product: '<S90>/Product2'\n   *  Product: '<S91>/Product'\n   *  Product: '<S91>/Product1'\n   *  Product: '<S91>/Product2'\n   */\n  rtb_TrueairspeedBodyaxes_b[0] = Sim_Multi_X.omega_CSTATE[1] *\n    Sim_Multi_X.V_b_CSTATE[2];\n  rtb_TrueairspeedBodyaxes_b[1] = Sim_Multi_X.V_b_CSTATE[0] *\n    Sim_Multi_X.omega_CSTATE[2];\n  rtb_TrueairspeedBodyaxes_b[2] = Sim_Multi_X.omega_CSTATE[0] *\n    Sim_Multi_X.V_b_CSTATE[1];\n  rtb_TrueairspeedBodyaxes[0] = Sim_Multi_X.V_b_CSTATE[1] *\n    Sim_Multi_X.omega_CSTATE[2];\n  rtb_TrueairspeedBodyaxes[1] = Sim_Multi_X.omega_CSTATE[0] *\n    Sim_Multi_X.V_b_CSTATE[2];\n  rtb_TrueairspeedBodyaxes[2] = Sim_Multi_X.V_b_CSTATE[0] *\n    Sim_Multi_X.omega_CSTATE[1];\n\n  /* Product: '<S93>/Product' */\n  cphi = Sim_Multi_B.ForceofgravityInertialaxes[1];\n  rtb_VectorConcatenate_g_tmp_1 = Sim_Multi_B.ForceofgravityInertialaxes[0];\n  rtb_VectorConcatenate_g_tmp_2 = Sim_Multi_B.ForceofgravityInertialaxes[2];\n  for (i = 0; i < 3; i++) {\n    /* Sum: '<S58>/Sum1' incorporates:\n     *  Concatenate: '<S89>/Vector Concatenate'\n     *  Constant: '<S59>/Constant2'\n     *  Merge: '<S95>/Merge'\n     *  Product: '<S58>/Product1'\n     *  Sum: '<S60>/Sum'\n     *  Sum: '<S60>/Sum3'\n     *  Sum: '<S67>/Sum'\n     */\n    Sim_Multi_B.Sum1_o[i] = ((((rtb_VectorConcatenate_k[i + 3] * cphi +\n      rtb_VectorConcatenate_k[i] * rtb_VectorConcatenate_g_tmp_1) +\n      rtb_VectorConcatenate_k[i + 6] * rtb_VectorConcatenate_g_tmp_2) +\n      rtb_Sum_k1[i]) + Sim_Multi_B.Forceagainstdirectionofmotiondu[i]) / 0.55 -\n      (rtb_TrueairspeedBodyaxes_b[i] - rtb_TrueairspeedBodyaxes[i]);\n\n    /* Sum: '<S35>/Sum' incorporates:\n     *  Integrator: '<S58>/omega'\n     */\n    Sim_Multi_B.omega[i] = Sim_Multi_X.omega_CSTATE[i];\n  }\n\n  /* End of Product: '<S93>/Product' */\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n\n  /* Sum: '<S35>/Sum1' incorporates:\n   *  Sum: '<S58>/Sum1'\n   */\n  Sim_Multi_B.a_b[0] = Sim_Multi_B.Sum1_o[0];\n  Sim_Multi_B.a_b[1] = Sim_Multi_B.Sum1_o[1];\n  Sim_Multi_B.a_b[2] = Sim_Multi_B.Sum1_o[2];\n\n  /* RateTransition: '<S4>/Rate Transition' incorporates:\n   *  Memory: '<S36>/Memory1'\n   *  Memory: '<S36>/Memory2'\n   *  Memory: '<S36>/Memory3'\n   */\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    if ((&Sim_Multi_M)->Timing.RateInteraction.TID1_2 == 1) {\n      Sim_Multi_DW.RateTransition_Buffer_b[0] = rtb_Memory_idx_0;\n      Sim_Multi_DW.RateTransition_Buffer_b[1] = rtb_Memory_idx_1;\n      Sim_Multi_DW.RateTransition_Buffer_b[2] = rtb_Memory_idx_2;\n      Sim_Multi_DW.RateTransition_Buffer_b[3] = rtb_Memory_idx_3;\n      Sim_Multi_DW.RateTransition_Buffer_b[4] = Sim_Multi_B.omega[0];\n      Sim_Multi_DW.RateTransition_Buffer_b[7] =\n        Sim_Multi_DW.Memory1_PreviousInput[0];\n      Sim_Multi_DW.RateTransition_Buffer_b[10] =\n        Sim_Multi_DW.Memory2_PreviousInput[0];\n      Sim_Multi_DW.RateTransition_Buffer_b[13] =\n        Sim_Multi_DW.Memory3_PreviousInput[0];\n      Sim_Multi_DW.RateTransition_Buffer_b[16] = Sim_Multi_B.a_b[0];\n      Sim_Multi_DW.RateTransition_Buffer_b[5] = Sim_Multi_B.omega[1];\n      Sim_Multi_DW.RateTransition_Buffer_b[8] =\n        Sim_Multi_DW.Memory1_PreviousInput[1];\n      Sim_Multi_DW.RateTransition_Buffer_b[11] =\n        Sim_Multi_DW.Memory2_PreviousInput[1];\n      Sim_Multi_DW.RateTransition_Buffer_b[14] =\n        Sim_Multi_DW.Memory3_PreviousInput[1];\n      Sim_Multi_DW.RateTransition_Buffer_b[17] = Sim_Multi_B.a_b[1];\n      Sim_Multi_DW.RateTransition_Buffer_b[6] = Sim_Multi_B.omega[2];\n      Sim_Multi_DW.RateTransition_Buffer_b[9] =\n        Sim_Multi_DW.Memory1_PreviousInput[2];\n      Sim_Multi_DW.RateTransition_Buffer_b[12] =\n        Sim_Multi_DW.Memory2_PreviousInput[2];\n      Sim_Multi_DW.RateTransition_Buffer_b[15] =\n        Sim_Multi_DW.Memory3_PreviousInput[2];\n      Sim_Multi_DW.RateTransition_Buffer_b[18] = Sim_Multi_B.a_b[2];\n    }\n\n    /* UniformRandomNumber: '<S37>/Uniform Random Number' incorporates:\n     *  Memory: '<S36>/Memory1'\n     *  Memory: '<S36>/Memory2'\n     *  Memory: '<S36>/Memory3'\n     */\n    Sim_Multi_B.UniformRandomNumber =\n      Sim_Multi_DW.UniformRandomNumber_NextOutput;\n\n    /* UniformRandomNumber: '<S38>/Uniform Random Number' */\n    Sim_Multi_B.UniformRandomNumber_n =\n      Sim_Multi_DW.UniformRandomNumber_NextOutpu_m;\n\n    /* Switch: '<S42>/Switch' incorporates:\n     *  Constant: '<S42>/Constant1'\n     */\n    Sim_Multi_B.Switch = 0.0;\n\n    /* Switch: '<S45>/Switch' incorporates:\n     *  Constant: '<S45>/Constant1'\n     */\n    Sim_Multi_B.Switch_j = 0.0;\n\n    /* Switch: '<S45>/Switch1' incorporates:\n     *  Constant: '<S45>/Constant3'\n     */\n    Sim_Multi_B.Switch1 = 0.0;\n\n    /* Switch: '<S45>/Switch2' incorporates:\n     *  Constant: '<S45>/Constant5'\n     */\n    Sim_Multi_B.Switch2 = 0.0;\n  }\n\n  /* End of RateTransition: '<S4>/Rate Transition' */\n\n  /* Sum: '<S36>/Sum' incorporates:\n   *  Product: '<S75>/Divide'\n   */\n  rtb_Memory_idx_0 = rtb_Divide_idx_0 + Sim_Multi_B.Switch;\n  rtb_Divide_idx_0 = rtb_Memory_idx_0;\n\n  /* Product: '<S47>/Product' incorporates:\n   *  Math: '<S47>/transpose'\n   *  Sum: '<S36>/Sum'\n   */\n  rtb_Memory_idx_1 = rtb_Memory_idx_0 * rtb_Memory_idx_0;\n\n  /* Sum: '<S36>/Sum' incorporates:\n   *  Product: '<S75>/Divide'\n   */\n  rtb_Memory_idx_0 = rtb_Divide_idx_1 + Sim_Multi_B.Switch;\n  rtb_Divide_idx_1 = rtb_Memory_idx_0;\n\n  /* Product: '<S47>/Product' incorporates:\n   *  Math: '<S47>/transpose'\n   *  Sum: '<S36>/Sum'\n   */\n  rtb_Memory_idx_1 += rtb_Memory_idx_0 * rtb_Memory_idx_0;\n\n  /* Sum: '<S36>/Sum' incorporates:\n   *  Product: '<S75>/Divide'\n   */\n  rtb_Memory_idx_0 = rtb_Divide_idx_2 + Sim_Multi_B.Switch;\n  rtb_Divide_idx_2 = rtb_Memory_idx_0;\n\n  /* Product: '<S47>/Product' incorporates:\n   *  Math: '<S47>/transpose'\n   *  Sum: '<S36>/Sum'\n   */\n  rtb_Memory_idx_1 += rtb_Memory_idx_0 * rtb_Memory_idx_0;\n\n  /* Sum: '<S36>/Sum' incorporates:\n   *  Product: '<S75>/Divide'\n   */\n  rtb_Memory_idx_0 = rtb_Divide_idx_3 + Sim_Multi_B.Switch;\n\n  /* Sqrt: '<S46>/Sqrt' incorporates:\n   *  Math: '<S47>/transpose'\n   *  Product: '<S47>/Product'\n   *  Sum: '<S36>/Sum'\n   */\n  cphi = std::sqrt(rtb_Memory_idx_0 * rtb_Memory_idx_0 + rtb_Memory_idx_1);\n\n  /* Product: '<S41>/Divide' incorporates:\n   *  Sum: '<S36>/Sum'\n   */\n  Sim_Multi_B.Divide[0] = rtb_Divide_idx_0 / cphi;\n  Sim_Multi_B.Divide[1] = rtb_Divide_idx_1 / cphi;\n  Sim_Multi_B.Divide[2] = rtb_Divide_idx_2 / cphi;\n  Sim_Multi_B.Divide[3] = rtb_Memory_idx_0 / cphi;\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  /* Sum: '<S36>/Sum1' incorporates:\n   *  Integrator: '<S58>/X_i'\n   */\n  Sim_Multi_B.Sum1[0] = Sim_Multi_X.X_i_CSTATE[0] + Sim_Multi_B.Switch_j;\n  Sim_Multi_B.Sum1[1] = Sim_Multi_X.X_i_CSTATE[1] + Sim_Multi_B.Switch1;\n  Sim_Multi_B.Sum1[2] = Sim_Multi_X.X_i_CSTATE[2] + Sim_Multi_B.Switch2;\n\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    /* Switch: '<S44>/Switch' incorporates:\n     *  Constant: '<S44>/Constant1'\n     */\n    Sim_Multi_B.Switch_jm = 0.0;\n\n    /* Switch: '<S44>/Switch1' incorporates:\n     *  Constant: '<S44>/Constant3'\n     */\n    Sim_Multi_B.Switch1_m = 0.0;\n\n    /* Switch: '<S44>/Switch2' incorporates:\n     *  Constant: '<S44>/Constant5'\n     */\n    Sim_Multi_B.Switch2_m = 0.0;\n\n    /* Switch: '<S43>/Switch' incorporates:\n     *  Constant: '<S43>/Constant1'\n     */\n    Sim_Multi_B.Switch_f = 0.0;\n\n    /* Switch: '<S43>/Switch1' incorporates:\n     *  Constant: '<S43>/Constant3'\n     */\n    Sim_Multi_B.Switch1_d = 0.0;\n\n    /* Switch: '<S43>/Switch2' incorporates:\n     *  Constant: '<S43>/Constant5'\n     */\n    Sim_Multi_B.Switch2_n = 0.0;\n  }\n\n  /* Sum: '<S36>/Sum2' incorporates:\n   *  Product: '<S61>/Product'\n   */\n  Sim_Multi_B.Sum2[0] = Sim_Multi_B.Product[0] + Sim_Multi_B.Switch_jm;\n  Sim_Multi_B.Sum2[1] = Sim_Multi_B.Product[1] + Sim_Multi_B.Switch1_m;\n  Sim_Multi_B.Sum2[2] = Sim_Multi_B.Product[2] + Sim_Multi_B.Switch2_m;\n\n  /* Outputs for Atomic SubSystem: '<Root>/multirotor' */\n  /* Sum: '<S36>/Sum3' incorporates:\n   *  Integrator: '<S58>/V_b'\n   */\n  Sim_Multi_B.Sum3[0] = Sim_Multi_X.V_b_CSTATE[0] + Sim_Multi_B.Switch_f;\n  Sim_Multi_B.Sum3[1] = Sim_Multi_X.V_b_CSTATE[1] + Sim_Multi_B.Switch1_d;\n  Sim_Multi_B.Sum3[2] = Sim_Multi_X.V_b_CSTATE[2] + Sim_Multi_B.Switch2_n;\n\n  /* End of Outputs for SubSystem: '<Root>/multirotor' */\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n      /* Update for Memory: '<S36>/Memory' incorporates:\n       *  Product: '<S41>/Divide'\n       */\n      Sim_Multi_DW.Memory_PreviousInput[0] = Sim_Multi_B.Divide[0];\n      Sim_Multi_DW.Memory_PreviousInput[1] = Sim_Multi_B.Divide[1];\n      Sim_Multi_DW.Memory_PreviousInput[2] = Sim_Multi_B.Divide[2];\n      Sim_Multi_DW.Memory_PreviousInput[3] = Sim_Multi_B.Divide[3];\n\n      /* Update for Memory: '<S36>/Memory1' incorporates:\n       *  Sum: '<S36>/Sum1'\n       */\n      Sim_Multi_DW.Memory1_PreviousInput[0] = Sim_Multi_B.Sum1[0];\n\n      /* Update for Memory: '<S36>/Memory2' incorporates:\n       *  Sum: '<S36>/Sum2'\n       */\n      Sim_Multi_DW.Memory2_PreviousInput[0] = Sim_Multi_B.Sum2[0];\n\n      /* Update for Memory: '<S36>/Memory3' incorporates:\n       *  Sum: '<S36>/Sum3'\n       */\n      Sim_Multi_DW.Memory3_PreviousInput[0] = Sim_Multi_B.Sum3[0];\n\n      /* Update for Memory: '<S36>/Memory1' incorporates:\n       *  Sum: '<S36>/Sum1'\n       */\n      Sim_Multi_DW.Memory1_PreviousInput[1] = Sim_Multi_B.Sum1[1];\n\n      /* Update for Memory: '<S36>/Memory2' incorporates:\n       *  Sum: '<S36>/Sum2'\n       */\n      Sim_Multi_DW.Memory2_PreviousInput[1] = Sim_Multi_B.Sum2[1];\n\n      /* Update for Memory: '<S36>/Memory3' incorporates:\n       *  Sum: '<S36>/Sum3'\n       */\n      Sim_Multi_DW.Memory3_PreviousInput[1] = Sim_Multi_B.Sum3[1];\n\n      /* Update for Memory: '<S36>/Memory1' incorporates:\n       *  Sum: '<S36>/Sum1'\n       */\n      Sim_Multi_DW.Memory1_PreviousInput[2] = Sim_Multi_B.Sum1[2];\n\n      /* Update for Memory: '<S36>/Memory2' incorporates:\n       *  Sum: '<S36>/Sum2'\n       */\n      Sim_Multi_DW.Memory2_PreviousInput[2] = Sim_Multi_B.Sum2[2];\n\n      /* Update for Memory: '<S36>/Memory3' incorporates:\n       *  Sum: '<S36>/Sum3'\n       */\n      Sim_Multi_DW.Memory3_PreviousInput[2] = Sim_Multi_B.Sum3[2];\n\n      /* Update for UniformRandomNumber: '<S37>/Uniform Random Number' */\n      Sim_Multi_DW.UniformRandomNumber_NextOutput = rt_urand_Upu32_Yd_f_pw_snf\n        (&Sim_Multi_DW.RandSeed) * 0.002 - 0.001;\n\n      /* Update for UniformRandomNumber: '<S38>/Uniform Random Number' */\n      Sim_Multi_DW.UniformRandomNumber_NextOutpu_m = rt_urand_Upu32_Yd_f_pw_snf(\n        &Sim_Multi_DW.RandSeed_b) * 0.002 - 0.001;\n    }\n\n    /* Update for Atomic SubSystem: '<Root>/multirotor' */\n    /* Update for Integrator: '<S64>/Q-Integrator' */\n    Sim_Multi_DW.QIntegrator_IWORK = 0;\n\n    /* End of Update for SubSystem: '<Root>/multirotor' */\n  }                                    /* end MajorTimeStep */\n\n  if (rtmIsMajorTimeStep((&Sim_Multi_M))) {\n    rt_ertODEUpdateContinuousStates(&(&Sim_Multi_M)->solverInfo);\n\n    /* Update absolute time */\n    /* The \"clockTick0\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n     * overflow during the application lifespan selected.\n     */\n    ++(&Sim_Multi_M)->Timing.clockTick0;\n    (&Sim_Multi_M)->Timing.t[0] = rtsiGetSolverStopTime(&(&Sim_Multi_M)\n      ->solverInfo);\n\n    /* Update absolute time */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The resolution of this integer timer is 0.001, which is the step size\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n     * application lifespan selected.\n     */\n    (&Sim_Multi_M)->Timing.clockTick1++;\n  }                                    /* end MajorTimeStep */\n}\n\n/* Derivatives for root system: '<Root>' */\nvoid Sim_Multi::Sim_Multi_derivatives()\n{\n  /* local scratch DWork variables */\n  int32_T ForEach_itr;\n  XDot_Sim_Multi_T *_rtXdot;\n  _rtXdot = ((XDot_Sim_Multi_T *) (&Sim_Multi_M)->derivs);\n\n  /* Derivatives for TransferFcn: '<S31>/Transfer Fcn1' */\n  _rtXdot->TransferFcn1_CSTATE = -100.0 * Sim_Multi_X.TransferFcn1_CSTATE;\n  _rtXdot->TransferFcn1_CSTATE += Sim_Multi_B.TransferFcn6;\n\n  /* Derivatives for TransferFcn: '<S31>/Transfer Fcn6' */\n  _rtXdot->TransferFcn6_CSTATE = -100.0 * Sim_Multi_X.TransferFcn6_CSTATE;\n  _rtXdot->TransferFcn6_CSTATE += Sim_Multi_B.Gain2_i;\n\n  /* Derivatives for TransferFcn: '<S31>/Transfer Fcn4' */\n  _rtXdot->TransferFcn4_CSTATE = -100.0 * Sim_Multi_X.TransferFcn4_CSTATE;\n  _rtXdot->TransferFcn4_CSTATE += Sim_Multi_B.Gain2;\n\n  /* Derivatives for TransferFcn: '<S31>/Transfer Fcn5' */\n  _rtXdot->TransferFcn5_CSTATE = -100.0 * Sim_Multi_X.TransferFcn5_CSTATE;\n  _rtXdot->TransferFcn5_CSTATE += Sim_Multi_B.TransferFcn4;\n\n  /* Derivatives for TransferFcn: '<S31>/Transfer Fcn2' */\n  _rtXdot->TransferFcn2_CSTATE = -100.0 * Sim_Multi_X.TransferFcn2_CSTATE;\n  _rtXdot->TransferFcn2_CSTATE += Sim_Multi_B.Gain2_g;\n\n  /* Derivatives for TransferFcn: '<S31>/Transfer Fcn3' */\n  _rtXdot->TransferFcn3_CSTATE = -100.0 * Sim_Multi_X.TransferFcn3_CSTATE;\n  _rtXdot->TransferFcn3_CSTATE += Sim_Multi_B.TransferFcn2;\n\n  /* Derivatives for Atomic SubSystem: '<Root>/multirotor' */\n  /* Derivatives for Integrator: '<S64>/Q-Integrator' incorporates:\n   *  SignalConversion generated from: '<S64>/Q-Integrator'\n   */\n  _rtXdot->QIntegrator_CSTATE[0] = Sim_Multi_B.TmpSignalConversionAtQIntegrato[0];\n  _rtXdot->QIntegrator_CSTATE[1] = Sim_Multi_B.TmpSignalConversionAtQIntegrato[1];\n  _rtXdot->QIntegrator_CSTATE[2] = Sim_Multi_B.TmpSignalConversionAtQIntegrato[2];\n  _rtXdot->QIntegrator_CSTATE[3] = Sim_Multi_B.TmpSignalConversionAtQIntegrato[3];\n\n  /* Derivatives for Integrator: '<S58>/V_b' incorporates:\n   *  Sum: '<S58>/Sum1'\n   */\n  _rtXdot->V_b_CSTATE[0] = Sim_Multi_B.Sum1_o[0];\n\n  /* Derivatives for Integrator: '<S58>/omega' incorporates:\n   *  Product: '<S63>/Product'\n   */\n  _rtXdot->omega_CSTATE[0] = Sim_Multi_B.Product_l[0];\n\n  /* Derivatives for Integrator: '<S58>/V_b' incorporates:\n   *  Sum: '<S58>/Sum1'\n   */\n  _rtXdot->V_b_CSTATE[1] = Sim_Multi_B.Sum1_o[1];\n\n  /* Derivatives for Integrator: '<S58>/omega' incorporates:\n   *  Product: '<S63>/Product'\n   */\n  _rtXdot->omega_CSTATE[1] = Sim_Multi_B.Product_l[1];\n\n  /* Derivatives for Integrator: '<S58>/V_b' incorporates:\n   *  Sum: '<S58>/Sum1'\n   */\n  _rtXdot->V_b_CSTATE[2] = Sim_Multi_B.Sum1_o[2];\n\n  /* Derivatives for Integrator: '<S58>/omega' incorporates:\n   *  Product: '<S63>/Product'\n   */\n  _rtXdot->omega_CSTATE[2] = Sim_Multi_B.Product_l[2];\n\n  /* Derivatives for Iterator SubSystem: '<S94>/For Each Subsystem' */\n  for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n    /* Derivatives for Integrator: '<S118>/Integrator' */\n    _rtXdot->CoreSubsys_p[ForEach_itr].Integrator_CSTATE_e =\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Switch;\n\n    /* Derivatives for Integrator: '<S119>/Integrator' */\n    _rtXdot->CoreSubsys_p[ForEach_itr].Integrator_CSTATE_o =\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].Switch_a;\n  }\n\n  /* End of Derivatives for SubSystem: '<S94>/For Each Subsystem' */\n\n  /* Derivatives for Integrator: '<S58>/X_i' incorporates:\n   *  Product: '<S61>/Product'\n   */\n  _rtXdot->X_i_CSTATE[0] = Sim_Multi_B.Product[0];\n  _rtXdot->X_i_CSTATE[1] = Sim_Multi_B.Product[1];\n  _rtXdot->X_i_CSTATE[2] = Sim_Multi_B.Product[2];\n\n  /* End of Derivatives for SubSystem: '<Root>/multirotor' */\n\n  /* Derivatives for Integrator: '<S37>/Integrator' */\n  _rtXdot->Integrator_CSTATE = Sim_Multi_B.UniformRandomNumber;\n\n  /* Derivatives for Integrator: '<S38>/Integrator' */\n  _rtXdot->Integrator_CSTATE_f = Sim_Multi_B.UniformRandomNumber_n;\n}\n\n/* Model step function for TID2 */\nvoid Sim_Multi::step2()                /* Sample time: [0.002s, 0.0s] */\n{\n  /* local block i/o variables */\n  real_T rtb_Product[3];\n\n  /* local scratch DWork variables */\n  int32_T ForEach_itr_f;\n  real_T rtb_MatrixMultiply1[4];\n  real_T rtb_Product_c[3];\n  real_T rtb_Sum3_l[3];\n  real_T rtb_Switch1[3];\n  real_T rtb_Switch1_0[3];\n  real_T rtb_Switch1_1[3];\n  real_T RateTransition;\n  real_T RateTransition_Buffer_b;\n  real_T RateTransition_Buffer_b_0;\n  real_T RateTransition_Buffer_b_1;\n  real_T rtb_Throttlecommandthrustvalue;\n  real_T u1;\n  real_T u2;\n\n  /* RateTransition: '<S3>/Rate Transition' incorporates:\n   *  Constant: '<S30>/Throttle value'\n   */\n  Sim_Multi_B.RateTransition[3] = 299.9916292904752;\n\n  /* Sum: '<S10>/Sum4' incorporates:\n   *  Gain: '<S10>/Unit conversion [stick value] to [N]'\n   */\n  rtb_Throttlecommandthrustvalue = 0.017979360000000003 *\n    Sim_Multi_B.RateTransition[3];\n\n  /* Product: '<S11>/Product1' incorporates:\n   *  Constant: '<S2>/Constant7'\n   *  RateTransition: '<S4>/Rate Transition'\n   */\n  RateTransition_Buffer_b = Sim_Multi_DW.RateTransition_Buffer_b[5];\n  RateTransition_Buffer_b_0 = Sim_Multi_DW.RateTransition_Buffer_b[4];\n  RateTransition_Buffer_b_1 = Sim_Multi_DW.RateTransition_Buffer_b[6];\n  for (int32_T i{0}; i < 3; i++) {\n    /* RateTransition: '<S3>/Rate Transition' incorporates:\n     *  RateTransition: '<S30>/Rate Transition'\n     */\n    RateTransition = Sim_Multi_DW.RateTransition_Buffer[i];\n    Sim_Multi_B.RateTransition[i] = RateTransition;\n\n    /* Product: '<S11>/Product1' incorporates:\n     *  Constant: '<S2>/Constant7'\n     *  RateTransition: '<S4>/Rate Transition'\n     *  Switch: '<S11>/Switch1'\n     */\n    rtb_Switch1[i] = (Sim_Multi_ConstP.pooled11[i + 3] * RateTransition_Buffer_b\n                      + Sim_Multi_ConstP.pooled11[i] * RateTransition_Buffer_b_0)\n      + Sim_Multi_ConstP.pooled11[i + 6] * RateTransition_Buffer_b_1;\n\n    /* Gain: '<S10>/Unit conversion [stick value] to [rad//s]' */\n    RateTransition *= Sim_Multi_ConstP.Unitconversionstickvaluetorads_[i];\n\n    /* Saturate: '<S11>/Saturation' */\n    u1 = Sim_Multi_ConstP.Saturation_LowerSat[i];\n    u2 = Sim_Multi_ConstP.Saturation_UpperSat[i];\n    if (RateTransition > u2) {\n      rtb_Sum3_l[i] = u2;\n    } else if (RateTransition < u1) {\n      rtb_Sum3_l[i] = u1;\n    } else {\n      rtb_Sum3_l[i] = RateTransition;\n    }\n\n    /* End of Saturate: '<S11>/Saturation' */\n  }\n\n  /* Product: '<S13>/Product' */\n  RateTransition_Buffer_b = rtb_Sum3_l[1];\n  RateTransition_Buffer_b_0 = rtb_Sum3_l[0];\n  RateTransition_Buffer_b_1 = rtb_Sum3_l[2];\n\n  /* Sum: '<S11>/Sum3' incorporates:\n   *  RateTransition: '<S4>/Rate Transition'\n   */\n  rtb_Sum3_l[0] -= Sim_Multi_DW.RateTransition_Buffer_b[4];\n  rtb_Sum3_l[1] -= Sim_Multi_DW.RateTransition_Buffer_b[5];\n  rtb_Sum3_l[2] -= Sim_Multi_DW.RateTransition_Buffer_b[6];\n\n  /* Product: '<S14>/Product' incorporates:\n   *  Sum: '<S11>/Sum3'\n   */\n  RateTransition = rtb_Sum3_l[1];\n  u1 = rtb_Sum3_l[0];\n  u2 = rtb_Sum3_l[2];\n  for (int32_T i{0}; i < 3; i++) {\n    /* Product: '<S13>/Product' incorporates:\n     *  Product: '<S13>/Product1'\n     */\n    rtb_Product_c[i] = (Sim_Multi_ConstB.Product1[i + 3] *\n                        RateTransition_Buffer_b + Sim_Multi_ConstB.Product1[i] *\n                        RateTransition_Buffer_b_0) + Sim_Multi_ConstB.Product1[i\n      + 6] * RateTransition_Buffer_b_1;\n\n    /* Product: '<S14>/Product' incorporates:\n     *  Product: '<S14>/Product1'\n     *  Sum: '<S11>/Sum3'\n     */\n    rtb_Product[i] = (Sim_Multi_ConstB.Product1_i[i + 3] * RateTransition +\n                      Sim_Multi_ConstB.Product1_i[i] * u1) +\n      Sim_Multi_ConstB.Product1_i[i + 6] * u2;\n  }\n\n  /* Switch: '<S29>/Switch2' incorporates:\n   *  RelationalOperator: '<S29>/LowerRelop1'\n   *  RelationalOperator: '<S29>/UpperRelop'\n   *  Switch: '<S29>/Switch'\n   */\n  if (rtb_Throttlecommandthrustvalue > 16.181424000000003) {\n    rtb_Throttlecommandthrustvalue = 16.181424000000003;\n  } else if (rtb_Throttlecommandthrustvalue < 1.7979360000000004) {\n    /* Switch: '<S29>/Switch' */\n    rtb_Throttlecommandthrustvalue = 1.7979360000000004;\n  }\n\n  /* End of Switch: '<S29>/Switch2' */\n\n  /* Sum: '<S12>/Sum' incorporates:\n   *  Product: '<S16>/Product'\n   *  Product: '<S16>/Product1'\n   *  Product: '<S16>/Product2'\n   *  Product: '<S17>/Product'\n   *  Product: '<S17>/Product1'\n   *  Product: '<S17>/Product2'\n   *  RateTransition: '<S4>/Rate Transition'\n   */\n  rtb_Switch1_0[0] = rtb_Switch1[2] * Sim_Multi_DW.RateTransition_Buffer_b[5];\n  rtb_Switch1_0[1] = rtb_Switch1[0] * Sim_Multi_DW.RateTransition_Buffer_b[6];\n  rtb_Switch1_0[2] = rtb_Switch1[1] * Sim_Multi_DW.RateTransition_Buffer_b[4];\n  rtb_Switch1_1[0] = rtb_Switch1[1] * Sim_Multi_DW.RateTransition_Buffer_b[6];\n  rtb_Switch1_1[1] = rtb_Switch1[2] * Sim_Multi_DW.RateTransition_Buffer_b[4];\n  rtb_Switch1_1[2] = rtb_Switch1[0] * Sim_Multi_DW.RateTransition_Buffer_b[5];\n\n  /* Product: '<S15>/Product' incorporates:\n   *  Sum: '<S11>/Sum3'\n   */\n  RateTransition_Buffer_b = rtb_Sum3_l[1];\n  RateTransition_Buffer_b_0 = rtb_Sum3_l[0];\n  RateTransition_Buffer_b_1 = rtb_Sum3_l[2];\n  for (int32_T i{0}; i < 3; i++) {\n    /* Product: '<S8>/Matrix Multiply1' incorporates:\n     *  DiscreteIntegrator: '<S11>/Discrete-Time Integrator'\n     *  Product: '<S15>/Product'\n     *  Product: '<S15>/Product1'\n     *  Sum: '<S11>/Sum'\n     *  Sum: '<S11>/Sum1'\n     *  Sum: '<S11>/Sum2'\n     *  Sum: '<S11>/Sum3'\n     *  Sum: '<S12>/Sum'\n     */\n    rtb_MatrixMultiply1[i] = ((((Sim_Multi_ConstB.Product1_g[i + 3] *\n      RateTransition_Buffer_b + Sim_Multi_ConstB.Product1_g[i] *\n      RateTransition_Buffer_b_0) + Sim_Multi_ConstB.Product1_g[i + 6] *\n      RateTransition_Buffer_b_1) + Sim_Multi_DW.DiscreteTimeIntegrator_DSTATE[i])\n      - rtb_Product_c[i]) + (rtb_Switch1_0[i] - rtb_Switch1_1[i]);\n  }\n\n  /* Product: '<S8>/Matrix Multiply1' incorporates:\n   *  Constant: '<S8>/Constant1'\n   */\n  RateTransition_Buffer_b = rtb_MatrixMultiply1[1];\n  RateTransition_Buffer_b_0 = rtb_MatrixMultiply1[0];\n  RateTransition_Buffer_b_1 = rtb_MatrixMultiply1[2];\n  for (int32_T i{0}; i < 4; i++) {\n    /* Product: '<S8>/Matrix Multiply1' incorporates:\n     *  SignalConversion generated from: '<S8>/Matrix Multiply1'\n     */\n    rtb_MatrixMultiply1[i] = ((Sim_Multi_ConstP.Constant1_Value_n[i + 4] *\n      RateTransition_Buffer_b + Sim_Multi_ConstP.Constant1_Value_n[i] *\n      RateTransition_Buffer_b_0) + Sim_Multi_ConstP.Constant1_Value_n[i + 8] *\n      RateTransition_Buffer_b_1) + Sim_Multi_ConstP.Constant1_Value_n[i + 12] *\n      rtb_Throttlecommandthrustvalue;\n  }\n\n  /* Outputs for Iterator SubSystem: '<S7>/For Each Subsystem' incorporates:\n   *  ForEach: '<S24>/For Each'\n   */\n  for (ForEach_itr_f = 0; ForEach_itr_f < 4; ForEach_itr_f++) {\n    /* SignalConversion generated from: '<S25>/ SFunction ' incorporates:\n     *  Constant: '<S2>/Constant4'\n     *  ForEachSliceSelector generated from: '<S24>/MotorMatrix_nominal'\n     *  MATLAB Function: '<S24>/MATLAB Function'\n     */\n    rtb_Switch1[0] = Sim_Multi_ConstP.pooled10[ForEach_itr_f + 24];\n    rtb_Switch1[1] = Sim_Multi_ConstP.pooled10[ForEach_itr_f + 28];\n\n    /* MATLAB Function: '<S24>/MATLAB Function' incorporates:\n     *  SignalConversion generated from: '<S25>/ SFunction '\n     */\n    rtb_Throttlecommandthrustvalue = rtb_Switch1[0] / (2.0 * rtb_Switch1[1]);\n\n    /* Saturate: '<S24>/Saturation limit: no negative thrust' incorporates:\n     *  ForEachSliceSelector generated from: '<S24>/Thrust_cmds'\n     *  Product: '<S8>/Matrix Multiply1'\n     */\n    if (rtb_MatrixMultiply1[ForEach_itr_f] <= 0.0) {\n      RateTransition_Buffer_b = 0.0;\n    } else {\n      RateTransition_Buffer_b = rtb_MatrixMultiply1[ForEach_itr_f];\n    }\n\n    /* MATLAB Function: '<S24>/MATLAB Function' incorporates:\n     *  Saturate: '<S24>/Saturation limit: no negative thrust'\n     *  SignalConversion generated from: '<S25>/ SFunction '\n     */\n    rtb_Throttlecommandthrustvalue = -rtb_Switch1[0] / (2.0 * rtb_Switch1[1]) +\n      std::sqrt(rtb_Throttlecommandthrustvalue * rtb_Throttlecommandthrustvalue\n                + RateTransition_Buffer_b / rtb_Switch1[1]);\n\n    /* ForEachSliceSelector generated from: '<S24>/MotorMatrix_nominal' incorporates:\n     *  Constant: '<S2>/Constant4'\n     *  RelationalOperator: '<S26>/LowerRelop1'\n     *  Switch: '<S26>/Switch2'\n     */\n    RateTransition_Buffer_b = Sim_Multi_ConstP.pooled10[ForEach_itr_f + 44];\n\n    /* Switch: '<S26>/Switch2' incorporates:\n     *  Constant: '<S2>/Constant4'\n     *  ForEachSliceSelector generated from: '<S24>/MotorMatrix_nominal'\n     *  RelationalOperator: '<S26>/LowerRelop1'\n     */\n    if (rtb_Throttlecommandthrustvalue > RateTransition_Buffer_b) {\n      /* ForEachSliceAssignment generated from: '<S24>/RPM_cmd_sat' */\n      Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[ForEach_itr_f] =\n        RateTransition_Buffer_b;\n    } else {\n      /* RelationalOperator: '<S26>/UpperRelop' incorporates:\n       *  Switch: '<S26>/Switch'\n       */\n      RateTransition_Buffer_b = Sim_Multi_ConstP.pooled10[ForEach_itr_f + 40];\n\n      /* Switch: '<S26>/Switch' incorporates:\n       *  RelationalOperator: '<S26>/UpperRelop'\n       */\n      if (rtb_Throttlecommandthrustvalue < RateTransition_Buffer_b) {\n        /* ForEachSliceAssignment generated from: '<S24>/RPM_cmd_sat' */\n        Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[ForEach_itr_f] =\n          RateTransition_Buffer_b;\n      } else {\n        /* ForEachSliceAssignment generated from: '<S24>/RPM_cmd_sat' */\n        Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[ForEach_itr_f] =\n          rtb_Throttlecommandthrustvalue;\n      }\n    }\n  }\n\n  /* End of Outputs for SubSystem: '<S7>/For Each Subsystem' */\n\n  /* Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator' incorporates:\n   *  Product: '<S14>/Product'\n   */\n  Sim_Multi_DW.DiscreteTimeIntegrator_DSTATE[0] += 0.002 * rtb_Product[0];\n  Sim_Multi_DW.DiscreteTimeIntegrator_DSTATE[1] += 0.002 * rtb_Product[1];\n  Sim_Multi_DW.DiscreteTimeIntegrator_DSTATE[2] += 0.002 * rtb_Product[2];\n\n  /* Update for Atomic SubSystem: '<Root>/multirotor' */\n  /* Update for RateTransition: '<S5>/Rate Transition1' incorporates:\n   *  ForEachSliceAssignment generated from: '<S24>/RPM_cmd_sat'\n   */\n  Sim_Multi_DW.RateTransition1_Buffer0[0] =\n    Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[0];\n  Sim_Multi_DW.RateTransition1_Buffer0[1] =\n    Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[1];\n  Sim_Multi_DW.RateTransition1_Buffer0[2] =\n    Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[2];\n  Sim_Multi_DW.RateTransition1_Buffer0[3] =\n    Sim_Multi_B.ImpAsg_InsertedFor_RPM_cmd_sat_[3];\n\n  /* End of Update for SubSystem: '<Root>/multirotor' */\n}\n\n/* Model step function for TID3 */\nvoid Sim_Multi::step3()                /* Sample time: [0.01s, 0.0s] */\n{\n  /* (no output/update code required) */\n}\n\n/* Model step function for TID4 */\nvoid Sim_Multi::step4()                /* Sample time: [0.02s, 0.0s] */\n{\n  /* (no output/update code required) */\n}\n\n/* Model step function for TID5 */\nvoid Sim_Multi::step5()                /* Sample time: [0.03s, 0.0s] */\n{\n  /* (no output/update code required) */\n}\n\n/* Model initialize function */\nvoid Sim_Multi::initialize()\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* Set task counter limit used by the static main program */\n  ((&Sim_Multi_M))->Timing.TaskCounters.cLimit[0] = 1;\n  ((&Sim_Multi_M))->Timing.TaskCounters.cLimit[1] = 1;\n  ((&Sim_Multi_M))->Timing.TaskCounters.cLimit[2] = 2;\n  ((&Sim_Multi_M))->Timing.TaskCounters.cLimit[3] = 10;\n  ((&Sim_Multi_M))->Timing.TaskCounters.cLimit[4] = 20;\n  ((&Sim_Multi_M))->Timing.TaskCounters.cLimit[5] = 30;\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&(&Sim_Multi_M)->solverInfo, &(&Sim_Multi_M)\n                          ->Timing.simTimeStep);\n    rtsiSetTPtr(&(&Sim_Multi_M)->solverInfo, &rtmGetTPtr((&Sim_Multi_M)));\n    rtsiSetStepSizePtr(&(&Sim_Multi_M)->solverInfo, &(&Sim_Multi_M)\n                       ->Timing.stepSize0);\n    rtsiSetdXPtr(&(&Sim_Multi_M)->solverInfo, &(&Sim_Multi_M)->derivs);\n    rtsiSetContStatesPtr(&(&Sim_Multi_M)->solverInfo, (real_T **) &(&Sim_Multi_M)\n                         ->contStates);\n    rtsiSetNumContStatesPtr(&(&Sim_Multi_M)->solverInfo, &(&Sim_Multi_M)\n      ->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&(&Sim_Multi_M)->solverInfo, &(&Sim_Multi_M\n      )->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&(&Sim_Multi_M)->solverInfo,\n      &(&Sim_Multi_M)->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&(&Sim_Multi_M)->solverInfo,\n      &(&Sim_Multi_M)->periodicContStateRanges);\n    rtsiSetErrorStatusPtr(&(&Sim_Multi_M)->solverInfo, (&rtmGetErrorStatus\n      ((&Sim_Multi_M))));\n    rtsiSetRTModelPtr(&(&Sim_Multi_M)->solverInfo, (&Sim_Multi_M));\n  }\n\n  rtsiSetSimTimeStep(&(&Sim_Multi_M)->solverInfo, MAJOR_TIME_STEP);\n  (&Sim_Multi_M)->intgData.y = (&Sim_Multi_M)->odeY;\n  (&Sim_Multi_M)->intgData.f[0] = (&Sim_Multi_M)->odeF[0];\n  (&Sim_Multi_M)->intgData.f[1] = (&Sim_Multi_M)->odeF[1];\n  (&Sim_Multi_M)->intgData.f[2] = (&Sim_Multi_M)->odeF[2];\n  (&Sim_Multi_M)->contStates = ((X_Sim_Multi_T *) &Sim_Multi_X);\n  rtsiSetSolverData(&(&Sim_Multi_M)->solverInfo, static_cast<void *>\n                    (&(&Sim_Multi_M)->intgData));\n  rtsiSetIsMinorTimeStepWithModeChange(&(&Sim_Multi_M)->solverInfo, false);\n  rtsiSetSolverName(&(&Sim_Multi_M)->solverInfo,\"ode3\");\n  rtmSetTPtr((&Sim_Multi_M), &(&Sim_Multi_M)->Timing.tArray[0]);\n  (&Sim_Multi_M)->Timing.stepSize0 = 0.001;\n  rtmSetFirstInitCond((&Sim_Multi_M), 1);\n\n  {\n    /* local scratch DWork variables */\n    int32_T ForEach_itr;\n\n    /* Start for Atomic SubSystem: '<Root>/multirotor' */\n    /* Start for RateTransition: '<S5>/Rate Transition1' */\n    Sim_Multi_B.RateTransition1[0] = 3104.5025852;\n    Sim_Multi_B.RateTransition1[1] = 3104.5025852;\n    Sim_Multi_B.RateTransition1[2] = 3104.5025852;\n    Sim_Multi_B.RateTransition1[3] = 3104.5025852;\n\n    /* Start for Iterator SubSystem: '<S94>/For Each Subsystem' */\n    for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n      /* Start for If: '<S131>/If' */\n      Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem = -1;\n\n      /* Start for If: '<S143>/If' */\n      Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_l = -1;\n\n      /* Start for If: '<S145>/If' */\n      Sim_Multi_DW.CoreSubsys_p[ForEach_itr].If_ActiveSubsystem_g = -1;\n    }\n\n    /* End of Start for SubSystem: '<S94>/For Each Subsystem' */\n\n    /* Start for If: '<S95>/If' */\n    Sim_Multi_DW.If_ActiveSubsystem = -1;\n\n    /* End of Start for SubSystem: '<Root>/multirotor' */\n  }\n\n  {\n    /* local scratch DWork variables */\n    int32_T ForEach_itr;\n\n    /* InitializeConditions for TransferFcn: '<S31>/Transfer Fcn1' */\n    Sim_Multi_X.TransferFcn1_CSTATE = 0.0;\n\n    /* InitializeConditions for TransferFcn: '<S31>/Transfer Fcn6' */\n    Sim_Multi_X.TransferFcn6_CSTATE = 0.0;\n\n    /* InitializeConditions for TransferFcn: '<S31>/Transfer Fcn4' */\n    Sim_Multi_X.TransferFcn4_CSTATE = 0.0;\n\n    /* InitializeConditions for TransferFcn: '<S31>/Transfer Fcn5' */\n    Sim_Multi_X.TransferFcn5_CSTATE = 0.0;\n\n    /* InitializeConditions for TransferFcn: '<S31>/Transfer Fcn2' */\n    Sim_Multi_X.TransferFcn2_CSTATE = 0.0;\n\n    /* InitializeConditions for TransferFcn: '<S31>/Transfer Fcn3' */\n    Sim_Multi_X.TransferFcn3_CSTATE = 0.0;\n\n    /* InitializeConditions for Memory: '<S36>/Memory' */\n    Sim_Multi_DW.Memory_PreviousInput[0] = 1.0;\n    Sim_Multi_DW.Memory_PreviousInput[1] = 0.0;\n    Sim_Multi_DW.Memory_PreviousInput[2] = 0.0;\n    Sim_Multi_DW.Memory_PreviousInput[3] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S37>/Integrator' */\n    Sim_Multi_X.Integrator_CSTATE = 0.0;\n\n    /* InitializeConditions for UniformRandomNumber: '<S37>/Uniform Random Number' */\n    Sim_Multi_DW.RandSeed = 43057152U;\n    Sim_Multi_DW.UniformRandomNumber_NextOutput = rt_urand_Upu32_Yd_f_pw_snf\n      (&Sim_Multi_DW.RandSeed) * 0.002 - 0.001;\n\n    /* InitializeConditions for Integrator: '<S38>/Integrator' */\n    Sim_Multi_X.Integrator_CSTATE_f = 0.0;\n\n    /* InitializeConditions for UniformRandomNumber: '<S38>/Uniform Random Number' */\n    Sim_Multi_DW.RandSeed_b = 22151168U;\n    Sim_Multi_DW.UniformRandomNumber_NextOutpu_m = rt_urand_Upu32_Yd_f_pw_snf\n      (&Sim_Multi_DW.RandSeed_b) * 0.002 - 0.001;\n\n    /* SystemInitialize for Atomic SubSystem: '<Root>/multirotor' */\n    /* InitializeConditions for Integrator: '<S64>/Q-Integrator' */\n    if (rtmIsFirstInitCond((&Sim_Multi_M))) {\n      Sim_Multi_X.QIntegrator_CSTATE[0] = 0.0;\n      Sim_Multi_X.QIntegrator_CSTATE[1] = 0.0;\n      Sim_Multi_X.QIntegrator_CSTATE[2] = 0.0;\n      Sim_Multi_X.QIntegrator_CSTATE[3] = 0.0;\n    }\n\n    Sim_Multi_DW.QIntegrator_IWORK = 1;\n\n    /* End of InitializeConditions for Integrator: '<S64>/Q-Integrator' */\n\n    /* InitializeConditions for Integrator: '<S58>/V_b' */\n    Sim_Multi_X.V_b_CSTATE[0] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S58>/omega' */\n    Sim_Multi_X.omega_CSTATE[0] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S58>/V_b' */\n    Sim_Multi_X.V_b_CSTATE[1] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S58>/omega' */\n    Sim_Multi_X.omega_CSTATE[1] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S58>/V_b' */\n    Sim_Multi_X.V_b_CSTATE[2] = 0.0;\n\n    /* InitializeConditions for Integrator: '<S58>/omega' */\n    Sim_Multi_X.omega_CSTATE[2] = 0.0;\n\n    /* InitializeConditions for RateTransition: '<S5>/Rate Transition1' */\n    Sim_Multi_DW.RateTransition1_Buffer0[0] = 3104.5025852;\n    Sim_Multi_DW.RateTransition1_Buffer0[1] = 3104.5025852;\n    Sim_Multi_DW.RateTransition1_Buffer0[2] = 3104.5025852;\n    Sim_Multi_DW.RateTransition1_Buffer0[3] = 3104.5025852;\n\n    /* InitializeConditions for Integrator: '<S58>/X_i' */\n    Sim_Multi_X.X_i_CSTATE[0] = 0.0;\n\n    /* SystemInitialize for IfAction SubSystem: '<S95>/Zero airspeed' */\n    /* SystemInitialize for Merge: '<S95>/Merge' incorporates:\n     *  Outport: '<S98>/Drag force'\n     */\n    Sim_Multi_B.Forceagainstdirectionofmotiondu[0] = 0.0;\n\n    /* End of SystemInitialize for SubSystem: '<S95>/Zero airspeed' */\n\n    /* InitializeConditions for Integrator: '<S58>/X_i' */\n    Sim_Multi_X.X_i_CSTATE[1] = 0.0;\n\n    /* SystemInitialize for IfAction SubSystem: '<S95>/Zero airspeed' */\n    /* SystemInitialize for Merge: '<S95>/Merge' incorporates:\n     *  Outport: '<S98>/Drag force'\n     */\n    Sim_Multi_B.Forceagainstdirectionofmotiondu[1] = 0.0;\n\n    /* End of SystemInitialize for SubSystem: '<S95>/Zero airspeed' */\n\n    /* InitializeConditions for Integrator: '<S58>/X_i' */\n    Sim_Multi_X.X_i_CSTATE[2] = 0.0;\n\n    /* SystemInitialize for IfAction SubSystem: '<S95>/Zero airspeed' */\n    /* SystemInitialize for Merge: '<S95>/Merge' incorporates:\n     *  Outport: '<S98>/Drag force'\n     */\n    Sim_Multi_B.Forceagainstdirectionofmotiondu[2] = -1.0;\n\n    /* End of SystemInitialize for SubSystem: '<S95>/Zero airspeed' */\n\n    /* SystemInitialize for Iterator SubSystem: '<S94>/For Each Subsystem' */\n    for (ForEach_itr = 0; ForEach_itr < 4; ForEach_itr++) {\n      /* InitializeConditions for Integrator: '<S118>/Integrator' */\n      Sim_Multi_X.CoreSubsys_p[ForEach_itr].Integrator_CSTATE_e = 3104.5025852;\n\n      /* InitializeConditions for Integrator: '<S119>/Integrator' */\n      Sim_Multi_X.CoreSubsys_p[ForEach_itr].Integrator_CSTATE_o = 3104.5025852;\n\n      /* SystemInitialize for IfAction SubSystem: '<S131>/Zero airspeed in rotor plane' */\n      /* SystemInitialize for Merge: '<S131>/Merge' incorporates:\n       *  Outport: '<S138>/Thrust direction (Body)'\n       */\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[0] =\n        0.0;\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[1] =\n        0.0;\n      Sim_Multi_B.CoreSubsys_p[ForEach_itr].NewtiltedthrustdirectionBodyaxe[2] =\n        -1.0;\n\n      /* End of SystemInitialize for SubSystem: '<S131>/Zero airspeed in rotor plane' */\n    }\n\n    /* End of SystemInitialize for SubSystem: '<S94>/For Each Subsystem' */\n    /* End of SystemInitialize for SubSystem: '<Root>/multirotor' */\n\n    /* set \"at time zero\" to false */\n    if (rtmIsFirstInitCond((&Sim_Multi_M))) {\n      rtmSetFirstInitCond((&Sim_Multi_M), 0);\n    }\n  }\n}\n\n/* Model terminate function */\nvoid Sim_Multi::terminate()\n{\n  /* (no terminate code required) */\n}\n\n/* Constructor */\nSim_Multi::Sim_Multi() :\n  Sim_Multi_B(),\n  Sim_Multi_DW(),\n  Sim_Multi_X(),\n  Sim_Multi_M()\n{\n  /* Currently there is no constructor body generated.*/\n}\n\n/* Destructor */\n/* Currently there is no destructor body generated.*/\nSim_Multi::~Sim_Multi() = default;\n\n/* Real-Time Model get method */\nRT_MODEL_Sim_Multi_T * Sim_Multi::getRTM()\n{\n  return (&Sim_Multi_M);\n}\n"},{"name":"Sim_Multi.h","type":"header","group":"model","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Sim_Multi.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Sim_Multi_h_\n#define RTW_HEADER_Sim_Multi_h_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"Sim_Multi_types.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <cstring>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContStateDisabled\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\n#endif\n\n#ifndef rtmSetContStateDisabled\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\n#endif\n\n#ifndef rtmGetContStates\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\n#endif\n\n#ifndef rtmSetContStates\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\n#endif\n\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetIntgData\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\n#endif\n\n#ifndef rtmSetIntgData\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\n#endif\n\n#ifndef rtmGetOdeF\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\n#endif\n\n#ifndef rtmSetOdeF\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\n#endif\n\n#ifndef rtmGetOdeY\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\n#endif\n\n#ifndef rtmSetOdeY\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateIndices\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\n#endif\n\n#ifndef rtmSetPeriodicContStateIndices\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\n#endif\n\n#ifndef rtmGetPeriodicContStateRanges\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\n#endif\n\n#ifndef rtmSetPeriodicContStateRanges\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetdX\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\n#endif\n\n#ifndef rtmSetdX\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\n#endif\n\n#ifndef rtmCounterLimit\n#define rtmCounterLimit(rtm, idx)      ((rtm)->Timing.TaskCounters.cLimit[(idx)])\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmStepTask\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmTaskCounter\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\n#endif\n\n/* Block signals for system '<S94>/For Each Subsystem' */\nstruct B_CoreSubsys_Sim_Multi_c_T {\n  real_T Product;                      /* '<S114>/Product' */\n  real_T Switch;                       /* '<S118>/Switch' */\n  real_T Switch_a;                     /* '<S119>/Switch' */\n  real_T VectorfromrealCoGtopropellerBod[3];/* '<S116>/Subtract' */\n  real_T VectorConcatenate[9];         /* '<S169>/Vector Concatenate' */\n  real_T Product9[3];                  /* '<S136>/Product9' */\n  real_T Gain1;                        /* '<S156>/Gain1' */\n  real_T Angleofattackrad;             /* '<S143>/Merge' */\n  real_T Climbspeedv_c;                /* '<S144>/Gain' */\n  real_T NewtiltedthrustdirectionBodyaxe[3];/* '<S131>/Merge' */\n  real_T Momentinthemotorhubduetobending[3];/* '<S131>/Merge1' */\n};\n\n/* Block states (default storage) for system '<S94>/For Each Subsystem' */\nstruct DW_CoreSubsys_Sim_Multi_f_T {\n  int8_T If_ActiveSubsystem;           /* '<S131>/If' */\n  int8_T If_ActiveSubsystem_l;         /* '<S143>/If' */\n  int8_T If_ActiveSubsystem_g;         /* '<S145>/If' */\n};\n\n/* Continuous states for system '<S94>/For Each Subsystem' */\nstruct X_CoreSubsys_Sim_Multi_n_T {\n  real_T Integrator_CSTATE_e;          /* '<S118>/Integrator' */\n  real_T Integrator_CSTATE_o;          /* '<S119>/Integrator' */\n};\n\n/* State derivatives for system '<S94>/For Each Subsystem' */\nstruct XDot_CoreSubsys_Sim_Multi_n_T {\n  real_T Integrator_CSTATE_e;          /* '<S118>/Integrator' */\n  real_T Integrator_CSTATE_o;          /* '<S119>/Integrator' */\n};\n\n/* State Disabled for system '<S94>/For Each Subsystem' */\nstruct XDis_CoreSubsys_Sim_Multi_n_T {\n  boolean_T Integrator_CSTATE_e;       /* '<S118>/Integrator' */\n  boolean_T Integrator_CSTATE_o;       /* '<S119>/Integrator' */\n};\n\n/* Block signals (default storage) */\nstruct B_Sim_Multi_T {\n  real_T TransferFcn1;                 /* '<S31>/Transfer Fcn1' */\n  real_T TransferFcn6;                 /* '<S31>/Transfer Fcn6' */\n  real_T TransferFcn4;                 /* '<S31>/Transfer Fcn4' */\n  real_T TransferFcn5;                 /* '<S31>/Transfer Fcn5' */\n  real_T TransferFcn2;                 /* '<S31>/Transfer Fcn2' */\n  real_T TransferFcn3;                 /* '<S31>/Transfer Fcn3' */\n  real_T Gain2;                        /* '<S32>/Gain2' */\n  real_T Gain2_i;                      /* '<S33>/Gain2' */\n  real_T Gain2_g;                      /* '<S34>/Gain2' */\n  real_T omega[3];                     /* '<S35>/Sum' */\n  real_T a_b[3];                       /* '<S35>/Sum1' */\n  real_T UniformRandomNumber;          /* '<S37>/Uniform Random Number' */\n  real_T UniformRandomNumber_n;        /* '<S38>/Uniform Random Number' */\n  real_T Switch;                       /* '<S42>/Switch' */\n  real_T Divide[4];                    /* '<S41>/Divide' */\n  real_T Switch_j;                     /* '<S45>/Switch' */\n  real_T Switch1;                      /* '<S45>/Switch1' */\n  real_T Switch2;                      /* '<S45>/Switch2' */\n  real_T Sum1[3];                      /* '<S36>/Sum1' */\n  real_T Switch_jm;                    /* '<S44>/Switch' */\n  real_T Switch1_m;                    /* '<S44>/Switch1' */\n  real_T Switch2_m;                    /* '<S44>/Switch2' */\n  real_T Sum2[3];                      /* '<S36>/Sum2' */\n  real_T Switch_f;                     /* '<S43>/Switch' */\n  real_T Switch1_d;                    /* '<S43>/Switch1' */\n  real_T Switch2_n;                    /* '<S43>/Switch2' */\n  real_T Sum3[3];                      /* '<S36>/Sum3' */\n  real_T RateTransition[4];            /* '<S3>/Rate Transition' */\n  real_T Product[3];                   /* '<S61>/Product' */\n  real_T RateTransition1[4];           /* '<S5>/Rate Transition1' */\n  real_T Product_l[3];                 /* '<S63>/Product' */\n  real_T ForceofgravityInertialaxes[3];/* '<S93>/Product1' */\n  real_T TmpSignalConversionAtQIntegrato[4];\n  real_T Sum1_o[3];                    /* '<S58>/Sum1' */\n  real_T quat_output[4];               /* '<S64>/MATLAB Function' */\n  real_T ImpAsg_InsertedFor_RPM_cmd_sat_[4];/* '<S24>/Saturation Dynamic' */\n  real_T Forceagainstdirectionofmotiondu[3];/* '<S95>/Merge' */\n  B_CoreSubsys_Sim_Multi_c_T CoreSubsys_p[4];/* '<S94>/For Each Subsystem' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_Sim_Multi_T {\n  real_T DiscreteTimeIntegrator_DSTATE[3];/* '<S11>/Discrete-Time Integrator' */\n  real_T RateTransition_Buffer[3];     /* '<S30>/Rate Transition' */\n  real_T Memory_PreviousInput[4];      /* '<S36>/Memory' */\n  real_T Memory1_PreviousInput[3];     /* '<S36>/Memory1' */\n  real_T Memory2_PreviousInput[3];     /* '<S36>/Memory2' */\n  real_T Memory3_PreviousInput[3];     /* '<S36>/Memory3' */\n  real_T RateTransition_Buffer_b[19];  /* '<S4>/Rate Transition' */\n  real_T UniformRandomNumber_NextOutput;/* '<S37>/Uniform Random Number' */\n  real_T UniformRandomNumber_NextOutpu_m;/* '<S38>/Uniform Random Number' */\n  real_T RateTransition1_Buffer0[4];   /* '<S5>/Rate Transition1' */\n  uint32_T RandSeed;                   /* '<S37>/Uniform Random Number' */\n  uint32_T RandSeed_b;                 /* '<S38>/Uniform Random Number' */\n  int_T QIntegrator_IWORK;             /* '<S64>/Q-Integrator' */\n  int8_T If_ActiveSubsystem;           /* '<S95>/If' */\n  DW_CoreSubsys_Sim_Multi_f_T CoreSubsys_p[4];/* '<S94>/For Each Subsystem' */\n};\n\n/* Continuous states (default storage) */\nstruct X_Sim_Multi_T {\n  real_T TransferFcn1_CSTATE;          /* '<S31>/Transfer Fcn1' */\n  real_T TransferFcn6_CSTATE;          /* '<S31>/Transfer Fcn6' */\n  real_T TransferFcn4_CSTATE;          /* '<S31>/Transfer Fcn4' */\n  real_T TransferFcn5_CSTATE;          /* '<S31>/Transfer Fcn5' */\n  real_T TransferFcn2_CSTATE;          /* '<S31>/Transfer Fcn2' */\n  real_T TransferFcn3_CSTATE;          /* '<S31>/Transfer Fcn3' */\n  real_T Integrator_CSTATE;            /* '<S37>/Integrator' */\n  real_T Integrator_CSTATE_f;          /* '<S38>/Integrator' */\n  real_T QIntegrator_CSTATE[4];        /* '<S64>/Q-Integrator' */\n  real_T V_b_CSTATE[3];                /* '<S58>/V_b' */\n  real_T omega_CSTATE[3];              /* '<S58>/omega' */\n  real_T X_i_CSTATE[3];                /* '<S58>/X_i' */\n  X_CoreSubsys_Sim_Multi_n_T CoreSubsys_p[4];/* '<S112>/CoreSubsys' */\n};\n\n/* State derivatives (default storage) */\nstruct XDot_Sim_Multi_T {\n  real_T TransferFcn1_CSTATE;          /* '<S31>/Transfer Fcn1' */\n  real_T TransferFcn6_CSTATE;          /* '<S31>/Transfer Fcn6' */\n  real_T TransferFcn4_CSTATE;          /* '<S31>/Transfer Fcn4' */\n  real_T TransferFcn5_CSTATE;          /* '<S31>/Transfer Fcn5' */\n  real_T TransferFcn2_CSTATE;          /* '<S31>/Transfer Fcn2' */\n  real_T TransferFcn3_CSTATE;          /* '<S31>/Transfer Fcn3' */\n  real_T Integrator_CSTATE;            /* '<S37>/Integrator' */\n  real_T Integrator_CSTATE_f;          /* '<S38>/Integrator' */\n  real_T QIntegrator_CSTATE[4];        /* '<S64>/Q-Integrator' */\n  real_T V_b_CSTATE[3];                /* '<S58>/V_b' */\n  real_T omega_CSTATE[3];              /* '<S58>/omega' */\n  real_T X_i_CSTATE[3];                /* '<S58>/X_i' */\n  XDot_CoreSubsys_Sim_Multi_n_T CoreSubsys_p[4];/* '<S112>/CoreSubsys' */\n};\n\n/* State disabled  */\nstruct XDis_Sim_Multi_T {\n  boolean_T TransferFcn1_CSTATE;       /* '<S31>/Transfer Fcn1' */\n  boolean_T TransferFcn6_CSTATE;       /* '<S31>/Transfer Fcn6' */\n  boolean_T TransferFcn4_CSTATE;       /* '<S31>/Transfer Fcn4' */\n  boolean_T TransferFcn5_CSTATE;       /* '<S31>/Transfer Fcn5' */\n  boolean_T TransferFcn2_CSTATE;       /* '<S31>/Transfer Fcn2' */\n  boolean_T TransferFcn3_CSTATE;       /* '<S31>/Transfer Fcn3' */\n  boolean_T Integrator_CSTATE;         /* '<S37>/Integrator' */\n  boolean_T Integrator_CSTATE_f;       /* '<S38>/Integrator' */\n  boolean_T QIntegrator_CSTATE[4];     /* '<S64>/Q-Integrator' */\n  boolean_T V_b_CSTATE[3];             /* '<S58>/V_b' */\n  boolean_T omega_CSTATE[3];           /* '<S58>/omega' */\n  boolean_T X_i_CSTATE[3];             /* '<S58>/X_i' */\n  XDis_CoreSubsys_Sim_Multi_n_T CoreSubsys_p[4];/* '<S112>/CoreSubsys' */\n};\n\n/* Invariant block signals (default storage) */\nstruct ConstB_Sim_Multi_T {\n  real_T Product1[9];                  /* '<S13>/Product1' */\n  real_T Product1_i[9];                /* '<S14>/Product1' */\n  real_T Product1_g[9];                /* '<S15>/Product1' */\n};\n\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n/* ODE3 Integration Data */\nstruct ODE3_IntgData {\n  real_T *y;                           /* output */\n  real_T *f[3];                        /* derivatives */\n};\n\n#endif\n\n/* Constant parameters (default storage) */\nstruct ConstP_Sim_Multi_T {\n  /* Pooled Parameter (Mixed Expressions)\n   * Referenced by:\n   *   '<S2>/Constant4'\n   *   '<S59>/Constant'\n   */\n  real_T pooled10[68];\n\n  /* Pooled Parameter (Mixed Expressions)\n   * Referenced by:\n   *   '<S2>/Constant7'\n   *   '<S59>/Constant3'\n   */\n  real_T pooled11[9];\n\n  /* Expression: MotorMap\n   * Referenced by: '<S8>/Constant1'\n   */\n  real_T Constant1_Value_n[16];\n\n  /* Expression: MaxRate_cmd/500\n   * Referenced by: '<S10>/Unit conversion [stick value] to [rad//s]'\n   */\n  real_T Unitconversionstickvaluetorads_[3];\n\n  /* Expression: MaxRate_cmd\n   * Referenced by: '<S11>/Saturation'\n   */\n  real_T Saturation_UpperSat[3];\n\n  /* Expression: -MaxRate_cmd\n   * Referenced by: '<S11>/Saturation'\n   */\n  real_T Saturation_LowerSat[3];\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_Sim_Multi_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n  X_Sim_Multi_T *contStates;\n  int_T *periodicContStateIndices;\n  real_T *periodicContStateRanges;\n  real_T *derivs;\n  XDis_Sim_Multi_T *contStateDisabled;\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n  real_T odeY[29];\n  real_T odeF[3][29];\n  ODE3_IntgData intgData;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    int_T numContStates;\n    int_T numPeriodicContStates;\n    int_T numSampTimes;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    boolean_T firstInitCondFlag;\n    struct {\n      uint8_T TID[6];\n      uint8_T cLimit[6];\n    } TaskCounters;\n\n    struct {\n      uint8_T TID1_2;\n    } RateInteraction;\n\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[6];\n  } Timing;\n};\n\nextern const ConstB_Sim_Multi_T Sim_Multi_ConstB;/* constant block i/o */\n\n/* Constant parameters (default storage) */\nextern const ConstP_Sim_Multi_T Sim_Multi_ConstP;\n\n/* Class declaration for model Sim_Multi */\nclass Sim_Multi final\n{\n  /* public data and function members */\n public:\n  /* Copy Constructor */\n  Sim_Multi(Sim_Multi const&) = delete;\n\n  /* Assignment Operator */\n  Sim_Multi& operator= (Sim_Multi const&) & = delete;\n\n  /* Move Constructor */\n  Sim_Multi(Sim_Multi &&) = delete;\n\n  /* Move Assignment Operator */\n  Sim_Multi& operator= (Sim_Multi &&) = delete;\n\n  /* Real-Time Model get method */\n  RT_MODEL_Sim_Multi_T * getRTM();\n\n  /* model start function */\n  void start();\n\n  /* Initial conditions function */\n  void initialize();\n\n  /* model step function */\n  void step0();\n\n  /* model step function */\n  void step2();\n\n  /* model step function */\n  void step3();\n\n  /* model step function */\n  void step4();\n\n  /* model step function */\n  void step5();\n\n  /* model terminate function */\n  static void terminate();\n\n  /* Constructor */\n  Sim_Multi();\n\n  /* Destructor */\n  ~Sim_Multi();\n\n  /* private data and function members */\n private:\n  /* Block signals */\n  B_Sim_Multi_T Sim_Multi_B;\n\n  /* Block states */\n  DW_Sim_Multi_T Sim_Multi_DW;\n\n  /* Block continuous states */\n  X_Sim_Multi_T Sim_Multi_X;\n\n  /* Continuous states update member function*/\n  void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si );\n\n  /* Derivatives member function */\n  void Sim_Multi_derivatives();\n\n  /* Real-Time Model */\n  RT_MODEL_Sim_Multi_T Sim_Multi_M;\n};\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<S26>/Data Type Duplicate' : Unused code path elimination\n * Block '<S26>/Data Type Propagation' : Unused code path elimination\n * Block '<S29>/Data Type Duplicate' : Unused code path elimination\n * Block '<S29>/Data Type Propagation' : Unused code path elimination\n * Block '<S2>/Constant' : Unused code path elimination\n * Block '<S2>/Constant1' : Unused code path elimination\n * Block '<S2>/Constant2' : Unused code path elimination\n * Block '<S2>/Constant3' : Unused code path elimination\n * Block '<S2>/Constant5' : Unused code path elimination\n * Block '<S2>/Constant6' : Unused code path elimination\n * Block '<S2>/Disturbance (forces)' : Unused code path elimination\n * Block '<S2>/Disturbance (torques)' : Unused code path elimination\n * Block '<S2>/Surface area params' : Unused code path elimination\n * Block '<S2>/Wind vector' : Unused code path elimination\n * Block '<S35>/Noisy acc' : Unused code path elimination\n * Block '<S35>/Noisy omega' : Unused code path elimination\n * Block '<S36>/Noisy Vb' : Unused code path elimination\n * Block '<S36>/Noisy Vi' : Unused code path elimination\n * Block '<S36>/Noisy Xi' : Unused code path elimination\n * Block '<S36>/Noisy quat' : Unused code path elimination\n * Block '<S62>/Math Function2' : Unused code path elimination\n * Block '<S62>/Product' : Unused code path elimination\n * Block '<S62>/Reshape' : Unused code path elimination\n * Block '<S62>/Reshape1' : Unused code path elimination\n * Block '<S65>/Reshape' : Unused code path elimination\n * Block '<S59>/Constant4' : Unused code path elimination\n * Block '<S59>/Constant5' : Unused code path elimination\n * Block '<S59>/Constant6' : Unused code path elimination\n * Block '<S59>/Constant7' : Unused code path elimination\n * Block '<S122>/Data Type Duplicate' : Unused code path elimination\n * Block '<S122>/Data Type Propagation' : Unused code path elimination\n * Block '<S125>/Data Type Duplicate' : Unused code path elimination\n * Block '<S125>/Data Type Propagation' : Unused code path elimination\n * Block '<S125>/LowerRelop1' : Unused code path elimination\n * Block '<S125>/Switch' : Unused code path elimination\n * Block '<S125>/Switch2' : Unused code path elimination\n * Block '<S125>/UpperRelop' : Unused code path elimination\n * Block '<S94>/Reshape' : Unused code path elimination\n * Block '<S19>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S21>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S23>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S7>/Rate Transition' : Eliminated since input and output rates are identical\n * Block '<S8>/Rate Transition' : Eliminated since input and output rates are identical\n * Block '<S1>/Reshape' : Reshape block reduction\n * Block '<S32>/Gain' : Eliminated nontunable gain of 1\n * Block '<S32>/Manual Switch' : Eliminated due to constant selection input\n * Block '<S32>/Manual Switch1' : Eliminated due to constant selection input\n * Block '<S33>/Manual Switch' : Eliminated due to constant selection input\n * Block '<S33>/Manual Switch1' : Eliminated due to constant selection input\n * Block '<S34>/Manual Switch' : Eliminated due to constant selection input\n * Block '<S34>/Manual Switch1' : Eliminated due to constant selection input\n * Block '<S35>/Gain' : Eliminated nontunable gain of 1\n * Block '<S35>/Gain1' : Eliminated nontunable gain of 1\n * Block '<S47>/Reshape' : Reshape block reduction\n * Block '<S47>/Reshape1' : Reshape block reduction\n * Block '<S61>/Reshape' : Reshape block reduction\n * Block '<S61>/Reshape1' : Reshape block reduction\n * Block '<S63>/Reshape' : Reshape block reduction\n * Block '<S63>/Reshape ' : Reshape block reduction\n * Block '<S69>/Reshape' : Reshape block reduction\n * Block '<S69>/Reshape1' : Reshape block reduction\n * Block '<S73>/Reshape' : Reshape block reduction\n * Block '<S73>/Reshape1' : Reshape block reduction\n * Block '<S79>/Reshape' : Reshape block reduction\n * Block '<S79>/Reshape1' : Reshape block reduction\n * Block '<S89>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S104>/Reshape' : Reshape block reduction\n * Block '<S104>/Reshape1' : Reshape block reduction\n * Block '<S108>/Reshape' : Reshape block reduction\n * Block '<S108>/Reshape1' : Reshape block reduction\n * Block '<S109>/Reshape' : Reshape block reduction\n * Block '<S109>/Reshape1' : Reshape block reduction\n * Block '<S110>/Reshape' : Reshape block reduction\n * Block '<S110>/Reshape1' : Reshape block reduction\n * Block '<S111>/Reshape' : Reshape block reduction\n * Block '<S111>/Reshape1' : Reshape block reduction\n * Block '<S96>/Reshape' : Reshape block reduction\n * Block '<S93>/Reshape' : Reshape block reduction\n * Block '<S115>/Reshape' : Reshape block reduction\n * Block '<S116>/Reshape1' : Reshape block reduction\n * Block '<S112>/Rate Transition' : Eliminated since input and output rates are identical\n * Block '<S137>/Reshape3' : Reshape block reduction\n * Block '<S141>/Reshape' : Reshape block reduction\n * Block '<S141>/Reshape1' : Reshape block reduction\n * Block '<S142>/Reshape' : Reshape block reduction\n * Block '<S142>/Reshape1' : Reshape block reduction\n * Block '<S150>/Reshape' : Reshape block reduction\n * Block '<S150>/Reshape1' : Reshape block reduction\n * Block '<S151>/Reshape' : Reshape block reduction\n * Block '<S151>/Reshape1' : Reshape block reduction\n * Block '<S133>/Reshape1' : Reshape block reduction\n * Block '<S133>/Reshape2' : Reshape block reduction\n * Block '<S136>/Reshape5' : Reshape block reduction\n * Block '<S169>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S117>/Reshape' : Reshape block reduction\n * Block '<S172>/Reshape' : Reshape block reduction\n * Block '<S172>/Reshape1' : Reshape block reduction\n * Block '<S113>/Reshape' : Reshape block reduction\n * Block '<S11>/Constant2' : Unused code path elimination\n * Block '<S11>/Constant3' : Unused code path elimination\n * Block '<S32>/Add1' : Unused code path elimination\n * Block '<S32>/Constant' : Unused code path elimination\n * Block '<S32>/Step3' : Unused code path elimination\n * Block '<S32>/Step4' : Unused code path elimination\n * Block '<S32>/Step5' : Unused code path elimination\n * Block '<S33>/Constant' : Unused code path elimination\n * Block '<S33>/Step3' : Unused code path elimination\n * Block '<S34>/Add1' : Unused code path elimination\n * Block '<S34>/Add2' : Unused code path elimination\n * Block '<S34>/Gain' : Unused code path elimination\n * Block '<S34>/Gain1' : Unused code path elimination\n * Block '<S34>/Step1' : Unused code path elimination\n * Block '<S34>/Step2' : Unused code path elimination\n * Block '<S34>/Step3' : Unused code path elimination\n * Block '<S34>/Step6' : Unused code path elimination\n * Block '<S34>/Step7' : Unused code path elimination\n * Block '<S34>/Step8' : Unused code path elimination\n * Block '<S39>/Output' : Unused code path elimination\n * Block '<S39>/White Noise' : Unused code path elimination\n * Block '<S37>/Constant' : Unused code path elimination\n * Block '<S37>/Gain1' : Unused code path elimination\n * Block '<S37>/Gain2' : Unused code path elimination\n * Block '<S37>/Sum1' : Unused code path elimination\n * Block '<S40>/Output' : Unused code path elimination\n * Block '<S40>/White Noise' : Unused code path elimination\n * Block '<S38>/Constant' : Unused code path elimination\n * Block '<S38>/Gain1' : Unused code path elimination\n * Block '<S38>/Gain2' : Unused code path elimination\n * Block '<S38>/Sum1' : Unused code path elimination\n * Block '<S48>/Output' : Unused code path elimination\n * Block '<S48>/White Noise' : Unused code path elimination\n * Block '<S42>/Constant' : Unused code path elimination\n * Block '<S42>/Gain2' : Unused code path elimination\n * Block '<S42>/Rate Transition1' : Unused code path elimination\n * Block '<S49>/Output' : Unused code path elimination\n * Block '<S49>/White Noise' : Unused code path elimination\n * Block '<S50>/Output' : Unused code path elimination\n * Block '<S50>/White Noise' : Unused code path elimination\n * Block '<S51>/Output' : Unused code path elimination\n * Block '<S51>/White Noise' : Unused code path elimination\n * Block '<S43>/Constant' : Unused code path elimination\n * Block '<S43>/Constant2' : Unused code path elimination\n * Block '<S43>/Constant4' : Unused code path elimination\n * Block '<S43>/Gain1' : Unused code path elimination\n * Block '<S43>/Gain2' : Unused code path elimination\n * Block '<S43>/Gain3' : Unused code path elimination\n * Block '<S43>/Rate Transition' : Unused code path elimination\n * Block '<S43>/Rate Transition1' : Unused code path elimination\n * Block '<S43>/Rate Transition2' : Unused code path elimination\n * Block '<S52>/Output' : Unused code path elimination\n * Block '<S52>/White Noise' : Unused code path elimination\n * Block '<S53>/Output' : Unused code path elimination\n * Block '<S53>/White Noise' : Unused code path elimination\n * Block '<S54>/Output' : Unused code path elimination\n * Block '<S54>/White Noise' : Unused code path elimination\n * Block '<S44>/Constant' : Unused code path elimination\n * Block '<S44>/Constant2' : Unused code path elimination\n * Block '<S44>/Constant4' : Unused code path elimination\n * Block '<S44>/Gain1' : Unused code path elimination\n * Block '<S44>/Gain2' : Unused code path elimination\n * Block '<S44>/Gain3' : Unused code path elimination\n * Block '<S44>/Rate Transition' : Unused code path elimination\n * Block '<S44>/Rate Transition1' : Unused code path elimination\n * Block '<S44>/Rate Transition2' : Unused code path elimination\n * Block '<S55>/Output' : Unused code path elimination\n * Block '<S55>/White Noise' : Unused code path elimination\n * Block '<S56>/Output' : Unused code path elimination\n * Block '<S56>/White Noise' : Unused code path elimination\n * Block '<S57>/Output' : Unused code path elimination\n * Block '<S57>/White Noise' : Unused code path elimination\n * Block '<S45>/Constant' : Unused code path elimination\n * Block '<S45>/Constant2' : Unused code path elimination\n * Block '<S45>/Constant4' : Unused code path elimination\n * Block '<S45>/Gain1' : Unused code path elimination\n * Block '<S45>/Gain2' : Unused code path elimination\n * Block '<S45>/Gain3' : Unused code path elimination\n * Block '<S45>/Rate Transition' : Unused code path elimination\n * Block '<S45>/Rate Transition1' : Unused code path elimination\n * Block '<S45>/Rate Transition2' : Unused code path elimination\n * Block '<S132>/Constant1' : Unused code path elimination\n * Block '<S132>/Divide' : Unused code path elimination\n * Block '<S132>/Product2' : Unused code path elimination\n * Block '<S132>/Sum2' : Unused code path elimination\n * Block '<S132>/Trigonometric Function' : Unused code path elimination\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'Sim_Multi'\n * '<S1>'   : 'Sim_Multi/Controller'\n * '<S2>'   : 'Sim_Multi/Disturbances & Dynamic Events'\n * '<S3>'   : 'Sim_Multi/Radio commands'\n * '<S4>'   : 'Sim_Multi/State Estimation, Sensors, Noise'\n * '<S5>'   : 'Sim_Multi/multirotor'\n * '<S6>'   : 'Sim_Multi/Controller/Controller Structure'\n * '<S7>'   : 'Sim_Multi/Controller/Mapping thrust to rpm and saturation'\n * '<S8>'   : 'Sim_Multi/Controller/Motor mapping'\n * '<S9>'   : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only'\n * '<S10>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/Conversion stick values to rate commands'\n * '<S11>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller'\n * '<S12>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Cross Product'\n * '<S13>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Kff'\n * '<S14>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Ki'\n * '<S15>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Kp'\n * '<S16>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Cross Product/Subsystem'\n * '<S17>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Cross Product/Subsystem1'\n * '<S18>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Kff/Create diagonal 3x3 matrix'\n * '<S19>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Kff/Create diagonal 3x3 matrix/Subsystem9'\n * '<S20>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Ki/Create diagonal 3x3 matrix'\n * '<S21>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Ki/Create diagonal 3x3 matrix/Subsystem9'\n * '<S22>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Kp/Create diagonal 3x3 matrix'\n * '<S23>'  : 'Sim_Multi/Controller/Controller Structure/Inner-loop control only/PI Rate controller/Gain Kp/Create diagonal 3x3 matrix/Subsystem9'\n * '<S24>'  : 'Sim_Multi/Controller/Mapping thrust to rpm and saturation/For Each Subsystem'\n * '<S25>'  : 'Sim_Multi/Controller/Mapping thrust to rpm and saturation/For Each Subsystem/MATLAB Function'\n * '<S26>'  : 'Sim_Multi/Controller/Mapping thrust to rpm and saturation/For Each Subsystem/Saturation Dynamic'\n * '<S27>'  : 'Sim_Multi/Controller/Motor mapping/Max thrust limit'\n * '<S28>'  : 'Sim_Multi/Controller/Motor mapping/Min thrust limit'\n * '<S29>'  : 'Sim_Multi/Controller/Motor mapping/Saturation Dynamic'\n * '<S30>'  : 'Sim_Multi/Radio commands/Rate commands'\n * '<S31>'  : 'Sim_Multi/Radio commands/Rate commands/Filter'\n * '<S32>'  : 'Sim_Multi/Radio commands/Rate commands/Pitch rate signal'\n * '<S33>'  : 'Sim_Multi/Radio commands/Rate commands/Roll rate signal'\n * '<S34>'  : 'Sim_Multi/Radio commands/Rate commands/Yaw rate signal'\n * '<S35>'  : 'Sim_Multi/State Estimation, Sensors, Noise/Sensor models'\n * '<S36>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation'\n * '<S37>'  : 'Sim_Multi/State Estimation, Sensors, Noise/Sensor models/Acc noise'\n * '<S38>'  : 'Sim_Multi/State Estimation, Sensors, Noise/Sensor models/Gyro noise'\n * '<S39>'  : 'Sim_Multi/State Estimation, Sensors, Noise/Sensor models/Acc noise/Band-Limited White Noise'\n * '<S40>'  : 'Sim_Multi/State Estimation, Sensors, Noise/Sensor models/Gyro noise/Band-Limited White Noise'\n * '<S41>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Normalize'\n * '<S42>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Quat noise'\n * '<S43>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vb noise'\n * '<S44>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vi noise'\n * '<S45>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Xi noise'\n * '<S46>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Normalize/norm'\n * '<S47>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Normalize/norm/dot_product'\n * '<S48>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Quat noise/Band-Limited White Noise'\n * '<S49>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vb noise/Band-Limited White Noise'\n * '<S50>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vb noise/Band-Limited White Noise1'\n * '<S51>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vb noise/Band-Limited White Noise2'\n * '<S52>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vi noise/Band-Limited White Noise'\n * '<S53>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vi noise/Band-Limited White Noise1'\n * '<S54>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Vi noise/Band-Limited White Noise2'\n * '<S55>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Xi noise/Band-Limited White Noise'\n * '<S56>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Xi noise/Band-Limited White Noise1'\n * '<S57>'  : 'Sim_Multi/State Estimation, Sensors, Noise/State estimation/Xi noise/Band-Limited White Noise2'\n * '<S58>'  : 'Sim_Multi/multirotor/6DOF model'\n * '<S59>'  : 'Sim_Multi/multirotor/Disturbances & Dynamic Events'\n * '<S60>'  : 'Sim_Multi/multirotor/Force//Moment computation'\n * '<S61>'  : 'Sim_Multi/multirotor/6DOF model/Body to Inertial'\n * '<S62>'  : 'Sim_Multi/multirotor/6DOF model/Body to Inertial1'\n * '<S63>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot'\n * '<S64>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq.'\n * '<S65>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Euler'\n * '<S66>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix'\n * '<S67>'  : 'Sim_Multi/multirotor/6DOF model/omega x V_b'\n * '<S68>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Cross Product omega x (J * omega)'\n * '<S69>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Subsystem'\n * '<S70>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Cross Product omega x (J * omega)/Subsystem'\n * '<S71>'  : 'Sim_Multi/multirotor/6DOF model/Calculate omega_dot/Cross Product omega x (J * omega)/Subsystem1'\n * '<S72>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Cross Product'\n * '<S73>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Dot product'\n * '<S74>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./MATLAB Function'\n * '<S75>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Normalize'\n * '<S76>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Cross Product/Subsystem'\n * '<S77>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Cross Product/Subsystem1'\n * '<S78>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Normalize/norm'\n * '<S79>'  : 'Sim_Multi/multirotor/6DOF model/Quat Strapdown Eq./Normalize/norm/dot_product'\n * '<S80>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem'\n * '<S81>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem1'\n * '<S82>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem2'\n * '<S83>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem3'\n * '<S84>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem4'\n * '<S85>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem5'\n * '<S86>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem6'\n * '<S87>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem7'\n * '<S88>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem8'\n * '<S89>'  : 'Sim_Multi/multirotor/6DOF model/Quat to Rotation Matrix/Subsystem9'\n * '<S90>'  : 'Sim_Multi/multirotor/6DOF model/omega x V_b/Subsystem'\n * '<S91>'  : 'Sim_Multi/multirotor/6DOF model/omega x V_b/Subsystem1'\n * '<S92>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes'\n * '<S93>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute force of gravity in Body axes'\n * '<S94>'  : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers'\n * '<S95>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force'\n * '<S96>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Total airspeed (Body axes)'\n * '<S97>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed'\n * '<S98>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Zero airspeed'\n * '<S99>'  : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/norm'\n * '<S100>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Normalize'\n * '<S101>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation'\n * '<S102>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/u^2'\n * '<S103>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Normalize/norm'\n * '<S104>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Normalize/norm/dot_product'\n * '<S105>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Scaling factor computation'\n * '<S106>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Surface area computation'\n * '<S107>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Surface area computation/norm'\n * '<S108>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/Surface area computation/Surface area computation/norm/dot_product'\n * '<S109>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/Nonzero airspeed/u^2/dot_product'\n * '<S110>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Aerodynamic drag force/norm/dot_product'\n * '<S111>' : 'Sim_Multi/multirotor/Force//Moment computation/Compute aerodynamic drag of the airframe in Body axes/Total airspeed (Body axes)/Inertial to Body'\n * '<S112>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem'\n * '<S113>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/Total airspeed (Body axes)'\n * '<S114>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics'\n * '<S115>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Cross Product'\n * '<S116>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Leverarm vector from real CoG to each propeller (Body axes)'\n * '<S117>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)'\n * '<S118>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits'\n * '<S119>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1'\n * '<S120>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits/Compare To Zero'\n * '<S121>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits/Compare To Zero1'\n * '<S122>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits/Saturation Dynamic'\n * '<S123>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1/Compare To Zero'\n * '<S124>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1/Compare To Zero1'\n * '<S125>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Actuator dynamics/Continuous Integrator with dynamic upper//lower limits1/Saturation Dynamic'\n * '<S126>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Cross Product/Subsystem'\n * '<S127>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Cross Product/Subsystem1'\n * '<S128>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments'\n * '<S129>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes'\n * '<S130>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Cross Product'\n * '<S131>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations'\n * '<S132>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio'\n * '<S133>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque'\n * '<S134>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Hover moment magnitude'\n * '<S135>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Hover thrust magnitude'\n * '<S136>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Thrust direction in Body axes (without blade flapping)'\n * '<S137>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Nonzero airspeed in rotor plane'\n * '<S138>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Zero airspeed in rotor plane'\n * '<S139>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/norm'\n * '<S140>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Nonzero airspeed in rotor plane/norm'\n * '<S141>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/Nonzero airspeed in rotor plane/norm/dot_product'\n * '<S142>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Blade flapping computations/norm/dot_product'\n * '<S143>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude'\n * '<S144>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Compute the climb speed'\n * '<S145>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller'\n * '<S146>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Nonzero airspeed'\n * '<S147>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Zero airspeed'\n * '<S148>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/norm2'\n * '<S149>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Nonzero airspeed/norm1'\n * '<S150>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/Nonzero airspeed/norm1/dot_product'\n * '<S151>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Angle of attack and airspeed magnitude/norm2/dot_product'\n * '<S152>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller/Normal working state vc//vh >= 0'\n * '<S153>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller/Vortex ring state -2 <= vc//vh < 0 '\n * '<S154>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Dynamic thrust ratio/Flight modes of the propeller/Windmill braking state vc//vh < -2'\n * '<S155>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Cross Product'\n * '<S156>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Propeller moment of inertia'\n * '<S157>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Cross Product/Subsystem'\n * '<S158>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Compute dynamic motor thrust and moments/Gyroscopic torque/Cross Product/Subsystem1'\n * '<S159>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor'\n * '<S160>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem'\n * '<S161>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem1'\n * '<S162>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem2'\n * '<S163>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem3'\n * '<S164>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem4'\n * '<S165>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem5'\n * '<S166>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem6'\n * '<S167>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem7'\n * '<S168>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem8'\n * '<S169>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Coordinate transformation Body to Motor axes/Rotation Matrix Body to Motor/Subsystem9'\n * '<S170>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Cross Product/Subsystem'\n * '<S171>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/For Each Subsystem/Thrust//moment vector for each propeller (Body axes)/Cross Product/Subsystem1'\n * '<S172>' : 'Sim_Multi/multirotor/Force//Moment computation/Forces and moments generated by spinning propellers/Total airspeed (Body axes)/Inertial to Body'\n */\n#endif                                 /* RTW_HEADER_Sim_Multi_h_ */\n"},{"name":"Sim_Multi_private.h","type":"header","group":"model","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Sim_Multi_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Sim_Multi_private_h_\n#define RTW_HEADER_Sim_Multi_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"Sim_Multi_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmSetFirstInitCond\n#define rtmSetFirstInitCond(rtm, val)  ((rtm)->Timing.firstInitCondFlag = (val))\n#endif\n\n#ifndef rtmIsFirstInitCond\n#define rtmIsFirstInitCond(rtm)        ((rtm)->Timing.firstInitCondFlag)\n#endif\n\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);\nextern void rt_mldivide_U1d3x3_U2d_JBYZyA3A(const real_T u0[9], const real_T u1\n  [3], real_T y[3]);\n\n/* private model entry point functions */\nextern void Sim_Multi_derivatives();\n\n#endif                                 /* RTW_HEADER_Sim_Multi_private_h_ */\n"},{"name":"Sim_Multi_types.h","type":"header","group":"model","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Sim_Multi_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Sim_Multi_types_h_\n#define RTW_HEADER_Sim_Multi_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_Sim_Multi_T RT_MODEL_Sim_Multi_T;\n\n#endif                                 /* RTW_HEADER_Sim_Multi_types_h_ */\n"},{"name":"Sim_Multi_data.cpp","type":"source","group":"data","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Sim_Multi_data.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"Sim_Multi.h\"\n\n/* Invariant block signals (default storage) */\nconst ConstB_Sim_Multi_T Sim_Multi_ConstB{\n  {\n    0.0027719999999999997,\n    0.0,\n    0.0,\n    0.0,\n    0.0026915,\n    0.0,\n    0.0,\n    0.0,\n    0.0048877499999999989\n  }\n  ,                                    /* '<S13>/Product1' */\n\n  {\n    0.039599999999999996,\n    0.0,\n    0.0,\n    0.0,\n    0.03845,\n    0.0,\n    0.0,\n    0.0,\n    0.11025\n  }\n  ,                                    /* '<S14>/Product1' */\n\n  {\n    0.0594,\n    0.0,\n    0.0,\n    0.0,\n    0.057675,\n    0.0,\n    0.0,\n    0.0,\n    0.165375\n  }\n  /* '<S15>/Product1' */\n};\n\n/* Constant parameters (default storage) */\nconst ConstP_Sim_Multi_T Sim_Multi_ConstP{\n  /* Pooled Parameter (Mixed Expressions)\n   * Referenced by:\n   *   '<S2>/Constant4'\n   *   '<S59>/Constant'\n   */\n  { 45.0, 135.0, 225.0, 315.0, 0.17, 0.17, 0.17, 0.17, -0.028, -0.028, -0.028,\n    -0.028, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.01, 0.01, 0.01, 0.01,\n    9.6820000000000012E-5, 9.6820000000000012E-5, 9.6820000000000012E-5,\n    9.6820000000000012E-5, 1.0872000000000001E-7, 1.0872000000000001E-7,\n    1.0872000000000001E-7, 1.0872000000000001E-7, 1.4504E-6, 1.4504E-6,\n    1.4504E-6, 1.4504E-6, 1.6312E-9, 1.6312E-9, 1.6312E-9, 1.6312E-9, 0.0, 0.0,\n    0.0, 0.0, 6000.0, 6000.0, 6000.0, 6000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.2032, 0.2032, 0.2032, 0.2032, 0.011, 0.011, 0.011,\n    0.011 },\n\n  /* Pooled Parameter (Mixed Expressions)\n   * Referenced by:\n   *   '<S2>/Constant7'\n   *   '<S59>/Constant3'\n   */\n  { 0.00396, 0.0, 0.0, 0.0, 0.003845, 0.0, 0.0, 0.0, 0.00735 },\n\n  /* Expression: MotorMap\n   * Referenced by: '<S8>/Constant1'\n   */\n  { -2.0797258270192569, -2.0797258270192569, 2.0797258270192569,\n    2.0797258270192573, 2.0797258270192578, -2.0797258270192573,\n    -2.0797258270192582, 2.0797258270192569, 16.666666666666664,\n    -16.666666666666664, 16.666666666666664, -16.666666666666664, 0.25,\n    0.24999999999999997, 0.24999999999999997, 0.25 },\n\n  /* Expression: MaxRate_cmd/500\n   * Referenced by: '<S10>/Unit conversion [stick value] to [rad//s]'\n   */\n  { 0.012566370614359173, 0.012566370614359173, 0.0041887902047863905 },\n\n  /* Expression: MaxRate_cmd\n   * Referenced by: '<S11>/Saturation'\n   */\n  { 6.2831853071795862, 6.2831853071795862, 2.0943951023931953 },\n\n  /* Expression: -MaxRate_cmd\n   * Referenced by: '<S11>/Saturation'\n   */\n  { -6.2831853071795862, -6.2831853071795862, -2.0943951023931953 }\n};\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long int long_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint32_T chunks[2];\n} int64m_T;\n\ntypedef struct {\n  int64m_T re;\n  int64m_T im;\n} cint64m_T;\n\ntypedef struct {\n  uint32_T chunks[2];\n} uint64m_T;\n\ntypedef struct {\n  uint64m_T re;\n  uint64m_T im;\n} cuint64m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} int96m_T;\n\ntypedef struct {\n  int96m_T re;\n  int96m_T im;\n} cint96m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} uint96m_T;\n\ntypedef struct {\n  uint96m_T re;\n  uint96m_T im;\n} cuint96m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} int160m_T;\n\ntypedef struct {\n  int160m_T re;\n  int160m_T im;\n} cint160m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} uint160m_T;\n\ntypedef struct {\n  uint160m_T re;\n  uint160m_T im;\n} cuint160m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} int224m_T;\n\ntypedef struct {\n  int224m_T re;\n  int224m_T im;\n} cint224m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} uint224m_T;\n\ntypedef struct {\n  uint224m_T re;\n  uint224m_T im;\n} cuint224m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint32_T chunks[9];\n} int288m_T;\n\ntypedef struct {\n  int288m_T re;\n  int288m_T im;\n} cint288m_T;\n\ntypedef struct {\n  uint32_T chunks[9];\n} uint288m_T;\n\ntypedef struct {\n  uint288m_T re;\n  uint288m_T im;\n} cuint288m_T;\n\ntypedef struct {\n  uint32_T chunks[10];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint32_T chunks[10];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint32_T chunks[11];\n} int352m_T;\n\ntypedef struct {\n  int352m_T re;\n  int352m_T im;\n} cint352m_T;\n\ntypedef struct {\n  uint32_T chunks[11];\n} uint352m_T;\n\ntypedef struct {\n  uint352m_T re;\n  uint352m_T im;\n} cuint352m_T;\n\ntypedef struct {\n  uint32_T chunks[12];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint32_T chunks[12];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint32_T chunks[13];\n} int416m_T;\n\ntypedef struct {\n  int416m_T re;\n  int416m_T im;\n} cint416m_T;\n\ntypedef struct {\n  uint32_T chunks[13];\n} uint416m_T;\n\ntypedef struct {\n  uint416m_T re;\n  uint416m_T im;\n} cuint416m_T;\n\ntypedef struct {\n  uint32_T chunks[14];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint32_T chunks[14];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint32_T chunks[15];\n} int480m_T;\n\ntypedef struct {\n  int480m_T re;\n  int480m_T im;\n} cint480m_T;\n\ntypedef struct {\n  uint32_T chunks[15];\n} uint480m_T;\n\ntypedef struct {\n  uint480m_T re;\n  uint480m_T im;\n} cuint480m_T;\n\ntypedef struct {\n  uint32_T chunks[16];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint32_T chunks[16];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint32_T chunks[17];\n} int544m_T;\n\ntypedef struct {\n  int544m_T re;\n  int544m_T im;\n} cint544m_T;\n\ntypedef struct {\n  uint32_T chunks[17];\n} uint544m_T;\n\ntypedef struct {\n  uint544m_T re;\n  uint544m_T im;\n} cuint544m_T;\n\ntypedef struct {\n  uint32_T chunks[18];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint32_T chunks[18];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint32_T chunks[19];\n} int608m_T;\n\ntypedef struct {\n  int608m_T re;\n  int608m_T im;\n} cint608m_T;\n\ntypedef struct {\n  uint32_T chunks[19];\n} uint608m_T;\n\ntypedef struct {\n  uint608m_T re;\n  uint608m_T im;\n} cuint608m_T;\n\ntypedef struct {\n  uint32_T chunks[20];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint32_T chunks[20];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint32_T chunks[21];\n} int672m_T;\n\ntypedef struct {\n  int672m_T re;\n  int672m_T im;\n} cint672m_T;\n\ntypedef struct {\n  uint32_T chunks[21];\n} uint672m_T;\n\ntypedef struct {\n  uint672m_T re;\n  uint672m_T im;\n} cuint672m_T;\n\ntypedef struct {\n  uint32_T chunks[22];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint32_T chunks[22];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint32_T chunks[23];\n} int736m_T;\n\ntypedef struct {\n  int736m_T re;\n  int736m_T im;\n} cint736m_T;\n\ntypedef struct {\n  uint32_T chunks[23];\n} uint736m_T;\n\ntypedef struct {\n  uint736m_T re;\n  uint736m_T im;\n} cuint736m_T;\n\ntypedef struct {\n  uint32_T chunks[24];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint32_T chunks[24];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint32_T chunks[25];\n} int800m_T;\n\ntypedef struct {\n  int800m_T re;\n  int800m_T im;\n} cint800m_T;\n\ntypedef struct {\n  uint32_T chunks[25];\n} uint800m_T;\n\ntypedef struct {\n  uint800m_T re;\n  uint800m_T im;\n} cuint800m_T;\n\ntypedef struct {\n  uint32_T chunks[26];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint32_T chunks[26];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint32_T chunks[27];\n} int864m_T;\n\ntypedef struct {\n  int864m_T re;\n  int864m_T im;\n} cint864m_T;\n\ntypedef struct {\n  uint32_T chunks[27];\n} uint864m_T;\n\ntypedef struct {\n  uint864m_T re;\n  uint864m_T im;\n} cuint864m_T;\n\ntypedef struct {\n  uint32_T chunks[28];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint32_T chunks[28];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint32_T chunks[29];\n} int928m_T;\n\ntypedef struct {\n  int928m_T re;\n  int928m_T im;\n} cint928m_T;\n\ntypedef struct {\n  uint32_T chunks[29];\n} uint928m_T;\n\ntypedef struct {\n  uint928m_T re;\n  uint928m_T im;\n} cuint928m_T;\n\ntypedef struct {\n  uint32_T chunks[30];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint32_T chunks[30];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint32_T chunks[31];\n} int992m_T;\n\ntypedef struct {\n  int992m_T re;\n  int992m_T im;\n} cint992m_T;\n\ntypedef struct {\n  uint32_T chunks[31];\n} uint992m_T;\n\ntypedef struct {\n  uint992m_T re;\n  uint992m_T im;\n} cuint992m_T;\n\ntypedef struct {\n  uint32_T chunks[32];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint32_T chunks[32];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint32_T chunks[33];\n} int1056m_T;\n\ntypedef struct {\n  int1056m_T re;\n  int1056m_T im;\n} cint1056m_T;\n\ntypedef struct {\n  uint32_T chunks[33];\n} uint1056m_T;\n\ntypedef struct {\n  uint1056m_T re;\n  uint1056m_T im;\n} cuint1056m_T;\n\ntypedef struct {\n  uint32_T chunks[34];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint32_T chunks[34];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint32_T chunks[35];\n} int1120m_T;\n\ntypedef struct {\n  int1120m_T re;\n  int1120m_T im;\n} cint1120m_T;\n\ntypedef struct {\n  uint32_T chunks[35];\n} uint1120m_T;\n\ntypedef struct {\n  uint1120m_T re;\n  uint1120m_T im;\n} cuint1120m_T;\n\ntypedef struct {\n  uint32_T chunks[36];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint32_T chunks[36];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint32_T chunks[37];\n} int1184m_T;\n\ntypedef struct {\n  int1184m_T re;\n  int1184m_T im;\n} cint1184m_T;\n\ntypedef struct {\n  uint32_T chunks[37];\n} uint1184m_T;\n\ntypedef struct {\n  uint1184m_T re;\n  uint1184m_T im;\n} cuint1184m_T;\n\ntypedef struct {\n  uint32_T chunks[38];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint32_T chunks[38];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint32_T chunks[39];\n} int1248m_T;\n\ntypedef struct {\n  int1248m_T re;\n  int1248m_T im;\n} cint1248m_T;\n\ntypedef struct {\n  uint32_T chunks[39];\n} uint1248m_T;\n\ntypedef struct {\n  uint1248m_T re;\n  uint1248m_T im;\n} cuint1248m_T;\n\ntypedef struct {\n  uint32_T chunks[40];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint32_T chunks[40];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint32_T chunks[41];\n} int1312m_T;\n\ntypedef struct {\n  int1312m_T re;\n  int1312m_T im;\n} cint1312m_T;\n\ntypedef struct {\n  uint32_T chunks[41];\n} uint1312m_T;\n\ntypedef struct {\n  uint1312m_T re;\n  uint1312m_T im;\n} cuint1312m_T;\n\ntypedef struct {\n  uint32_T chunks[42];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint32_T chunks[42];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint32_T chunks[43];\n} int1376m_T;\n\ntypedef struct {\n  int1376m_T re;\n  int1376m_T im;\n} cint1376m_T;\n\ntypedef struct {\n  uint32_T chunks[43];\n} uint1376m_T;\n\ntypedef struct {\n  uint1376m_T re;\n  uint1376m_T im;\n} cuint1376m_T;\n\ntypedef struct {\n  uint32_T chunks[44];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint32_T chunks[44];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint32_T chunks[45];\n} int1440m_T;\n\ntypedef struct {\n  int1440m_T re;\n  int1440m_T im;\n} cint1440m_T;\n\ntypedef struct {\n  uint32_T chunks[45];\n} uint1440m_T;\n\ntypedef struct {\n  uint1440m_T re;\n  uint1440m_T im;\n} cuint1440m_T;\n\ntypedef struct {\n  uint32_T chunks[46];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint32_T chunks[46];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint32_T chunks[47];\n} int1504m_T;\n\ntypedef struct {\n  int1504m_T re;\n  int1504m_T im;\n} cint1504m_T;\n\ntypedef struct {\n  uint32_T chunks[47];\n} uint1504m_T;\n\ntypedef struct {\n  uint1504m_T re;\n  uint1504m_T im;\n} cuint1504m_T;\n\ntypedef struct {\n  uint32_T chunks[48];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint32_T chunks[48];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint32_T chunks[49];\n} int1568m_T;\n\ntypedef struct {\n  int1568m_T re;\n  int1568m_T im;\n} cint1568m_T;\n\ntypedef struct {\n  uint32_T chunks[49];\n} uint1568m_T;\n\ntypedef struct {\n  uint1568m_T re;\n  uint1568m_T im;\n} cuint1568m_T;\n\ntypedef struct {\n  uint32_T chunks[50];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint32_T chunks[50];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint32_T chunks[51];\n} int1632m_T;\n\ntypedef struct {\n  int1632m_T re;\n  int1632m_T im;\n} cint1632m_T;\n\ntypedef struct {\n  uint32_T chunks[51];\n} uint1632m_T;\n\ntypedef struct {\n  uint1632m_T re;\n  uint1632m_T im;\n} cuint1632m_T;\n\ntypedef struct {\n  uint32_T chunks[52];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint32_T chunks[52];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint32_T chunks[53];\n} int1696m_T;\n\ntypedef struct {\n  int1696m_T re;\n  int1696m_T im;\n} cint1696m_T;\n\ntypedef struct {\n  uint32_T chunks[53];\n} uint1696m_T;\n\ntypedef struct {\n  uint1696m_T re;\n  uint1696m_T im;\n} cuint1696m_T;\n\ntypedef struct {\n  uint32_T chunks[54];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint32_T chunks[54];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint32_T chunks[55];\n} int1760m_T;\n\ntypedef struct {\n  int1760m_T re;\n  int1760m_T im;\n} cint1760m_T;\n\ntypedef struct {\n  uint32_T chunks[55];\n} uint1760m_T;\n\ntypedef struct {\n  uint1760m_T re;\n  uint1760m_T im;\n} cuint1760m_T;\n\ntypedef struct {\n  uint32_T chunks[56];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint32_T chunks[56];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint32_T chunks[57];\n} int1824m_T;\n\ntypedef struct {\n  int1824m_T re;\n  int1824m_T im;\n} cint1824m_T;\n\ntypedef struct {\n  uint32_T chunks[57];\n} uint1824m_T;\n\ntypedef struct {\n  uint1824m_T re;\n  uint1824m_T im;\n} cuint1824m_T;\n\ntypedef struct {\n  uint32_T chunks[58];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint32_T chunks[58];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint32_T chunks[59];\n} int1888m_T;\n\ntypedef struct {\n  int1888m_T re;\n  int1888m_T im;\n} cint1888m_T;\n\ntypedef struct {\n  uint32_T chunks[59];\n} uint1888m_T;\n\ntypedef struct {\n  uint1888m_T re;\n  uint1888m_T im;\n} cuint1888m_T;\n\ntypedef struct {\n  uint32_T chunks[60];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint32_T chunks[60];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint32_T chunks[61];\n} int1952m_T;\n\ntypedef struct {\n  int1952m_T re;\n  int1952m_T im;\n} cint1952m_T;\n\ntypedef struct {\n  uint32_T chunks[61];\n} uint1952m_T;\n\ntypedef struct {\n  uint1952m_T re;\n  uint1952m_T im;\n} cuint1952m_T;\n\ntypedef struct {\n  uint32_T chunks[62];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint32_T chunks[62];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint32_T chunks[63];\n} int2016m_T;\n\ntypedef struct {\n  int2016m_T re;\n  int2016m_T im;\n} cint2016m_T;\n\ntypedef struct {\n  uint32_T chunks[63];\n} uint2016m_T;\n\ntypedef struct {\n  uint2016m_T re;\n  uint2016m_T im;\n} cuint2016m_T;\n\ntypedef struct {\n  uint32_T chunks[64];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint32_T chunks[64];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T inf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T minf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T nan{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF{ { 0.0F } };\n\n    uint16_T one{ 1U };\n\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder\n{\n      (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n    };\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_defines.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_defines_h_\n#define RTW_HEADER_rt_defines_h_\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result{ (boolean_T) 0 };\n\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.fltVal = value;\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                               0x7FF00000 &&\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                                (tmpVal.bitVal.words.wordL != 0) ));\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.fltVal = value;\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                               0x7FF00000 &&\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                                (tmpVal.bitVal.words.wordL != 0) ));\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.cpp","type":"source","group":"interface","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.cpp:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtmodel.h\"\n\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\nvoid Sim_Multi_step(Sim_Multi & Sim_Multi_Obj, int_T tid)\n{\n  switch (tid) {\n   case 0 :\n    Sim_Multi_Obj.step0();\n    break;\n\n   case 2 :\n    Sim_Multi_Obj.step2();\n    break;\n\n   case 3 :\n    Sim_Multi_Obj.step3();\n    break;\n\n   case 4 :\n    Sim_Multi_Obj.step4();\n    break;\n\n   case 5 :\n    Sim_Multi_Obj.step5();\n    break;\n\n   default :\n    /* do nothing */\n    break;\n  }\n}\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/divij/Desktop/complex/MultirotorSim_Vervoorst/Sim_Multi_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"Sim_Multi\".\n *\n * Model version              : 14.1\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Mon Jul 24 11:57:47 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"Sim_Multi.h\"\n#define MODEL_CLASSNAME                Sim_Multi\n#define MODEL_STEPNAME                 Sim_Multi_step\n#define GRTINTERFACE                   0\n\n/*\n * ROOT_IO_FORMAT: 0 (Individual arguments)\n * ROOT_IO_FORMAT: 1 (Structure reference)\n * ROOT_IO_FORMAT: 2 (Part of model data structure)\n */\n#define ROOT_IO_FORMAT                 2\n\n/* Model wrapper function */\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\nextern void Sim_Multi_step(Sim_Multi & Sim_Multi_Obj, int_T tid);\n\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};