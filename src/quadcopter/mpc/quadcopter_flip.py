import casadi as ca
import numpy as np
import matplotlib.pyplot as plt


# Define quadcopter dynamics and optimisation
opti = ca.Opti()

# Constants
N = 100  # Number of time steps
mass = 0.1
Ixx = 1.0
Iyy = 0.5 * mass * 0.1 ** 2
Izz = 1.0
arm_length = 0.1  # Distance from the centre to the propellers

# Time variable
time_final = opti.variable()
opti.set_initial(time_final, 1.0)  # Initial guess
opti.subject_to(time_final > 0)  # Time must be positive

# Time discretisation
time = ca.linspace(0, 1, N) * time_final  # Scaled time vector

# Control variables (thrusts for 4 thrusters)
thruster_FL = opti.variable(N)
thruster_FR = opti.variable(N)
thruster_BL = opti.variable(N)
thruster_BR = opti.variable(N)
opti.set_initial(thruster_FL, 0.7)
opti.set_initial(thruster_FR, 0.7)
opti.set_initial(thruster_BL, 0.7)
opti.set_initial(thruster_BR, 0.7)

# State variables
x_e = opti.variable(N)  # Position in x (inertial frame)
y_e = opti.variable(N)  # Position in y (inertial frame)
z_e = opti.variable(N)  # Position in z (inertial frame)
u_b = opti.variable(N)  # Velocity in x (body frame)
v_b = opti.variable(N)  # Velocity in y (body frame)
w_b = opti.variable(N)  # Velocity in z (body frame)
theta = opti.variable(N)  # Pitch angle
phi = opti.variable(N)  # Roll angle
psi = opti.variable(N)  # Yaw angle
p = opti.variable(N)  # Pitch rate
q = opti.variable(N)  # Roll rate
r = opti.variable(N)  # Yaw rate

# Set initial guesses
opti.set_initial(x_e, 0)
opti.set_initial(y_e, 0)
opti.set_initial(z_e, 0)
opti.set_initial(u_b, 0)
opti.set_initial(v_b, 0)
opti.set_initial(w_b, 0)
opti.set_initial(theta, 0)
opti.set_initial(phi, 0)
opti.set_initial(psi, 0)
opti.set_initial(p, 0)
opti.set_initial(q, 0)
opti.set_initial(r, 0)
energy_final = 0

# Dynamics equations
dt = time_final / (N - 1)  # Time step
for k in range(N - 1):
    # Forces from each of the four thrusters
    F_FL = thruster_FL[k]
    F_FR = thruster_FR[k]
    F_BL = thruster_BL[k]
    F_BR = thruster_BR[k]

    opti.subject_to(thruster_FL[k] >= 0)
    opti.subject_to(thruster_FR[k] >= 0)
    opti.subject_to(thruster_BL[k] >= 0)
    opti.subject_to(thruster_BR[k] >= 0)

    # Total thrust in z direction
    Fz = F_FL + F_FR + F_BL + F_BR

    # Torques generated by the thrusters (using arm_length for distance from center)
    Mx = (F_FR + F_BR - F_FL - F_BL) * arm_length / 2
    My = (F_FL + F_FR - F_BL - F_BR) * arm_length / 2


    cr, cp, cy = ca.cos(phi[k]), ca.cos(theta[k]), ca.cos(psi[k])
    sr, sp, sy = ca.sin(phi[k]), ca.sin(theta[k]), ca.sin(psi[k])

    # Rotation matrix
    R = ca.vertcat(
        ca.horzcat(cy * cp, cy * sp * sr - sy * cr, cy * sp * cr + sy * sr),
        ca.horzcat(sy * cp, sy * sp * sr + cy * cr, sy * sp * cr - cy * sr),
        ca.horzcat(-sp, cp * sr, cp * cr)
    )

    # Forces in the inertial frame
    thrust_force = R @ ca.vertcat(0, 0, Fz)
    gravity_force = ca.vertcat(0, 0, -mass * 9.81)
    total_force = thrust_force + gravity_force

    # Linear acceleration
    linear_acc = total_force / mass

    # Angular accelerations
    angular_acc = ca.vertcat(Mx / Ixx, My / Iyy, 0)

    # State update equations (Euler integration)
    opti.subject_to(x_e[k + 1] == x_e[k] + dt * u_b[k])
    opti.subject_to(y_e[k + 1] == y_e[k] + dt * v_b[k])
    opti.subject_to(z_e[k + 1] == z_e[k] + dt * w_b[k])

    opti.subject_to(u_b[k + 1] == u_b[k] + dt * linear_acc[0])
    opti.subject_to(v_b[k + 1] == v_b[k] + dt * linear_acc[1])
    opti.subject_to(w_b[k + 1] == w_b[k] + dt * linear_acc[2])

    opti.subject_to(phi[k + 1] == phi[k] + dt * p[k])
    opti.subject_to(theta[k + 1] == theta[k] + dt * q[k])
    opti.subject_to(psi[k + 1] == psi[k] + dt * r[k])

    opti.subject_to(p[k + 1] == p[k] + dt * angular_acc[0])
    opti.subject_to(q[k + 1] == q[k] + dt * angular_acc[1])
    opti.subject_to(r[k + 1] == r[k] + dt * angular_acc[2])

    energy_final += (thruster_FL[k]**2 +
                    thruster_FR[k]**2 +
                    thruster_BL[k]**2 +
                    thruster_BR[k]**2)

# Initial state constraints
opti.subject_to([
    x_e[0] == 0,
    y_e[0] == 0,
    z_e[0] == 0,
    u_b[0] == 0,
    v_b[0] == 0,
    w_b[0] == 0,
    theta[0] == 0,
    phi[0] == 0,
    psi[0] == 0,
    p[0] == 0,
    q[0] == 0,
    r[0] == 0,
])

# Final state constraints (target position (5, 5, 5))
opti.subject_to([
    x_e[-1] == 5,
    y_e[-1] == 5,
    z_e[-1] == 5,
    u_b[-1] == 0,
    v_b[-1] == 0,
    w_b[-1] == 0,
    theta[-1] == 0,
    phi[-1] == 0,
    psi[-1] == 0,
    p[-1] == 0,
    q[-1] == 0,
    r[-1] == 0,
])

# Objective function: minimise time
opti.minimize(0.99 * time_final + 0.01 * energy_final)

# Solver setup and solution
opti.solver("ipopt", {"print_time": True}, {"print_level": 0})
solution = opti.solve()

# Extract results
x_e_opt = solution.value(x_e)
y_e_opt = solution.value(y_e)
z_e_opt = solution.value(z_e)
theta_opt = solution.value(theta)
phi_opt = solution.value(phi)
time_final_opt = solution.value(time_final)
thruster_FL_opt = solution.value(thruster_FL)
thruster_FR_opt = solution.value(thruster_FR)
thruster_BL_opt = solution.value(thruster_BL)
thruster_BR_opt = solution.value(thruster_BR)


# Results output
print(f"Move to (5, 5, 5) completed in {time_final_opt:.3f} seconds")


def visualise_quadcopter_3d(x_e_vals, y_e_vals, z_e_vals, theta_vals, phi_vals, arm_length=0.4, motor_radius=0.1, draw_interval=5):
    """
    Visualises the quadcopter's motion in 3D, including arms, motors, and trajectory.

    Parameters:
        x_e_vals: Array of x positions (world frame)
        y_e_vals: Array of y positions (world frame)
        z_e_vals: Array of z positions (world frame)
        theta_vals: Array of pitch angles (radians)
        phi_vals: Array of roll angles (radians)
        arm_length: Length of each arm of the quadcopter
        motor_radius: Radius of the circular motors
        draw_interval: Interval to draw the quadcopter during simulation
    """
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection="3d")
    ax.set_xlabel("X (m)")
    ax.set_ylabel("Y (m)")
    ax.set_zlabel("Z (m)")
    ax.set_title("Quadcopter Motion in 3D")

    # Plot the trajectory
    ax.plot(x_e_vals, y_e_vals, z_e_vals, label="Trajectory", lw=2, color="blue")
    ax.scatter([x_e_vals[0]], [y_e_vals[0]], [z_e_vals[0]], color="green", label="Start Point", s=100)
    ax.scatter([x_e_vals[-1]], [y_e_vals[-1]], [z_e_vals[-1]], color="red", label="End Point", s=100)

    for i in range(0, len(x_e_vals), draw_interval):
        x = x_e_vals[i]
        y = y_e_vals[i]
        z = z_e_vals[i]
        theta = theta_vals[i]
        phi = phi_vals[i]

        # Rotation matrix for roll (phi) and pitch (theta)
        rotation_matrix = np.array([
            [np.cos(theta), 0, np.sin(theta)],
            [0, 1, 0],
            [-np.sin(theta), 0, np.cos(theta)]
        ]) @ np.array([
            [1, 0, 0],
            [0, np.cos(phi), -np.sin(phi)],
            [0, np.sin(phi), np.cos(phi)]
        ])

        # Arm endpoints in the body frame
        arm_ends = np.array([
            [arm_length / 2, 0, 0],  # Front arm (positive x direction)
            [-arm_length / 2, 0, 0], # Back arm (negative x direction)
            [0, arm_length / 2, 0],  # Left arm (positive y direction)
            [0, -arm_length / 2, 0]  # Right arm (negative y direction)
        ]).T

        rotated_ends = rotation_matrix @ arm_ends

        # Plot arms
        for j in range(0, len(rotated_ends.T), 2):
            ax.plot(
                [x, x + rotated_ends[0, j]],
                [y, y + rotated_ends[1, j]],
                [z, z + rotated_ends[2, j]],
                "b-", lw=2, label="Arms" if i == 0 and j == 0 else ""
            )

        # Plot motors as circles at arm endpoints
        for j in range(rotated_ends.shape[1]):
            motor_x = x + rotated_ends[0, j]
            motor_y = y + rotated_ends[1, j]
            motor_z = z + rotated_ends[2, j]

            # Create a circle to represent the motor
            u = np.linspace(0, 2 * np.pi, 100)
            motor_circle_x = motor_x + motor_radius * np.cos(u)
            motor_circle_y = motor_y + motor_radius * np.sin(u)
            motor_circle_z = np.full_like(u, motor_z)

            ax.plot(motor_circle_x, motor_circle_y, motor_circle_z, "r-", lw=1, label="Motors" if i == 0 and j == 0 else "")

    # Add legend and show
    ax.legend()
    plt.show()


# Call the visualisation function for 3D
visualise_quadcopter_3d(x_e_opt, y_e_opt, z_e_opt, theta_opt, phi_opt, arm_length=0.4, motor_radius=0.1, draw_interval=5)

plt.figure(figsize=(10, 6))

# Plot each thruster force
plt.plot(thruster_FL_opt, label="Front Left (F_FL)", linestyle='-', marker='o')
plt.plot( thruster_FR_opt, label="Front Right (F_FR)", linestyle='-', marker='x')
plt.plot(thruster_BL_opt, label="Back Left (F_BL)", linestyle='-', marker='^')
plt.plot(thruster_BR_opt, label="Back Right (F_BR)", linestyle='-', marker='s')

# Add labels, legend, and grid
plt.xlabel("Time (s)")
plt.ylabel("Thruster Force (N)")
plt.title("Control Inputs: Thruster Forces Over Time")
plt.legend()
plt.grid(True)

# Show the plot
plt.show()
