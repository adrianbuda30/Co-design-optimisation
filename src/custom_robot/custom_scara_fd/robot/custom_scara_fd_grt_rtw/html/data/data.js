var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"custom_forward_dynamics/custom_scara_fd","ref":false,"files":[{"name":"custom_scara_fd.cpp","type":"source","group":"model","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * custom_scara_fd.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"custom_scara_fd.h\"\n#include \"rtwtypes.h\"\n#include <cstring>\n#include <cmath>\n#include \"custom_scara_fd_private.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_eye(real_T b_I[9])\n{\n  std::memset(&b_I[0], 0, 9U * sizeof(real_T));\n  b_I[0] = 1.0;\n  b_I[4] = 1.0;\n  b_I[8] = 1.0;\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_diag(const real_T v[3], real_T d[9])\n{\n  std::memset(&d[0], 0, 9U * sizeof(real_T));\n  d[0] = v[0];\n  d[4] = v[1];\n  d[8] = v[2];\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_repmat(real_T b[18])\n{\n  static const int8_T a[6]{ 0, 0, 0, 0, 0, 1 };\n\n  for (int32_T itilerow{0}; itilerow < 3; itilerow++) {\n    int32_T ibcol;\n    ibcol = itilerow * 6;\n    for (int32_T k{0}; k < 6; k++) {\n      b[ibcol + k] = a[k];\n    }\n  }\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nboolean_T custom_scara_fd::custom_scara_fd_all(const boolean_T x[3])\n{\n  int32_T k;\n  boolean_T exitg1;\n  boolean_T y;\n  y = true;\n  k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (k < 3)) {\n    if (!x[k]) {\n      y = false;\n      exitg1 = true;\n    } else {\n      k++;\n    }\n  }\n\n  return y;\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes(const real_T A_data[], const\n  int32_T A_size[2], const real_T B[16], real_T C_data[], int32_T C_size[2])\n{\n  int32_T m;\n  m = A_size[0];\n  C_size[0] = A_size[0];\n  C_size[1] = 4;\n  for (int32_T j{0}; j < 4; j++) {\n    int32_T boffset;\n    int32_T coffset;\n    coffset = j * m;\n    boffset = j << 2;\n    for (int32_T i{0}; i < m; i++) {\n      C_data[coffset + i] = ((A_data[A_size[0] + i] * B[boffset + 1] + A_data[i]\n        * B[boffset]) + A_data[(A_size[0] << 1) + i] * B[boffset + 2]) + A_data\n        [3 * A_size[0] + i] * B[boffset + 3];\n    }\n  }\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes_m(const real_T A[36], const real_T\n  B_data[], const int32_T B_size[2], real_T C_data[], int32_T C_size[2])\n{\n  int32_T b;\n  C_size[0] = 6;\n  C_size[1] = B_size[1];\n  b = B_size[1];\n  for (int32_T j{0}; j < b; j++) {\n    int32_T coffset_tmp;\n    coffset_tmp = j * 6;\n    for (int32_T i{0}; i < 6; i++) {\n      real_T s;\n      s = 0.0;\n      for (int32_T k{0}; k < 6; k++) {\n        s += A[k * 6 + i] * B_data[coffset_tmp + k];\n      }\n\n      C_data[coffset_tmp + i] = s;\n    }\n  }\n}\n\nvoid custom_scara_fd::custom_sca_binary_expand_op_ih2(real_T in1[18], int32_T\n  in2, const real_T in3[36], const real_T in4[18], const real_T in5[9], const\n  real_T in6[6], const real_T in7[18])\n{\n  real_T in5_0[36];\n  real_T in4_data[12];\n  real_T tmp_data[12];\n  real_T tmp_data_0[12];\n  real_T in5_1;\n  int32_T in4_size[2];\n  int32_T tmp_size[2];\n  int32_T tmp_size_0[2];\n  int32_T aux_0_1;\n  int32_T aux_1_1;\n  int32_T i;\n  int32_T in5_tmp;\n  int32_T loop_ub;\n  int32_T stride_0_1;\n  int32_T stride_1_1;\n\n  /* Outputs for Atomic SubSystem: '<Root>/custom_scara_fd' */\n  /* MATLAB Function: '<S1>/calcSysMatrices' */\n  in4_size[0] = 6;\n  in4_size[1] = in2;\n  for (i = 0; i < in2; i++) {\n    for (in5_tmp = 0; in5_tmp < 6; in5_tmp++) {\n      in4_data[in5_tmp + 6 * i] = in4[6 * i + in5_tmp];\n    }\n  }\n\n  custom_scara_fd_mtimes_m(in3, in4_data, in4_size, tmp_data, tmp_size);\n  in5_0[18] = 0.0;\n  in5_0[24] = -in6[2];\n  in5_0[30] = in6[1];\n  in5_0[19] = in6[2];\n  in5_0[25] = 0.0;\n  in5_0[31] = -in6[0];\n  in5_0[20] = -in6[1];\n  in5_0[26] = in6[0];\n  in5_0[32] = 0.0;\n  for (i = 0; i < 3; i++) {\n    in5_1 = in5[3 * i];\n    in5_0[6 * i] = in5_1;\n    in5_0[6 * i + 3] = 0.0;\n    in5_tmp = (i + 3) * 6;\n    in5_0[in5_tmp + 3] = in5_1;\n    in5_1 = in5[3 * i + 1];\n    in5_0[6 * i + 1] = in5_1;\n    in5_0[6 * i + 4] = 0.0;\n    in5_0[in5_tmp + 4] = in5_1;\n    in5_1 = in5[3 * i + 2];\n    in5_0[6 * i + 2] = in5_1;\n    in5_0[6 * i + 5] = 0.0;\n    in5_0[in5_tmp + 5] = in5_1;\n  }\n\n  in4_size[0] = 6;\n  in4_size[1] = in2;\n  for (i = 0; i < in2; i++) {\n    for (in5_tmp = 0; in5_tmp < 6; in5_tmp++) {\n      in4_data[in5_tmp + 6 * i] = in7[6 * i + in5_tmp];\n    }\n  }\n\n  custom_scara_fd_mtimes_m(in5_0, in4_data, in4_size, tmp_data_0, tmp_size_0);\n  stride_0_1 = (tmp_size[1] != 1);\n  stride_1_1 = (tmp_size_0[1] != 1);\n  aux_0_1 = 0;\n  aux_1_1 = 0;\n  loop_ub = tmp_size_0[1] == 1 ? tmp_size[1] : tmp_size_0[1];\n  for (i = 0; i < loop_ub; i++) {\n    for (in5_tmp = 0; in5_tmp < 6; in5_tmp++) {\n      in1[in5_tmp + 6 * i] = tmp_data[6 * aux_0_1 + in5_tmp] - tmp_data_0[6 *\n        aux_1_1 + in5_tmp];\n    }\n\n    aux_1_1 += stride_1_1;\n    aux_0_1 += stride_0_1;\n  }\n\n  /* End of MATLAB Function: '<S1>/calcSysMatrices' */\n  /* End of Outputs for SubSystem: '<Root>/custom_scara_fd' */\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes_mn(const real_T A_data[], const\n  int32_T A_size[2], const real_T B_data[], const int32_T B_size[2], real_T\n  C_data[], int32_T C_size[2])\n{\n  int32_T m;\n  m = A_size[1];\n  C_size[0] = A_size[1];\n  C_size[1] = 6;\n  for (int32_T j{0}; j < 6; j++) {\n    int32_T boffset;\n    int32_T coffset;\n    coffset = j * m;\n    boffset = j * B_size[0];\n    for (int32_T i{0}; i < m; i++) {\n      real_T s;\n      int32_T aoffset;\n      aoffset = i * 6;\n      s = 0.0;\n      for (int32_T k{0}; k < 6; k++) {\n        s += A_data[aoffset + k] * B_data[boffset + k];\n      }\n\n      C_data[coffset + i] = s;\n    }\n  }\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes_mni(const real_T A_data[], const\n  int32_T A_size[2], const real_T B_data[], const int32_T B_size[2], real_T\n  C_data[], int32_T C_size[2])\n{\n  int32_T b;\n  int32_T m;\n  m = A_size[0];\n  C_size[0] = A_size[0];\n  C_size[1] = B_size[1];\n  b = B_size[1];\n  for (int32_T j{0}; j < b; j++) {\n    int32_T boffset;\n    int32_T coffset;\n    coffset = j * m;\n    boffset = j * 6;\n    for (int32_T i{0}; i < m; i++) {\n      real_T s;\n      s = 0.0;\n      for (int32_T k{0}; k < 6; k++) {\n        s += A_data[k * A_size[0] + i] * B_data[boffset + k];\n      }\n\n      C_data[coffset + i] = s;\n    }\n  }\n}\n\nvoid custom_scara_fd::custom_scar_binary_expand_op_ih(real_T in1[9], int32_T in2,\n  const real_T in3_data[], const int32_T in3_size[2], const real_T in4[18])\n{\n  real_T in4_data[18];\n  real_T in1_data[9];\n  real_T tmp_data[9];\n  int32_T in4_size[2];\n  int32_T tmp_size[2];\n  int32_T aux_0_1;\n  int32_T aux_1_1;\n  int32_T i;\n  int32_T i_0;\n  int32_T loop_ub;\n  int32_T loop_ub_0;\n  int32_T stride_0_0_tmp;\n  int32_T stride_1_0;\n  int32_T stride_1_1;\n\n  /* Outputs for Atomic SubSystem: '<Root>/custom_scara_fd' */\n  /* MATLAB Function: '<S1>/calcSysMatrices' */\n  in4_size[0] = 6;\n  in4_size[1] = in2 + 1;\n  for (i_0 = 0; i_0 <= in2; i_0++) {\n    for (i = 0; i < 6; i++) {\n      in4_data[i + 6 * i_0] = in4[6 * i_0 + i];\n    }\n  }\n\n  custom_scara_fd_mtimes_mni(in3_data, in3_size, in4_data, in4_size, tmp_data,\n    tmp_size);\n  loop_ub_0 = tmp_size[0] == 1 ? in2 + 1 : tmp_size[0];\n  loop_ub = tmp_size[1] == 1 ? in2 + 1 : tmp_size[1];\n  stride_0_0_tmp = (in2 + 1 != 1);\n  stride_1_0 = (tmp_size[0] != 1);\n  stride_1_1 = (tmp_size[1] != 1);\n  aux_0_1 = 0;\n  aux_1_1 = 0;\n  for (i_0 = 0; i_0 < loop_ub; i_0++) {\n    for (i = 0; i < loop_ub_0; i++) {\n      in1_data[i + loop_ub_0 * i_0] = in1[i * stride_0_0_tmp + 3 * aux_0_1] +\n        tmp_data[i * stride_1_0 + tmp_size[0] * aux_1_1];\n    }\n\n    aux_1_1 += stride_1_1;\n    aux_0_1 += stride_0_0_tmp;\n  }\n\n  for (i_0 = 0; i_0 < loop_ub; i_0++) {\n    for (i = 0; i < loop_ub_0; i++) {\n      in1[i + 3 * i_0] = in1_data[loop_ub_0 * i_0 + i];\n    }\n  }\n\n  /* End of MATLAB Function: '<S1>/calcSysMatrices' */\n  /* End of Outputs for SubSystem: '<Root>/custom_scara_fd' */\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes_mnik(const real_T A_data[], const\n  int32_T A_size[2], const real_T B[36], real_T C_data[], int32_T C_size[2])\n{\n  int32_T m;\n  m = A_size[1];\n  C_size[0] = A_size[1];\n  C_size[1] = 6;\n  for (int32_T j{0}; j < 6; j++) {\n    int32_T boffset;\n    int32_T coffset;\n    coffset = j * m;\n    boffset = j * 6;\n    for (int32_T i{0}; i < m; i++) {\n      real_T s;\n      int32_T aoffset;\n      aoffset = i * 6;\n      s = 0.0;\n      for (int32_T k{0}; k < 6; k++) {\n        s += A_data[aoffset + k] * B[boffset + k];\n      }\n\n      C_data[coffset + i] = s;\n    }\n  }\n}\n\nvoid custom_scara_fd::custom_scara_binary_expand_op_i(real_T in1[9], int32_T in2,\n  const real_T in3[18], real_T in4, const real_T in5[9], const real_T in6[9],\n  const real_T in7[9], const real_T in8_data[], const int32_T in8_size[2], const\n  real_T in9[18])\n{\n  real_T in4_0[36];\n  real_T in3_data[18];\n  real_T in3_data_0[18];\n  real_T tmp_data_1[18];\n  real_T in1_data[9];\n  real_T tmp_data[9];\n  real_T tmp_data_0[9];\n  int32_T in3_size[2];\n  int32_T in3_size_0[2];\n  int32_T tmp_size[2];\n  int32_T tmp_size_0[2];\n  int32_T aux_0_1;\n  int32_T aux_1_1;\n  int32_T aux_2_1;\n  int32_T i;\n  int32_T in4_tmp;\n  int32_T in4_tmp_0;\n  int32_T loop_ub;\n  int32_T stride_0_0_tmp;\n  int32_T stride_1_0;\n  int32_T stride_1_1;\n  int32_T stride_2_0;\n  int32_T stride_2_1;\n\n  /* Outputs for Atomic SubSystem: '<Root>/custom_scara_fd' */\n  /* MATLAB Function: '<S1>/calcSysMatrices' */\n  in3_size[0] = 6;\n  in3_size[1] = in2 + 1;\n  for (i = 0; i <= in2; i++) {\n    for (in4_tmp = 0; in4_tmp < 6; in4_tmp++) {\n      in3_data[in4_tmp + 6 * i] = in3[6 * i + in4_tmp];\n    }\n  }\n\n  for (i = 0; i < 3; i++) {\n    in4_0[6 * i] = in5[3 * i] * in4;\n    in4_tmp = (i + 3) * 6;\n    in4_0[in4_tmp] = -in6[i];\n    in4_0[6 * i + 3] = in6[3 * i];\n    in4_0[in4_tmp + 3] = in7[3 * i] - in7[i];\n    in4_tmp_0 = 3 * i + 1;\n    in4_0[6 * i + 1] = in5[in4_tmp_0] * in4;\n    in4_0[in4_tmp + 1] = -in6[i + 3];\n    in4_0[6 * i + 4] = in6[in4_tmp_0];\n    in4_0[in4_tmp + 4] = in7[in4_tmp_0] - in7[i + 3];\n    in4_tmp_0 = 3 * i + 2;\n    in4_0[6 * i + 2] = in5[in4_tmp_0] * in4;\n    in4_0[in4_tmp + 2] = -in6[i + 6];\n    in4_0[6 * i + 5] = in6[in4_tmp_0];\n    in4_0[in4_tmp + 5] = in7[in4_tmp_0] - in7[i + 6];\n  }\n\n  in3_size_0[0] = 6;\n  in3_size_0[1] = in2 + 1;\n  for (i = 0; i <= in2; i++) {\n    for (in4_tmp = 0; in4_tmp < 6; in4_tmp++) {\n      in3_data_0[in4_tmp + 6 * i] = in3[6 * i + in4_tmp];\n    }\n  }\n\n  custom_scara_fd_mtimes_mnik(in3_data, in3_size, in4_0, tmp_data_1, tmp_size_0);\n  custom_scara_fd_mtimes_mni(tmp_data_1, tmp_size_0, in3_data_0, in3_size_0,\n    tmp_data, tmp_size);\n  in3_size[0] = 6;\n  in3_size[1] = in2 + 1;\n  for (i = 0; i <= in2; i++) {\n    for (in4_tmp = 0; in4_tmp < 6; in4_tmp++) {\n      in3_data[in4_tmp + 6 * i] = in9[6 * i + in4_tmp];\n    }\n  }\n\n  custom_scara_fd_mtimes_mni(in8_data, in8_size, in3_data, in3_size, tmp_data_0,\n    tmp_size_0);\n  in4_tmp_0 = tmp_size_0[0] == 1 ? tmp_size[0] == 1 ? in2 + 1 : tmp_size[0] :\n    tmp_size_0[0];\n  loop_ub = tmp_size_0[1] == 1 ? tmp_size[1] == 1 ? in2 + 1 : tmp_size[1] :\n    tmp_size_0[1];\n  stride_0_0_tmp = (in2 + 1 != 1);\n  stride_1_0 = (tmp_size[0] != 1);\n  stride_1_1 = (tmp_size[1] != 1);\n  stride_2_0 = (tmp_size_0[0] != 1);\n  stride_2_1 = (tmp_size_0[1] != 1);\n  aux_0_1 = 0;\n  aux_1_1 = 0;\n  aux_2_1 = 0;\n  for (i = 0; i < loop_ub; i++) {\n    for (in4_tmp = 0; in4_tmp < in4_tmp_0; in4_tmp++) {\n      in1_data[in4_tmp + in4_tmp_0 * i] = (in1[in4_tmp * stride_0_0_tmp + 3 *\n        aux_0_1] + tmp_data[in4_tmp * stride_1_0 + tmp_size[0] * aux_1_1]) +\n        tmp_data_0[in4_tmp * stride_2_0 + tmp_size_0[0] * aux_2_1];\n    }\n\n    aux_2_1 += stride_2_1;\n    aux_1_1 += stride_1_1;\n    aux_0_1 += stride_0_0_tmp;\n  }\n\n  for (i = 0; i < loop_ub; i++) {\n    for (in4_tmp = 0; in4_tmp < in4_tmp_0; in4_tmp++) {\n      in1[in4_tmp + 3 * i] = in1_data[in4_tmp_0 * i + in4_tmp];\n    }\n  }\n\n  /* End of MATLAB Function: '<S1>/calcSysMatrices' */\n  /* End of Outputs for SubSystem: '<Root>/custom_scara_fd' */\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes_mnik3(const real_T A_data[], const\n  int32_T A_size[2], const real_T B[9], real_T C_data[], int32_T C_size[2])\n{\n  int32_T m;\n  m = A_size[0];\n  C_size[0] = A_size[0];\n  C_size[1] = 3;\n  for (int32_T j{0}; j < 3; j++) {\n    int32_T coffset;\n    coffset = j * m;\n    for (int32_T i{0}; i < m; i++) {\n      C_data[coffset + i] = (A_data[A_size[0] + i] * B[j + 3] + A_data[i] * B[j])\n        + A_data[(A_size[0] << 1) + i] * B[j + 6];\n    }\n  }\n}\n\n/* Function for MATLAB Function: '<S1>/calcSysMatrices' */\nvoid custom_scara_fd::custom_scara_fd_mtimes_mnik3n(const real_T A_data[], const\n  int32_T A_size[2], real_T C_data[], int32_T *C_size)\n{\n  int32_T b;\n  *C_size = A_size[0];\n  b = A_size[0];\n  for (int32_T i{0}; i < b; i++) {\n    C_data[i] = (A_data[A_size[0] + i] * 0.0 + A_data[i] * 0.0) + A_data\n      [(A_size[0] << 1) + i] * 0.0;\n  }\n}\n\nvoid custom_scara_fd::custom_scara_f_binary_expand_op(real_T in1[3], int32_T in2,\n  const real_T in3_data[], const int32_T in3_size[2], const real_T in4[16])\n{\n  real_T in3_data_0[9];\n  real_T in4_0[9];\n  real_T tmp_data_0[9];\n  real_T in1_data[3];\n  real_T tmp_data[3];\n  int32_T in3_size_0[2];\n  int32_T tmp_size_0[2];\n  int32_T in4_tmp;\n  int32_T stride_0_1;\n  int32_T stride_1_1;\n  int32_T tmp_size;\n\n  /* Outputs for Atomic SubSystem: '<Root>/custom_scara_fd' */\n  /* MATLAB Function: '<S1>/calcSysMatrices' */\n  in3_size_0[0] = in2 + 1;\n  in3_size_0[1] = 3;\n  for (tmp_size = 0; tmp_size < 3; tmp_size++) {\n    for (in4_tmp = 0; in4_tmp <= in2; in4_tmp++) {\n      in3_data_0[in4_tmp + (in2 + 1) * tmp_size] = in3_data[in3_size[0] *\n        tmp_size + in4_tmp];\n    }\n\n    in4_tmp = tmp_size << 2;\n    in4_0[3 * tmp_size] = in4[in4_tmp];\n    in4_0[3 * tmp_size + 1] = in4[in4_tmp + 1];\n    in4_0[3 * tmp_size + 2] = in4[in4_tmp + 2];\n  }\n\n  custom_scara_fd_mtimes_mnik3(in3_data_0, in3_size_0, in4_0, tmp_data_0,\n    tmp_size_0);\n  custom_scara_fd_mtimes_mnik3n(tmp_data_0, tmp_size_0, tmp_data, &tmp_size);\n  in4_tmp = in2 + 1;\n  stride_0_1 = (in2 + 1 != 1);\n  stride_1_1 = (tmp_size != 1);\n  for (tmp_size = 0; tmp_size < in4_tmp; tmp_size++) {\n    in1_data[tmp_size] = in1[tmp_size * stride_0_1] + tmp_data[tmp_size *\n      stride_1_1];\n  }\n\n  if ((in2 + 1) - 1 >= 0) {\n    std::memcpy(&in1[0], &in1_data[0], static_cast<uint32_T>(in2 + 1) * sizeof\n                (real_T));\n  }\n\n  /* End of MATLAB Function: '<S1>/calcSysMatrices' */\n  /* End of Outputs for SubSystem: '<Root>/custom_scara_fd' */\n}\n\nvoid rt_invd3x3_snf(const real_T u[9], real_T y[9])\n{\n  real_T x[9];\n  real_T absx11;\n  real_T absx21;\n  real_T absx31;\n  int32_T p1;\n  int32_T p2;\n  int32_T p3;\n  std::memcpy(&x[0], &u[0], 9U * sizeof(real_T));\n  p1 = 1;\n  p2 = 3;\n  p3 = 6;\n  absx11 = std::abs(u[0]);\n  absx21 = std::abs(u[1]);\n  absx31 = std::abs(u[2]);\n  if ((absx21 > absx11) && (absx21 > absx31)) {\n    p1 = 4;\n    p2 = 0;\n    x[0] = u[1];\n    x[1] = u[0];\n    x[3] = u[4];\n    x[4] = u[3];\n    x[6] = u[7];\n    x[7] = u[6];\n  } else if (absx31 > absx11) {\n    p1 = 7;\n    p3 = 0;\n    x[2] = x[0];\n    x[0] = u[2];\n    x[5] = x[3];\n    x[3] = u[5];\n    x[8] = x[6];\n    x[6] = u[8];\n  }\n\n  absx31 = x[1] / x[0];\n  x[1] = absx31;\n  absx11 = x[2] / x[0];\n  x[2] = absx11;\n  x[4] -= absx31 * x[3];\n  x[5] -= absx11 * x[3];\n  x[7] -= absx31 * x[6];\n  x[8] -= absx11 * x[6];\n  if (std::abs(x[5]) > std::abs(x[4])) {\n    int32_T itmp;\n    itmp = p2;\n    p2 = p3;\n    p3 = itmp;\n    x[1] = absx11;\n    x[2] = absx31;\n    absx11 = x[4];\n    x[4] = x[5];\n    x[5] = absx11;\n    absx11 = x[7];\n    x[7] = x[8];\n    x[8] = absx11;\n  }\n\n  absx31 = x[5] / x[4];\n  x[8] -= absx31 * x[7];\n  absx11 = (x[1] * absx31 - x[2]) / x[8];\n  absx21 = -(x[7] * absx11 + x[1]) / x[4];\n  y[p1 - 1] = ((1.0 - x[3] * absx21) - x[6] * absx11) / x[0];\n  y[p1] = absx21;\n  y[p1 + 1] = absx11;\n  absx11 = -absx31 / x[8];\n  absx21 = (1.0 - x[7] * absx11) / x[4];\n  y[p2] = -(x[3] * absx21 + x[6] * absx11) / x[0];\n  y[p2 + 1] = absx21;\n  y[p2 + 2] = absx11;\n  absx11 = 1.0 / x[8];\n  absx21 = -x[7] * absx11 / x[4];\n  y[p3] = -(x[3] * absx21 + x[6] * absx11) / x[0];\n  y[p3 + 1] = absx21;\n  y[p3 + 2] = absx11;\n}\n\n/* Model step function */\nvoid custom_scara_fd::step()\n{\n  {\n    static const int8_T c_b[9]{ 1, 0, 0, 0, 1, 0, 0, 0, 1 };\n\n    real_T ROBOT_Mass[108];\n    real_T ROBOT_Mass_data[108];\n    real_T Htm_data[48];\n    real_T ROBOT_g0[48];\n    real_T ROBOT_g0_data[48];\n    real_T invAd[36];\n    real_T m_0[36];\n    real_T m_1[36];\n    real_T m_2[36];\n    real_T J[18];\n    real_T J_data[18];\n    real_T J_data_0[18];\n    real_T J_data_1[18];\n    real_T J_data_2[18];\n    real_T J_data_3[18];\n    real_T J_data_4[18];\n    real_T J_data_5[18];\n    real_T J_pre[18];\n    real_T ROBOT_csi[18];\n    real_T dJ[18];\n    real_T dJ_data[18];\n    real_T dJ_data_0[18];\n    real_T dJ_pre[18];\n    real_T tmp_data_1[18];\n    real_T O_Htm[16];\n    real_T O_Htm_0[16];\n    real_T O_Htm_pre[16];\n    real_T J_pre_data[12];\n    real_T dJ_pre_data[12];\n    real_T tmp_data[12];\n    real_T E_tmp[9];\n    real_T S[9];\n    real_T b_I[9];\n    real_T b_I_0[9];\n    real_T b_S[9];\n    real_T b_tmp[9];\n    real_T b_y[9];\n    real_T c_S[9];\n    real_T c_y[9];\n    real_T d_y[9];\n    real_T jointOrigins[9];\n    real_T rtb_CC[9];\n    real_T tmp[9];\n    real_T tmp2[9];\n    real_T tmp2_0[9];\n    real_T tmp_0[9];\n    real_T inertialTwist[6];\n    real_T inertialTwist_pre[6];\n    real_T relTwist[6];\n    real_T rtb_g[3];\n    real_T rtb_g_data[3];\n    real_T tmp_data_0[3];\n    real_T (*lastU)[3];\n    real_T Iz;\n    real_T ROBOT_Mass_0;\n    real_T b_m;\n    real_T b_tmp_0;\n    real_T c_m;\n    real_T m;\n    real_T m_tmp;\n    real_T m_tmp_0;\n    real_T tmp2_1;\n    int32_T Htm_size[2];\n    int32_T J_pre_size[2];\n    int32_T J_size[2];\n    int32_T J_size_0[2];\n    int32_T J_size_1[2];\n    int32_T J_size_2[2];\n    int32_T J_size_3[2];\n    int32_T J_size_4[2];\n    int32_T J_size_5[2];\n    int32_T J_size_6[2];\n    int32_T ROBOT_Mass_size[2];\n    int32_T ROBOT_g0_size[2];\n    int32_T dJ_pre_size[2];\n    int32_T dJ_size[2];\n    int32_T dJ_size_0[2];\n    int32_T tmp_size[2];\n    int32_T tmp_size_0[2];\n    int32_T tmp_size_1[2];\n    int32_T tmp_size_2[2];\n    int32_T tmp_size_3[2];\n    int32_T tmp_size_4[2];\n    int32_T tmp_size_5[2];\n    int32_T O_Htm_tmp;\n    int32_T O_Htm_tmp_0;\n    int32_T i;\n    int32_T idxStart_4Row;\n    int32_T idxStart_6Row;\n    int32_T rtb_CC_0;\n    boolean_T ROBOT_csi_0[3];\n\n    /* Outputs for Atomic SubSystem: '<Root>/custom_scara_fd' */\n    /* MATLAB Function: '<S1>/calcSysMatrices' incorporates:\n     *  Derivative: '<S1>/Derivative1'\n     *  Inport: '<Root>/arm_length'\n     *  Inport: '<Root>/arm_link_radius'\n     *  Inport: '<Root>/dq'\n     *  Inport: '<Root>/q'\n     *  Inport: '<Root>/rho'\n     */\n    custom_scara_fd_eye(E_tmp);\n    jointOrigins[0] = 0.0;\n    jointOrigins[3] = custom_scara_fd_U.arm_length[0];\n    jointOrigins[6] = custom_scara_fd_U.arm_length[1];\n    m_tmp = custom_scara_fd_U.arm_link_radius *\n      custom_scara_fd_U.arm_link_radius;\n    m_tmp_0 = m_tmp * 3.1415926535897931;\n    m = m_tmp_0 * custom_scara_fd_U.arm_length[0] * custom_scara_fd_U.rho;\n    rtb_g[0] = custom_scara_fd_U.arm_length[0] / 2.0;\n    Iz = 0.25 * m * m_tmp + 0.083333333333333329 * m *\n      (custom_scara_fd_U.arm_length[0] * custom_scara_fd_U.arm_length[0]);\n    b_m = m;\n    inertialTwist_pre[0] = 0.5 * m * m_tmp;\n    inertialTwist_pre[1] = Iz;\n    inertialTwist_pre[2] = Iz;\n    inertialTwist_pre[3] = 0.0;\n    inertialTwist_pre[4] = 0.0;\n    inertialTwist_pre[5] = 0.0;\n    custom_scara_fd_diag(&inertialTwist_pre[0], tmp2);\n    jointOrigins[1] = 0.0;\n    jointOrigins[2] = 0.0;\n    S[0] = 0.0;\n    jointOrigins[4] = 0.0;\n    jointOrigins[5] = 0.0;\n    S[3] = 0.0;\n    jointOrigins[7] = 0.0;\n    jointOrigins[8] = 0.0;\n    S[6] = 0.0;\n    S[1] = 0.0;\n    S[4] = 0.0;\n    S[7] = -rtb_g[0];\n    S[2] = -0.0;\n    S[5] = rtb_g[0];\n    S[8] = 0.0;\n    for (i = 0; i < 9; i++) {\n      rtb_CC_0 = c_b[i];\n      rtb_CC[i] = rtb_CC_0;\n      b_tmp[i] = m * static_cast<real_T>(rtb_CC_0);\n      b_y[i] = m * S[i];\n    }\n\n    m = m_tmp_0 * custom_scara_fd_U.arm_length[1] * custom_scara_fd_U.rho;\n    rtb_g[0] = custom_scara_fd_U.arm_length[1] / 2.0;\n    Iz = 0.25 * m * m_tmp + 0.083333333333333329 * m *\n      (custom_scara_fd_U.arm_length[1] * custom_scara_fd_U.arm_length[1]);\n    c_m = m;\n    inertialTwist_pre[0] = 0.5 * m * m_tmp;\n    inertialTwist_pre[1] = Iz;\n    inertialTwist_pre[2] = Iz;\n    inertialTwist_pre[3] = 0.0;\n    inertialTwist_pre[4] = 0.0;\n    inertialTwist_pre[5] = 0.0;\n    custom_scara_fd_diag(&inertialTwist_pre[0], b_I);\n    b_S[0] = 0.0;\n    b_S[3] = 0.0;\n    b_S[6] = 0.0;\n    b_S[1] = 0.0;\n    b_S[4] = 0.0;\n    b_S[7] = -rtb_g[0];\n    b_S[2] = -0.0;\n    b_S[5] = rtb_g[0];\n    b_S[8] = 0.0;\n    for (i = 0; i < 9; i++) {\n      c_y[i] = m * rtb_CC[i];\n      d_y[i] = m * b_S[i];\n    }\n\n    m = m_tmp_0 * custom_scara_fd_U.arm_length[2] * custom_scara_fd_U.rho;\n    rtb_g[0] = custom_scara_fd_U.arm_length[2] / 2.0;\n    Iz = 0.25 * m * m_tmp + 0.083333333333333329 * m *\n      (custom_scara_fd_U.arm_length[2] * custom_scara_fd_U.arm_length[2]);\n    c_S[0] = 0.0;\n    c_S[3] = 0.0;\n    c_S[6] = 0.0;\n    c_S[1] = 0.0;\n    c_S[4] = 0.0;\n    c_S[7] = -rtb_g[0];\n    c_S[2] = -0.0;\n    c_S[5] = rtb_g[0];\n    c_S[8] = 0.0;\n    custom_scara_fd_repmat(ROBOT_csi);\n    for (i = 0; i < 3; i++) {\n      ROBOT_g0[12 * i] = E_tmp[3 * i];\n      ROBOT_g0[12 * i + 1] = E_tmp[3 * i + 1];\n      ROBOT_g0[12 * i + 2] = E_tmp[3 * i + 2];\n      ROBOT_g0[i + 36] = 0.0;\n    }\n\n    ROBOT_g0[3] = 0.0;\n    ROBOT_g0[15] = 0.0;\n    ROBOT_g0[27] = 0.0;\n    ROBOT_g0[39] = 1.0;\n    for (i = 0; i < 3; i++) {\n      ROBOT_g0[12 * i + 4] = E_tmp[3 * i];\n      ROBOT_g0[12 * i + 5] = E_tmp[3 * i + 1];\n      ROBOT_g0[12 * i + 6] = E_tmp[3 * i + 2];\n      ROBOT_g0[i + 40] = jointOrigins[i + 3];\n    }\n\n    ROBOT_g0[7] = 0.0;\n    ROBOT_g0[19] = 0.0;\n    ROBOT_g0[31] = 0.0;\n    ROBOT_g0[43] = 1.0;\n    for (i = 0; i < 3; i++) {\n      ROBOT_g0[12 * i + 8] = E_tmp[3 * i];\n      ROBOT_g0[12 * i + 9] = E_tmp[3 * i + 1];\n      ROBOT_g0[12 * i + 10] = E_tmp[3 * i + 2];\n      ROBOT_g0[i + 44] = jointOrigins[i + 6];\n    }\n\n    ROBOT_g0[11] = 0.0;\n    ROBOT_g0[23] = 0.0;\n    ROBOT_g0[35] = 0.0;\n    ROBOT_g0[47] = 1.0;\n    for (i = 0; i < 9; i++) {\n      jointOrigins[i] = m * c_S[i];\n    }\n\n    inertialTwist_pre[0] = 0.5 * m * m_tmp;\n    inertialTwist_pre[1] = Iz;\n    inertialTwist_pre[2] = Iz;\n    inertialTwist_pre[3] = 0.0;\n    inertialTwist_pre[4] = 0.0;\n    inertialTwist_pre[5] = 0.0;\n    custom_scara_fd_diag(&inertialTwist_pre[0], tmp);\n    for (i = 0; i < 3; i++) {\n      m_tmp = jointOrigins[i + 3];\n      m_tmp_0 = jointOrigins[i];\n      Iz = jointOrigins[i + 6];\n      for (O_Htm_tmp = 0; O_Htm_tmp < 3; O_Htm_tmp++) {\n        idxStart_4Row = 3 * O_Htm_tmp + i;\n        rtb_CC_0 = 3 * O_Htm_tmp + 1;\n        idxStart_6Row = 3 * O_Htm_tmp + 2;\n        tmp2_0[idxStart_4Row] = tmp2[idxStart_4Row] - ((S[i + 3] * b_m *\n          S[rtb_CC_0] + b_m * S[i] * S[3 * O_Htm_tmp]) + S[i + 6] * b_m *\n          S[idxStart_6Row]);\n        b_I_0[idxStart_4Row] = b_I[idxStart_4Row] - ((b_S[i + 3] * c_m *\n          b_S[rtb_CC_0] + c_m * b_S[i] * b_S[3 * O_Htm_tmp]) + b_S[i + 6] * c_m *\n          b_S[idxStart_6Row]);\n        tmp_0[idxStart_4Row] = tmp[idxStart_4Row] - ((c_S[3 * O_Htm_tmp] *\n          m_tmp_0 + c_S[rtb_CC_0] * m_tmp) + c_S[idxStart_6Row] * Iz);\n        idxStart_4Row = 3 * i + O_Htm_tmp;\n        rtb_CC_0 = 18 * i + O_Htm_tmp;\n        ROBOT_Mass[rtb_CC_0] = b_tmp[idxStart_4Row];\n        ROBOT_Mass[O_Htm_tmp + 18 * (i + 3)] = S[idxStart_4Row] * -b_m;\n        ROBOT_Mass[rtb_CC_0 + 3] = b_y[idxStart_4Row];\n      }\n    }\n\n    for (i = 0; i < 3; i++) {\n      idxStart_4Row = (i + 3) * 18;\n      ROBOT_Mass[idxStart_4Row + 3] = tmp2_0[3 * i];\n      ROBOT_Mass[18 * i + 6] = c_y[3 * i];\n      ROBOT_Mass[idxStart_4Row + 6] = b_S[3 * i] * -c_m;\n      ROBOT_Mass[18 * i + 9] = d_y[3 * i];\n      ROBOT_Mass[idxStart_4Row + 9] = b_I_0[3 * i];\n      ROBOT_Mass[18 * i + 12] = rtb_CC[3 * i] * m;\n      ROBOT_Mass[idxStart_4Row + 12] = c_S[3 * i] * -m;\n      ROBOT_Mass[18 * i + 15] = jointOrigins[3 * i];\n      ROBOT_Mass[idxStart_4Row + 15] = tmp_0[3 * i];\n      rtb_CC_0 = 3 * i + 1;\n      ROBOT_Mass[idxStart_4Row + 4] = tmp2_0[rtb_CC_0];\n      ROBOT_Mass[18 * i + 7] = c_y[rtb_CC_0];\n      ROBOT_Mass[idxStart_4Row + 7] = b_S[rtb_CC_0] * -c_m;\n      ROBOT_Mass[18 * i + 10] = d_y[rtb_CC_0];\n      ROBOT_Mass[idxStart_4Row + 10] = b_I_0[rtb_CC_0];\n      ROBOT_Mass[18 * i + 13] = rtb_CC[rtb_CC_0] * m;\n      ROBOT_Mass[idxStart_4Row + 13] = c_S[rtb_CC_0] * -m;\n      ROBOT_Mass[18 * i + 16] = jointOrigins[rtb_CC_0];\n      ROBOT_Mass[idxStart_4Row + 16] = tmp_0[rtb_CC_0];\n      rtb_CC_0 = 3 * i + 2;\n      ROBOT_Mass[idxStart_4Row + 5] = tmp2_0[rtb_CC_0];\n      ROBOT_Mass[18 * i + 8] = c_y[rtb_CC_0];\n      ROBOT_Mass[idxStart_4Row + 8] = b_S[rtb_CC_0] * -c_m;\n      ROBOT_Mass[18 * i + 11] = d_y[rtb_CC_0];\n      ROBOT_Mass[idxStart_4Row + 11] = b_I_0[rtb_CC_0];\n      ROBOT_Mass[18 * i + 14] = rtb_CC[rtb_CC_0] * m;\n      ROBOT_Mass[idxStart_4Row + 14] = c_S[rtb_CC_0] * -m;\n      ROBOT_Mass[18 * i + 17] = jointOrigins[rtb_CC_0];\n      ROBOT_Mass[idxStart_4Row + 17] = tmp_0[rtb_CC_0];\n    }\n\n    std::memset(&S[0], 0, 9U * sizeof(real_T));\n    std::memset(&rtb_CC[0], 0, 9U * sizeof(real_T));\n    rtb_g[0] = 0.0;\n    rtb_g[1] = 0.0;\n    rtb_g[2] = 0.0;\n    std::memset(&J_pre[0], 0, 18U * sizeof(real_T));\n    std::memset(&dJ_pre[0], 0, 18U * sizeof(real_T));\n    for (i = 0; i < 6; i++) {\n      inertialTwist_pre[i] = 0.0;\n    }\n\n    std::memset(&O_Htm_pre[0], 0, sizeof(real_T) << 4U);\n    O_Htm_pre[0] = 1.0;\n    O_Htm_pre[5] = 1.0;\n    O_Htm_pre[10] = 1.0;\n    O_Htm_pre[15] = 1.0;\n    tmp[0] = 0.0;\n    tmp[4] = 0.0;\n    tmp[8] = 0.0;\n    for (rtb_CC_0 = 0; rtb_CC_0 < 3; rtb_CC_0++) {\n      idxStart_4Row = rtb_CC_0 << 2;\n      idxStart_6Row = 6 * rtb_CC_0;\n      m_tmp = custom_scara_fd_U.joint_vel[rtb_CC_0];\n      for (i = 0; i < 6; i++) {\n        relTwist[i] = ROBOT_csi[idxStart_6Row + i] * m_tmp;\n      }\n\n      m_tmp = ROBOT_csi[idxStart_6Row + 3];\n      ROBOT_csi_0[0] = (m_tmp == 0.0);\n      m = ROBOT_csi[idxStart_6Row + 4];\n      ROBOT_csi_0[1] = (m == 0.0);\n      b_m = ROBOT_csi[idxStart_6Row + 5];\n      ROBOT_csi_0[2] = (b_m == 0.0);\n      if (custom_scara_fd_all(ROBOT_csi_0)) {\n        m_tmp = custom_scara_fd_U.joint_pos[rtb_CC_0];\n        for (i = 0; i < 3; i++) {\n          O_Htm_tmp_0 = i << 2;\n          O_Htm[O_Htm_tmp_0] = E_tmp[3 * i];\n          O_Htm[O_Htm_tmp_0 + 1] = E_tmp[3 * i + 1];\n          O_Htm[O_Htm_tmp_0 + 2] = E_tmp[3 * i + 2];\n          O_Htm[i + 12] = ROBOT_csi[idxStart_6Row + i] * m_tmp;\n        }\n\n        O_Htm[3] = 0.0;\n        O_Htm[7] = 0.0;\n        O_Htm[11] = 0.0;\n        O_Htm[15] = 1.0;\n      } else {\n        jointOrigins[0] = 0.0;\n        jointOrigins[3] = -b_m;\n        jointOrigins[6] = m;\n        jointOrigins[1] = b_m;\n        jointOrigins[4] = 0.0;\n        jointOrigins[7] = -m_tmp;\n        jointOrigins[2] = -m;\n        jointOrigins[5] = m_tmp;\n        jointOrigins[8] = 0.0;\n        m = std::sin(custom_scara_fd_U.joint_pos[rtb_CC_0]);\n        Iz = std::cos(custom_scara_fd_U.joint_pos[rtb_CC_0]);\n        for (i = 0; i < 3; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 3; O_Htm_tmp++) {\n            tmp2[i + 3 * O_Htm_tmp] = (jointOrigins[3 * O_Htm_tmp + 1] *\n              jointOrigins[i + 3] + jointOrigins[3 * O_Htm_tmp] * jointOrigins[i])\n              + jointOrigins[3 * O_Htm_tmp + 2] * jointOrigins[i + 6];\n          }\n        }\n\n        for (i = 0; i < 3; i++) {\n          O_Htm_tmp_0 = i << 2;\n          O_Htm[O_Htm_tmp_0] = (jointOrigins[3 * i] * m + tmp2[3 * i] * (1.0 -\n            Iz)) + E_tmp[3 * i];\n          O_Htm_tmp = 3 * i + 1;\n          O_Htm[O_Htm_tmp_0 + 1] = ((1.0 - Iz) * tmp2[O_Htm_tmp] +\n            jointOrigins[O_Htm_tmp] * m) + E_tmp[O_Htm_tmp];\n          O_Htm_tmp = 3 * i + 2;\n          O_Htm[O_Htm_tmp_0 + 2] = ((1.0 - Iz) * tmp2[O_Htm_tmp] +\n            jointOrigins[O_Htm_tmp] * m) + E_tmp[O_Htm_tmp];\n          O_Htm[i + 12] = 0.0;\n        }\n\n        O_Htm[3] = 0.0;\n        O_Htm[7] = 0.0;\n        O_Htm[11] = 0.0;\n        O_Htm[15] = 1.0;\n      }\n\n      ROBOT_g0_size[0] = 4;\n      ROBOT_g0_size[1] = 4;\n      for (i = 0; i < 4; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 4; O_Htm_tmp++) {\n          ROBOT_g0_data[O_Htm_tmp + (i << 2)] = ROBOT_g0[(idxStart_4Row +\n            O_Htm_tmp) + 12 * i];\n        }\n      }\n\n      custom_scara_fd_mtimes(ROBOT_g0_data, ROBOT_g0_size, O_Htm, Htm_data,\n        Htm_size);\n      for (i = 0; i < 4; i++) {\n        m_tmp = O_Htm_pre[i + 4];\n        m = O_Htm_pre[i];\n        b_m = O_Htm_pre[i + 8];\n        c_m = O_Htm_pre[i + 12];\n        for (O_Htm_tmp = 0; O_Htm_tmp < 4; O_Htm_tmp++) {\n          O_Htm_tmp_0 = O_Htm_tmp << 2;\n          O_Htm[i + O_Htm_tmp_0] = ((Htm_data[O_Htm_tmp_0 + 1] * m_tmp +\n            Htm_data[O_Htm_tmp_0] * m) + Htm_data[O_Htm_tmp_0 + 2] * b_m) +\n            Htm_data[O_Htm_tmp_0 + 3] * c_m;\n        }\n      }\n\n      for (i = 0; i < 6; i++) {\n        inertialTwist[i] = relTwist[i];\n      }\n\n      for (i = 0; i < 3; i++) {\n        jointOrigins[3 * i] = Htm_data[i];\n        jointOrigins[3 * i + 1] = Htm_data[i + Htm_size[0]];\n        jointOrigins[3 * i + 2] = Htm_data[(Htm_size[0] << 1) + i];\n      }\n\n      for (i = 0; i < 9; i++) {\n        tmp2[i] = -jointOrigins[i];\n      }\n\n      m_tmp = Htm_data[Htm_size[0] * 3 + 2];\n      tmp[3] = -m_tmp;\n      m_tmp_0 = Htm_data[Htm_size[0] * 3 + 1];\n      tmp[6] = m_tmp_0;\n      tmp[1] = m_tmp;\n      m_tmp = Htm_data[Htm_size[0] * 3];\n      tmp[7] = -m_tmp;\n      tmp[2] = -m_tmp_0;\n      tmp[5] = m_tmp;\n      for (i = 0; i < 3; i++) {\n        m_tmp = tmp2[i + 3];\n        m_tmp_0 = tmp2[i];\n        Iz = tmp2[i + 6];\n        for (O_Htm_tmp = 0; O_Htm_tmp < 3; O_Htm_tmp++) {\n          b_tmp[i + 3 * O_Htm_tmp] = (tmp[3 * O_Htm_tmp + 1] * m_tmp + tmp[3 *\n            O_Htm_tmp] * m_tmp_0) + tmp[3 * O_Htm_tmp + 2] * Iz;\n          invAd[O_Htm_tmp + 6 * i] = jointOrigins[3 * i + O_Htm_tmp];\n        }\n      }\n\n      for (i = 0; i < 3; i++) {\n        O_Htm_tmp = (i + 3) * 6;\n        invAd[O_Htm_tmp] = b_tmp[3 * i];\n        invAd[6 * i + 3] = 0.0;\n        invAd[O_Htm_tmp + 3] = jointOrigins[3 * i];\n        idxStart_4Row = 3 * i + 1;\n        invAd[O_Htm_tmp + 1] = b_tmp[idxStart_4Row];\n        invAd[6 * i + 4] = 0.0;\n        invAd[O_Htm_tmp + 4] = jointOrigins[idxStart_4Row];\n        idxStart_4Row = 3 * i + 2;\n        invAd[O_Htm_tmp + 2] = b_tmp[idxStart_4Row];\n        invAd[6 * i + 5] = 0.0;\n        invAd[O_Htm_tmp + 5] = jointOrigins[idxStart_4Row];\n      }\n\n      std::memset(&J[0], 0, 18U * sizeof(real_T));\n      std::memset(&dJ[0], 0, 18U * sizeof(real_T));\n      if (rtb_CC_0 + 1 > 1) {\n        for (i = 0; i < 6; i++) {\n          m_tmp = 0.0;\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            m_tmp += invAd[6 * O_Htm_tmp + i] * inertialTwist_pre[O_Htm_tmp];\n          }\n\n          inertialTwist[i] = relTwist[i] + m_tmp;\n        }\n\n        J_pre_size[0] = 6;\n        J_pre_size[1] = rtb_CC_0;\n        for (i = 0; i < rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            J_pre_data[O_Htm_tmp + 6 * i] = J_pre[6 * i + O_Htm_tmp];\n          }\n        }\n\n        custom_scara_fd_mtimes_m(invAd, J_pre_data, J_pre_size, tmp_data,\n          Htm_size);\n        idxStart_4Row = Htm_size[1];\n        for (i = 0; i < idxStart_4Row; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            J[O_Htm_tmp + 6 * i] = tmp_data[6 * i + O_Htm_tmp];\n          }\n        }\n\n        jointOrigins[0] = 0.0;\n        jointOrigins[3] = -relTwist[5];\n        jointOrigins[6] = relTwist[4];\n        jointOrigins[1] = relTwist[5];\n        jointOrigins[4] = 0.0;\n        jointOrigins[7] = -relTwist[3];\n        jointOrigins[2] = -relTwist[4];\n        jointOrigins[5] = relTwist[3];\n        jointOrigins[8] = 0.0;\n        dJ_pre_size[0] = 6;\n        dJ_pre_size[1] = rtb_CC_0;\n        for (i = 0; i < rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            dJ_pre_data[O_Htm_tmp + 6 * i] = dJ_pre[6 * i + O_Htm_tmp];\n          }\n        }\n\n        m_0[18] = 0.0;\n        m_0[24] = -relTwist[2];\n        m_0[30] = relTwist[1];\n        m_0[19] = relTwist[2];\n        m_0[25] = 0.0;\n        m_0[31] = -relTwist[0];\n        m_0[20] = -relTwist[1];\n        m_0[26] = relTwist[0];\n        m_0[32] = 0.0;\n        for (i = 0; i < 3; i++) {\n          m_tmp = jointOrigins[3 * i];\n          m_0[6 * i] = m_tmp;\n          m_0[6 * i + 3] = 0.0;\n          O_Htm_tmp = (i + 3) * 6;\n          m_0[O_Htm_tmp + 3] = m_tmp;\n          m_tmp = jointOrigins[3 * i + 1];\n          m_0[6 * i + 1] = m_tmp;\n          m_0[6 * i + 4] = 0.0;\n          m_0[O_Htm_tmp + 4] = m_tmp;\n          m_tmp = jointOrigins[3 * i + 2];\n          m_0[6 * i + 2] = m_tmp;\n          m_0[6 * i + 5] = 0.0;\n          m_0[O_Htm_tmp + 5] = m_tmp;\n        }\n\n        J_pre_size[0] = 6;\n        J_pre_size[1] = rtb_CC_0;\n        for (i = 0; i < rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            J_pre_data[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n          }\n        }\n\n        custom_scara_fd_mtimes_m(invAd, dJ_pre_data, dJ_pre_size, tmp_data,\n          Htm_size);\n        custom_scara_fd_mtimes_m(m_0, J_pre_data, J_pre_size, tmp_data,\n          tmp_size_5);\n        if (Htm_size[1] == tmp_size_5[1]) {\n          dJ_pre_size[0] = 6;\n          dJ_pre_size[1] = rtb_CC_0;\n          for (i = 0; i < rtb_CC_0; i++) {\n            for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n              dJ_pre_data[O_Htm_tmp + 6 * i] = dJ_pre[6 * i + O_Htm_tmp];\n            }\n          }\n\n          custom_scara_fd_mtimes_m(invAd, dJ_pre_data, dJ_pre_size, tmp_data,\n            Htm_size);\n          m_0[18] = 0.0;\n          m_0[24] = -relTwist[2];\n          m_0[30] = relTwist[1];\n          m_0[19] = relTwist[2];\n          m_0[25] = 0.0;\n          m_0[31] = -relTwist[0];\n          m_0[20] = -relTwist[1];\n          m_0[26] = relTwist[0];\n          m_0[32] = 0.0;\n          for (i = 0; i < 3; i++) {\n            m_tmp = jointOrigins[3 * i];\n            m_0[6 * i] = m_tmp;\n            m_0[6 * i + 3] = 0.0;\n            O_Htm_tmp = (i + 3) * 6;\n            m_0[O_Htm_tmp + 3] = m_tmp;\n            m_tmp = jointOrigins[3 * i + 1];\n            m_0[6 * i + 1] = m_tmp;\n            m_0[6 * i + 4] = 0.0;\n            m_0[O_Htm_tmp + 4] = m_tmp;\n            m_tmp = jointOrigins[3 * i + 2];\n            m_0[6 * i + 2] = m_tmp;\n            m_0[6 * i + 5] = 0.0;\n            m_0[O_Htm_tmp + 5] = m_tmp;\n          }\n\n          J_pre_size[0] = 6;\n          J_pre_size[1] = rtb_CC_0;\n          for (i = 0; i < rtb_CC_0; i++) {\n            for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n              J_pre_data[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n            }\n          }\n\n          custom_scara_fd_mtimes_m(m_0, J_pre_data, J_pre_size, dJ_pre_data,\n            dJ_pre_size);\n          idxStart_4Row = Htm_size[1];\n          for (i = 0; i < idxStart_4Row; i++) {\n            for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n              O_Htm_tmp_0 = 6 * i + O_Htm_tmp;\n              dJ[O_Htm_tmp_0] = tmp_data[O_Htm_tmp_0] - dJ_pre_data[O_Htm_tmp_0];\n            }\n          }\n        } else {\n          custom_sca_binary_expand_op_ih2(dJ, rtb_CC_0, invAd, dJ_pre,\n            jointOrigins, relTwist, J);\n        }\n      }\n\n      for (i = 0; i < 6; i++) {\n        J[i + 6 * rtb_CC_0] = ROBOT_csi[idxStart_6Row + i];\n      }\n\n      J_size[0] = 6;\n      J_size[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          J_pre[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n        }\n      }\n\n      ROBOT_Mass_size[0] = 6;\n      ROBOT_Mass_size[1] = 6;\n      for (i = 0; i < 6; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          ROBOT_Mass_data[O_Htm_tmp + 6 * i] = ROBOT_Mass[(idxStart_6Row +\n            O_Htm_tmp) + 18 * i];\n        }\n      }\n\n      custom_scara_fd_mtimes_mn(J_pre, J_size, ROBOT_Mass_data, ROBOT_Mass_size,\n        dJ_pre, Htm_size);\n      J_size[0] = 6;\n      J_size[1] = rtb_CC_0 + 1;\n      J_size_0[0] = 6;\n      J_size_0[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          idxStart_4Row = 6 * i + O_Htm_tmp;\n          m_tmp = J[idxStart_4Row];\n          J_pre[idxStart_4Row] = m_tmp;\n          J_data[idxStart_4Row] = m_tmp;\n        }\n      }\n\n      custom_scara_fd_mtimes_mni(dJ_pre, Htm_size, J_pre, J_size, b_y,\n        tmp_size_5);\n      custom_scara_fd_mtimes_mni(dJ_pre, Htm_size, J_data, J_size_0, b_y,\n        tmp_size_4);\n      if ((rtb_CC_0 + 1 == tmp_size_5[0]) && (rtb_CC_0 + 1 == tmp_size_4[1])) {\n        J_size[0] = 6;\n        J_size[1] = rtb_CC_0 + 1;\n        for (i = 0; i <= rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            J_pre[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n          }\n        }\n\n        custom_scara_fd_mtimes_mni(dJ_pre, Htm_size, J_pre, J_size, b_y,\n          tmp_size_5);\n        for (i = 0; i <= rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp <= rtb_CC_0; O_Htm_tmp++) {\n            jointOrigins[O_Htm_tmp + (rtb_CC_0 + 1) * i] = S[3 * i + O_Htm_tmp]\n              + b_y[tmp_size_5[0] * i + O_Htm_tmp];\n          }\n        }\n\n        idxStart_4Row = rtb_CC_0 + 1;\n        O_Htm_tmp_0 = rtb_CC_0 + 1;\n        for (i = 0; i < idxStart_4Row; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < O_Htm_tmp_0; O_Htm_tmp++) {\n            S[O_Htm_tmp + 3 * i] = jointOrigins[(rtb_CC_0 + 1) * i + O_Htm_tmp];\n          }\n        }\n      } else {\n        custom_scar_binary_expand_op_ih(S, rtb_CC_0, dJ_pre, Htm_size, J);\n      }\n\n      jointOrigins[0] = 0.0;\n      jointOrigins[3] = -inertialTwist[5];\n      jointOrigins[6] = inertialTwist[4];\n      jointOrigins[1] = inertialTwist[5];\n      jointOrigins[4] = 0.0;\n      jointOrigins[7] = -inertialTwist[3];\n      jointOrigins[2] = -inertialTwist[4];\n      jointOrigins[5] = inertialTwist[3];\n      jointOrigins[8] = 0.0;\n      for (i = 0; i < 3; i++) {\n        idxStart_4Row = idxStart_6Row + i;\n        m = ROBOT_Mass[idxStart_4Row + 3];\n        b_m = ROBOT_Mass[idxStart_4Row + 57];\n        c_m = ROBOT_Mass[idxStart_4Row + 21];\n        m_tmp_0 = ROBOT_Mass[idxStart_4Row + 75];\n        Iz = ROBOT_Mass[idxStart_4Row + 93];\n        ROBOT_Mass_0 = ROBOT_Mass[idxStart_4Row + 39];\n        for (O_Htm_tmp = 0; O_Htm_tmp < 3; O_Htm_tmp++) {\n          m_tmp = jointOrigins[3 * O_Htm_tmp];\n          b_tmp_0 = m * m_tmp;\n          tmp2_1 = b_m * m_tmp;\n          m_tmp = jointOrigins[3 * O_Htm_tmp + 1];\n          b_tmp_0 += c_m * m_tmp;\n          tmp2_1 += m_tmp_0 * m_tmp;\n          m_tmp = jointOrigins[3 * O_Htm_tmp + 2];\n          idxStart_4Row = 3 * O_Htm_tmp + i;\n          tmp2[idxStart_4Row] = Iz * m_tmp + tmp2_1;\n          b_tmp[idxStart_4Row] = ROBOT_Mass_0 * m_tmp + b_tmp_0;\n        }\n      }\n\n      m = ROBOT_Mass[idxStart_6Row];\n      J_size[0] = 6;\n      J_size[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          J_pre[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n        }\n      }\n\n      for (i = 0; i < 3; i++) {\n        invAd[6 * i] = jointOrigins[3 * i] * m;\n        O_Htm_tmp = (i + 3) * 6;\n        invAd[O_Htm_tmp] = -b_tmp[i];\n        invAd[6 * i + 3] = b_tmp[3 * i];\n        invAd[O_Htm_tmp + 3] = tmp2[3 * i] - tmp2[i];\n        idxStart_6Row = 3 * i + 1;\n        invAd[6 * i + 1] = jointOrigins[idxStart_6Row] * m;\n        invAd[O_Htm_tmp + 1] = -b_tmp[i + 3];\n        invAd[6 * i + 4] = b_tmp[idxStart_6Row];\n        invAd[O_Htm_tmp + 4] = tmp2[idxStart_6Row] - tmp2[i + 3];\n        idxStart_6Row = 3 * i + 2;\n        invAd[6 * i + 2] = jointOrigins[idxStart_6Row] * m;\n        invAd[O_Htm_tmp + 2] = -b_tmp[i + 6];\n        invAd[6 * i + 5] = b_tmp[idxStart_6Row];\n        invAd[O_Htm_tmp + 5] = tmp2[idxStart_6Row] - tmp2[i + 6];\n      }\n\n      J_size_0[0] = 6;\n      J_size_0[1] = rtb_CC_0 + 1;\n      J_size_1[0] = 6;\n      J_size_1[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          idxStart_4Row = 6 * i + O_Htm_tmp;\n          m_tmp = J[idxStart_4Row];\n          J_data[idxStart_4Row] = m_tmp;\n          J_data_0[O_Htm_tmp + 6 * i] = m_tmp;\n        }\n      }\n\n      for (i = 0; i < 3; i++) {\n        m_0[6 * i] = jointOrigins[3 * i] * m;\n        O_Htm_tmp = (i + 3) * 6;\n        m_0[O_Htm_tmp] = -b_tmp[i];\n        m_0[6 * i + 3] = b_tmp[3 * i];\n        m_0[O_Htm_tmp + 3] = tmp2[3 * i] - tmp2[i];\n        idxStart_6Row = 3 * i + 1;\n        m_0[6 * i + 1] = jointOrigins[idxStart_6Row] * m;\n        m_0[O_Htm_tmp + 1] = -b_tmp[i + 3];\n        m_0[6 * i + 4] = b_tmp[idxStart_6Row];\n        m_0[O_Htm_tmp + 4] = tmp2[idxStart_6Row] - tmp2[i + 3];\n        idxStart_6Row = 3 * i + 2;\n        m_0[6 * i + 2] = jointOrigins[idxStart_6Row] * m;\n        m_0[O_Htm_tmp + 2] = -b_tmp[i + 6];\n        m_0[6 * i + 5] = b_tmp[idxStart_6Row];\n        m_0[O_Htm_tmp + 5] = tmp2[idxStart_6Row] - tmp2[i + 6];\n      }\n\n      J_size_2[0] = 6;\n      J_size_2[1] = rtb_CC_0 + 1;\n      J_size_3[0] = 6;\n      J_size_3[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          idxStart_4Row = 6 * i + O_Htm_tmp;\n          m_tmp = J[idxStart_4Row];\n          J_data_1[idxStart_4Row] = m_tmp;\n          J_data_2[O_Htm_tmp + 6 * i] = m_tmp;\n        }\n      }\n\n      for (i = 0; i < 3; i++) {\n        m_1[6 * i] = jointOrigins[3 * i] * m;\n        O_Htm_tmp = (i + 3) * 6;\n        m_1[O_Htm_tmp] = -b_tmp[i];\n        m_1[6 * i + 3] = b_tmp[3 * i];\n        m_1[O_Htm_tmp + 3] = tmp2[3 * i] - tmp2[i];\n        idxStart_6Row = 3 * i + 1;\n        m_1[6 * i + 1] = jointOrigins[idxStart_6Row] * m;\n        m_1[O_Htm_tmp + 1] = -b_tmp[i + 3];\n        m_1[6 * i + 4] = b_tmp[idxStart_6Row];\n        m_1[O_Htm_tmp + 4] = tmp2[idxStart_6Row] - tmp2[i + 3];\n        idxStart_6Row = 3 * i + 2;\n        m_1[6 * i + 2] = jointOrigins[idxStart_6Row] * m;\n        m_1[O_Htm_tmp + 2] = -b_tmp[i + 6];\n        m_1[6 * i + 5] = b_tmp[idxStart_6Row];\n        m_1[O_Htm_tmp + 5] = tmp2[idxStart_6Row] - tmp2[i + 6];\n      }\n\n      J_size_4[0] = 6;\n      J_size_4[1] = rtb_CC_0 + 1;\n      dJ_size[0] = 6;\n      dJ_size[1] = rtb_CC_0 + 1;\n      J_size_5[0] = 6;\n      J_size_5[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          idxStart_6Row = 6 * i + O_Htm_tmp;\n          m_tmp = J[idxStart_6Row];\n          idxStart_4Row = 6 * i + O_Htm_tmp;\n          J_data_3[idxStart_4Row] = m_tmp;\n          dJ_data[idxStart_4Row] = dJ[idxStart_6Row];\n          J_data_4[idxStart_4Row] = m_tmp;\n        }\n      }\n\n      for (i = 0; i < 3; i++) {\n        m_2[6 * i] = jointOrigins[3 * i] * m;\n        O_Htm_tmp = (i + 3) * 6;\n        m_2[O_Htm_tmp] = -b_tmp[i];\n        m_2[6 * i + 3] = b_tmp[3 * i];\n        m_2[O_Htm_tmp + 3] = tmp2[3 * i] - tmp2[i];\n        idxStart_6Row = 3 * i + 1;\n        m_2[6 * i + 1] = jointOrigins[idxStart_6Row] * m;\n        m_2[O_Htm_tmp + 1] = -b_tmp[i + 3];\n        m_2[6 * i + 4] = b_tmp[idxStart_6Row];\n        m_2[O_Htm_tmp + 4] = tmp2[idxStart_6Row] - tmp2[i + 3];\n        idxStart_6Row = 3 * i + 2;\n        m_2[6 * i + 2] = jointOrigins[idxStart_6Row] * m;\n        m_2[O_Htm_tmp + 2] = -b_tmp[i + 6];\n        m_2[6 * i + 5] = b_tmp[idxStart_6Row];\n        m_2[O_Htm_tmp + 5] = tmp2[idxStart_6Row] - tmp2[i + 6];\n      }\n\n      J_size_6[0] = 6;\n      J_size_6[1] = rtb_CC_0 + 1;\n      dJ_size_0[0] = 6;\n      dJ_size_0[1] = rtb_CC_0 + 1;\n      for (i = 0; i <= rtb_CC_0; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n          idxStart_6Row = 6 * i + O_Htm_tmp;\n          J_data_5[idxStart_6Row] = J[idxStart_6Row];\n          dJ_data_0[idxStart_6Row] = dJ[idxStart_6Row];\n        }\n      }\n\n      custom_scara_fd_mtimes_mnik(J_pre, J_size, invAd, tmp_data_1, tmp_size_5);\n      custom_scara_fd_mtimes_mni(tmp_data_1, tmp_size_5, J_data, J_size_0, b_y,\n        tmp_size_4);\n      custom_scara_fd_mtimes_mnik(J_data_0, J_size_1, m_0, tmp_data_1,\n        tmp_size_5);\n      custom_scara_fd_mtimes_mni(tmp_data_1, tmp_size_5, J_data_1, J_size_2, b_y,\n        tmp_size_0);\n      custom_scara_fd_mtimes_mnik(J_data_2, J_size_3, m_1, tmp_data_1,\n        tmp_size_5);\n      custom_scara_fd_mtimes_mni(tmp_data_1, tmp_size_5, J_data_3, J_size_4, b_y,\n        tmp_size_1);\n      custom_scara_fd_mtimes_mni(dJ_pre, Htm_size, dJ_data, dJ_size, b_y,\n        tmp_size_5);\n      custom_scara_fd_mtimes_mnik(J_data_4, J_size_5, m_2, tmp_data_1,\n        tmp_size_2);\n      custom_scara_fd_mtimes_mni(tmp_data_1, tmp_size_2, J_data_5, J_size_6, b_y,\n        tmp_size_3);\n      custom_scara_fd_mtimes_mni(dJ_pre, Htm_size, dJ_data_0, dJ_size_0, b_y,\n        tmp_size_2);\n      if ((rtb_CC_0 + 1 == tmp_size_4[0]) && (rtb_CC_0 + 1 == tmp_size_0[1]) &&\n          ((rtb_CC_0 + 1 == 1 ? tmp_size_1[0] : rtb_CC_0 + 1) == tmp_size_5[0]) &&\n          ((rtb_CC_0 + 1 == 1 ? tmp_size_3[1] : rtb_CC_0 + 1) == tmp_size_2[1]))\n      {\n        J_size[0] = 6;\n        J_size[1] = rtb_CC_0 + 1;\n        for (i = 0; i <= rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            J_pre[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n          }\n        }\n\n        for (i = 0; i < 3; i++) {\n          invAd[6 * i] = jointOrigins[3 * i] * m;\n          O_Htm_tmp = (i + 3) * 6;\n          invAd[O_Htm_tmp] = -b_tmp[i];\n          invAd[6 * i + 3] = b_tmp[3 * i];\n          invAd[O_Htm_tmp + 3] = tmp2[3 * i] - tmp2[i];\n          idxStart_6Row = 3 * i + 1;\n          invAd[6 * i + 1] = jointOrigins[idxStart_6Row] * m;\n          invAd[O_Htm_tmp + 1] = -b_tmp[i + 3];\n          invAd[6 * i + 4] = b_tmp[idxStart_6Row];\n          invAd[O_Htm_tmp + 4] = tmp2[idxStart_6Row] - tmp2[i + 3];\n          idxStart_6Row = 3 * i + 2;\n          invAd[6 * i + 2] = jointOrigins[idxStart_6Row] * m;\n          invAd[O_Htm_tmp + 2] = -b_tmp[i + 6];\n          invAd[6 * i + 5] = b_tmp[idxStart_6Row];\n          invAd[O_Htm_tmp + 5] = tmp2[idxStart_6Row] - tmp2[i + 6];\n        }\n\n        J_size_0[0] = 6;\n        J_size_0[1] = rtb_CC_0 + 1;\n        for (i = 0; i <= rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            J_data[O_Htm_tmp + 6 * i] = J[6 * i + O_Htm_tmp];\n          }\n        }\n\n        custom_scara_fd_mtimes_mnik(J_pre, J_size, invAd, tmp_data_1, tmp_size_4);\n        custom_scara_fd_mtimes_mni(tmp_data_1, tmp_size_4, J_data, J_size_0, b_y,\n          tmp_size_5);\n        dJ_size[0] = 6;\n        dJ_size[1] = rtb_CC_0 + 1;\n        for (i = 0; i <= rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < 6; O_Htm_tmp++) {\n            dJ_data[O_Htm_tmp + 6 * i] = dJ[6 * i + O_Htm_tmp];\n          }\n        }\n\n        custom_scara_fd_mtimes_mni(dJ_pre, Htm_size, dJ_data, dJ_size,\n          jointOrigins, tmp_size_4);\n        idxStart_6Row = rtb_CC_0 + 1;\n        idxStart_4Row = rtb_CC_0 + 1;\n        for (i = 0; i <= rtb_CC_0; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp <= rtb_CC_0; O_Htm_tmp++) {\n            tmp2[O_Htm_tmp + (rtb_CC_0 + 1) * i] = (rtb_CC[3 * i + O_Htm_tmp] +\n              b_y[tmp_size_5[0] * i + O_Htm_tmp]) + jointOrigins[tmp_size_4[0] *\n              i + O_Htm_tmp];\n          }\n        }\n\n        for (i = 0; i < idxStart_4Row; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp < idxStart_6Row; O_Htm_tmp++) {\n            rtb_CC[O_Htm_tmp + 3 * i] = tmp2[(rtb_CC_0 + 1) * i + O_Htm_tmp];\n          }\n        }\n      } else {\n        custom_scara_binary_expand_op_i(rtb_CC, rtb_CC_0, J, m, jointOrigins,\n          b_tmp, tmp2, dJ_pre, Htm_size, dJ);\n      }\n\n      tmp_size[0] = rtb_CC_0 + 1;\n      tmp_size[1] = 3;\n      for (i = 0; i < 3; i++) {\n        for (O_Htm_tmp = 0; O_Htm_tmp <= rtb_CC_0; O_Htm_tmp++) {\n          b_y[O_Htm_tmp + (rtb_CC_0 + 1) * i] = dJ_pre[Htm_size[0] * i +\n            O_Htm_tmp];\n        }\n\n        O_Htm_tmp_0 = i << 2;\n        jointOrigins[3 * i] = O_Htm[O_Htm_tmp_0];\n        jointOrigins[3 * i + 1] = O_Htm[O_Htm_tmp_0 + 1];\n        jointOrigins[3 * i + 2] = O_Htm[O_Htm_tmp_0 + 2];\n      }\n\n      custom_scara_fd_mtimes_mnik3(b_y, tmp_size, jointOrigins, tmp2, tmp_size_5);\n      custom_scara_fd_mtimes_mnik3n(tmp2, tmp_size_5, tmp_data_0, &i);\n      if (rtb_CC_0 + 1 == i) {\n        tmp_size[0] = rtb_CC_0 + 1;\n        tmp_size[1] = 3;\n        for (i = 0; i < 3; i++) {\n          for (O_Htm_tmp = 0; O_Htm_tmp <= rtb_CC_0; O_Htm_tmp++) {\n            b_y[O_Htm_tmp + (rtb_CC_0 + 1) * i] = dJ_pre[Htm_size[0] * i +\n              O_Htm_tmp];\n          }\n\n          O_Htm_tmp_0 = i << 2;\n          jointOrigins[3 * i] = O_Htm[O_Htm_tmp_0];\n          jointOrigins[3 * i + 1] = O_Htm[O_Htm_tmp_0 + 1];\n          jointOrigins[3 * i + 2] = O_Htm[O_Htm_tmp_0 + 2];\n        }\n\n        custom_scara_fd_mtimes_mnik3(b_y, tmp_size, jointOrigins, tmp2, Htm_size);\n        custom_scara_fd_mtimes_mnik3n(tmp2, Htm_size, tmp_data_0, &i);\n        O_Htm_tmp = rtb_CC_0 + 1;\n        for (i = 0; i < O_Htm_tmp; i++) {\n          rtb_g_data[i] = rtb_g[i] + tmp_data_0[i];\n        }\n\n        std::memcpy(&rtb_g[0], &rtb_g_data[0], static_cast<uint32_T>(rtb_CC_0 +\n          1) * sizeof(real_T));\n      } else {\n        custom_scara_f_binary_expand_op(rtb_g, rtb_CC_0, dJ_pre, Htm_size, O_Htm);\n      }\n\n      std::memcpy(&J_pre[0], &J[0], 18U * sizeof(real_T));\n      std::memcpy(&dJ_pre[0], &dJ[0], 18U * sizeof(real_T));\n      for (i = 0; i < 6; i++) {\n        inertialTwist_pre[i] = inertialTwist[i];\n      }\n\n      std::memcpy(&O_Htm_pre[0], &O_Htm[0], sizeof(real_T) << 4U);\n    }\n\n    for (i = 0; i < 3; i++) {\n      rtb_CC_0 = i << 2;\n      O_Htm_pre[rtb_CC_0] = E_tmp[3 * i];\n      O_Htm_pre[rtb_CC_0 + 1] = E_tmp[3 * i + 1];\n      O_Htm_pre[rtb_CC_0 + 2] = E_tmp[3 * i + 2];\n    }\n\n    O_Htm_pre[12] = custom_scara_fd_U.arm_length[2];\n    O_Htm_pre[13] = 0.0;\n    O_Htm_pre[14] = 0.0;\n    O_Htm_pre[3] = 0.0;\n    O_Htm_pre[7] = 0.0;\n    O_Htm_pre[11] = 0.0;\n    O_Htm_pre[15] = 1.0;\n    for (i = 0; i < 4; i++) {\n      rtb_CC_0 = i << 2;\n      m_tmp = O_Htm_pre[rtb_CC_0 + 1];\n      m = O_Htm_pre[rtb_CC_0];\n      b_m = O_Htm_pre[rtb_CC_0 + 2];\n      c_m = O_Htm_pre[rtb_CC_0 + 3];\n      for (O_Htm_tmp = 0; O_Htm_tmp < 4; O_Htm_tmp++) {\n        O_Htm_0[O_Htm_tmp + rtb_CC_0] = ((O_Htm[O_Htm_tmp + 4] * m_tmp + m *\n          O_Htm[O_Htm_tmp]) + O_Htm[O_Htm_tmp + 8] * b_m) + O_Htm[O_Htm_tmp + 12]\n          * c_m;\n      }\n    }\n\n    /* Outport: '<Root>/TCP_pos' incorporates:\n     *  MATLAB Function: '<S1>/calcSysMatrices'\n     */\n    custom_scara_fd_Y.TCP_pos[0] = O_Htm_0[12];\n    custom_scara_fd_Y.TCP_pos[1] = O_Htm_0[13];\n    custom_scara_fd_Y.TCP_pos[2] = O_Htm_0[14];\n\n    /* Derivative: '<S1>/Derivative1' incorporates:\n     *  Derivative: '<S1>/Derivative'\n     */\n    m = (&custom_scara_fd_M)->Timing.t[0];\n    if ((custom_scara_fd_DW.TimeStampA >= m) && (custom_scara_fd_DW.TimeStampB >=\n         m)) {\n      /* Derivative: '<S1>/Derivative1' */\n      custom_scara_fd_B.Derivative1[0] = 0.0;\n      custom_scara_fd_B.Derivative1[1] = 0.0;\n      custom_scara_fd_B.Derivative1[2] = 0.0;\n    } else {\n      Iz = custom_scara_fd_DW.TimeStampA;\n      lastU = &custom_scara_fd_DW.LastUAtTimeA;\n      if (custom_scara_fd_DW.TimeStampA < custom_scara_fd_DW.TimeStampB) {\n        if (custom_scara_fd_DW.TimeStampB < m) {\n          Iz = custom_scara_fd_DW.TimeStampB;\n          lastU = &custom_scara_fd_DW.LastUAtTimeB;\n        }\n      } else if (custom_scara_fd_DW.TimeStampA >= m) {\n        Iz = custom_scara_fd_DW.TimeStampB;\n        lastU = &custom_scara_fd_DW.LastUAtTimeB;\n      }\n\n      Iz = m - Iz;\n\n      /* Derivative: '<S1>/Derivative1' incorporates:\n       *  Outport: '<Root>/TCP_pos'\n       */\n      custom_scara_fd_B.Derivative1[0] = (custom_scara_fd_Y.TCP_pos[0] - (*lastU)\n        [0]) / Iz;\n      custom_scara_fd_B.Derivative1[1] = (custom_scara_fd_Y.TCP_pos[1] - (*lastU)\n        [1]) / Iz;\n      custom_scara_fd_B.Derivative1[2] = (custom_scara_fd_Y.TCP_pos[2] - (*lastU)\n        [2]) / Iz;\n    }\n\n    /* Derivative: '<S1>/Derivative' */\n    if ((custom_scara_fd_DW.TimeStampA_b >= m) &&\n        (custom_scara_fd_DW.TimeStampB_g >= m)) {\n      /* Outport: '<Root>/TCP_acc' */\n      custom_scara_fd_Y.TCP_acc[0] = 0.0;\n      custom_scara_fd_Y.TCP_acc[1] = 0.0;\n      custom_scara_fd_Y.TCP_acc[2] = 0.0;\n    } else {\n      Iz = custom_scara_fd_DW.TimeStampA_b;\n      lastU = &custom_scara_fd_DW.LastUAtTimeA_d;\n      if (custom_scara_fd_DW.TimeStampA_b < custom_scara_fd_DW.TimeStampB_g) {\n        if (custom_scara_fd_DW.TimeStampB_g < m) {\n          Iz = custom_scara_fd_DW.TimeStampB_g;\n          lastU = &custom_scara_fd_DW.LastUAtTimeB_p;\n        }\n      } else if (custom_scara_fd_DW.TimeStampA_b >= m) {\n        Iz = custom_scara_fd_DW.TimeStampB_g;\n        lastU = &custom_scara_fd_DW.LastUAtTimeB_p;\n      }\n\n      Iz = m - Iz;\n\n      /* Outport: '<Root>/TCP_acc' */\n      custom_scara_fd_Y.TCP_acc[0] = (custom_scara_fd_B.Derivative1[0] - (*lastU)\n        [0]) / Iz;\n      custom_scara_fd_Y.TCP_acc[1] = (custom_scara_fd_B.Derivative1[1] - (*lastU)\n        [1]) / Iz;\n      custom_scara_fd_Y.TCP_acc[2] = (custom_scara_fd_B.Derivative1[2] - (*lastU)\n        [2]) / Iz;\n    }\n\n    /* Product: '<S1>/Product5' */\n    rt_invd3x3_snf(S, tmp);\n\n    /* Product: '<S1>/Product3' incorporates:\n     *  Inport: '<Root>/dq'\n     */\n    m_tmp = custom_scara_fd_U.joint_vel[1];\n    m = custom_scara_fd_U.joint_vel[0];\n    b_m = custom_scara_fd_U.joint_vel[2];\n\n    /* Sum: '<S1>/Sum4' incorporates:\n     *  Inport: '<Root>/joint_torque'\n     *  Product: '<S1>/Product3'\n     */\n    for (i = 0; i < 3; i++) {\n      tmp_data_0[i] = (custom_scara_fd_U.joint_torque[i] - ((rtb_CC[i + 3] *\n        m_tmp + rtb_CC[i] * m) + rtb_CC[i + 6] * b_m)) - rtb_g[i];\n    }\n\n    /* End of Sum: '<S1>/Sum4' */\n\n    /* Product: '<S1>/Product1' */\n    m_tmp = tmp_data_0[1];\n    m = tmp_data_0[0];\n    b_m = tmp_data_0[2];\n\n    /* End of Outputs for SubSystem: '<Root>/custom_scara_fd' */\n    for (i = 0; i < 3; i++) {\n      /* Outputs for Atomic SubSystem: '<Root>/custom_scara_fd' */\n      /* Outport: '<Root>/joint_acc' incorporates:\n       *  Product: '<S1>/Product1'\n       */\n      custom_scara_fd_Y.joint_acc[i] = (tmp[i + 3] * m_tmp + tmp[i] * m) + tmp[i\n        + 6] * b_m;\n\n      /* End of Outputs for SubSystem: '<Root>/custom_scara_fd' */\n\n      /* Outport: '<Root>/TCP_vel' */\n      custom_scara_fd_Y.TCP_vel[i] = custom_scara_fd_B.Derivative1[i];\n    }\n  }\n\n  {\n    real_T (*lastU)[3];\n\n    /* Update for Atomic SubSystem: '<Root>/custom_scara_fd' */\n    /* Update for Derivative: '<S1>/Derivative1' incorporates:\n     *  Outport: '<Root>/TCP_pos'\n     */\n    if (custom_scara_fd_DW.TimeStampA == (rtInf)) {\n      custom_scara_fd_DW.TimeStampA = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeA;\n    } else if (custom_scara_fd_DW.TimeStampB == (rtInf)) {\n      custom_scara_fd_DW.TimeStampB = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeB;\n    } else if (custom_scara_fd_DW.TimeStampA < custom_scara_fd_DW.TimeStampB) {\n      custom_scara_fd_DW.TimeStampA = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeA;\n    } else {\n      custom_scara_fd_DW.TimeStampB = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeB;\n    }\n\n    (*lastU)[0] = custom_scara_fd_Y.TCP_pos[0];\n    (*lastU)[1] = custom_scara_fd_Y.TCP_pos[1];\n    (*lastU)[2] = custom_scara_fd_Y.TCP_pos[2];\n\n    /* End of Update for Derivative: '<S1>/Derivative1' */\n\n    /* Update for Derivative: '<S1>/Derivative' */\n    if (custom_scara_fd_DW.TimeStampA_b == (rtInf)) {\n      custom_scara_fd_DW.TimeStampA_b = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeA_d;\n    } else if (custom_scara_fd_DW.TimeStampB_g == (rtInf)) {\n      custom_scara_fd_DW.TimeStampB_g = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeB_p;\n    } else if (custom_scara_fd_DW.TimeStampA_b < custom_scara_fd_DW.TimeStampB_g)\n    {\n      custom_scara_fd_DW.TimeStampA_b = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeA_d;\n    } else {\n      custom_scara_fd_DW.TimeStampB_g = (&custom_scara_fd_M)->Timing.t[0];\n      lastU = &custom_scara_fd_DW.LastUAtTimeB_p;\n    }\n\n    (*lastU)[0] = custom_scara_fd_B.Derivative1[0];\n    (*lastU)[1] = custom_scara_fd_B.Derivative1[1];\n    (*lastU)[2] = custom_scara_fd_B.Derivative1[2];\n\n    /* End of Update for Derivative: '<S1>/Derivative' */\n    /* End of Update for SubSystem: '<Root>/custom_scara_fd' */\n  }\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   */\n  (&custom_scara_fd_M)->Timing.t[0] =\n    ((time_T)(++(&custom_scara_fd_M)->Timing.clockTick0)) * (&custom_scara_fd_M\n    )->Timing.stepSize0;\n\n  {\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The resolution of this integer timer is 0.001, which is the step size\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n     * application lifespan selected.\n     */\n    (&custom_scara_fd_M)->Timing.clockTick1++;\n  }\n}\n\n/* Model initialize function */\nvoid custom_scara_fd::initialize()\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&(&custom_scara_fd_M)->solverInfo,\n                          &(&custom_scara_fd_M)->Timing.simTimeStep);\n    rtsiSetTPtr(&(&custom_scara_fd_M)->solverInfo, &rtmGetTPtr\n                ((&custom_scara_fd_M)));\n    rtsiSetStepSizePtr(&(&custom_scara_fd_M)->solverInfo, &(&custom_scara_fd_M\n                       )->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&(&custom_scara_fd_M)->solverInfo, (&rtmGetErrorStatus\n      ((&custom_scara_fd_M))));\n    rtsiSetRTModelPtr(&(&custom_scara_fd_M)->solverInfo, (&custom_scara_fd_M));\n  }\n\n  rtsiSetSimTimeStep(&(&custom_scara_fd_M)->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetSolverName(&(&custom_scara_fd_M)->solverInfo,\"FixedStepDiscrete\");\n  rtmSetTPtr((&custom_scara_fd_M), &(&custom_scara_fd_M)->Timing.tArray[0]);\n  (&custom_scara_fd_M)->Timing.stepSize0 = 0.001;\n\n  /* SystemInitialize for Atomic SubSystem: '<Root>/custom_scara_fd' */\n  /* InitializeConditions for Derivative: '<S1>/Derivative1' */\n  custom_scara_fd_DW.TimeStampA = (rtInf);\n  custom_scara_fd_DW.TimeStampB = (rtInf);\n\n  /* InitializeConditions for Derivative: '<S1>/Derivative' */\n  custom_scara_fd_DW.TimeStampA_b = (rtInf);\n  custom_scara_fd_DW.TimeStampB_g = (rtInf);\n\n  /* End of SystemInitialize for SubSystem: '<Root>/custom_scara_fd' */\n}\n\n/* Model terminate function */\nvoid custom_scara_fd::terminate()\n{\n  /* (no terminate code required) */\n}\n\n/* Constructor */\ncustom_scara_fd::custom_scara_fd() :\n  custom_scara_fd_U(),\n  custom_scara_fd_Y(),\n  custom_scara_fd_B(),\n  custom_scara_fd_DW(),\n  custom_scara_fd_M()\n{\n  /* Currently there is no constructor body generated.*/\n}\n\n/* Destructor */\n/* Currently there is no destructor body generated.*/\ncustom_scara_fd::~custom_scara_fd() = default;\n\n/* Real-Time Model get method */\nRT_MODEL_custom_scara_fd_T * custom_scara_fd::getRTM()\n{\n  return (&custom_scara_fd_M);\n}\n"},{"name":"custom_scara_fd.h","type":"header","group":"model","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * custom_scara_fd.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_custom_scara_fd_h_\n#define RTW_HEADER_custom_scara_fd_h_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"custom_scara_fd_types.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n/* Block signals (default storage) */\nstruct B_custom_scara_fd_T {\n  real_T Derivative1[3];               /* '<S1>/Derivative1' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_custom_scara_fd_T {\n  real_T TimeStampA;                   /* '<S1>/Derivative1' */\n  real_T LastUAtTimeA[3];              /* '<S1>/Derivative1' */\n  real_T TimeStampB;                   /* '<S1>/Derivative1' */\n  real_T LastUAtTimeB[3];              /* '<S1>/Derivative1' */\n  real_T TimeStampA_b;                 /* '<S1>/Derivative' */\n  real_T LastUAtTimeA_d[3];            /* '<S1>/Derivative' */\n  real_T TimeStampB_g;                 /* '<S1>/Derivative' */\n  real_T LastUAtTimeB_p[3];            /* '<S1>/Derivative' */\n  real_T Product5_DWORK4[9];           /* '<S1>/Product5' */\n};\n\n/* External inputs (root inport signals with default storage) */\nstruct ExtU_custom_scara_fd_T {\n  real_T joint_torque[3];              /* '<Root>/joint_torque' */\n  real_T rho;                          /* '<Root>/rho' */\n  real_T arm_link_radius;              /* '<Root>/arm_link_radius' */\n  real_T arm_length[3];                /* '<Root>/arm_length' */\n  real_T joint_pos[3];                 /* '<Root>/q' */\n  real_T joint_vel[3];                 /* '<Root>/dq' */\n};\n\n/* External outputs (root outports fed by signals with default storage) */\nstruct ExtY_custom_scara_fd_T {\n  real_T joint_acc[3];                 /* '<Root>/joint_acc' */\n  real_T TCP_pos[3];                   /* '<Root>/TCP_pos' */\n  real_T TCP_vel[3];                   /* '<Root>/TCP_vel' */\n  real_T TCP_acc[3];                   /* '<Root>/TCP_acc' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_custom_scara_fd_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    SimTimeStep simTimeStep;\n    time_T *t;\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Class declaration for model custom_scara_fd */\nclass custom_scara_fd final\n{\n  /* public data and function members */\n public:\n  /* Copy Constructor */\n  custom_scara_fd(custom_scara_fd const&) = delete;\n\n  /* Assignment Operator */\n  custom_scara_fd& operator= (custom_scara_fd const&) & = delete;\n\n  /* Move Constructor */\n  custom_scara_fd(custom_scara_fd &&) = delete;\n\n  /* Move Assignment Operator */\n  custom_scara_fd& operator= (custom_scara_fd &&) = delete;\n\n  /* Real-Time Model get method */\n  RT_MODEL_custom_scara_fd_T * getRTM();\n\n  /* External inputs */\n  ExtU_custom_scara_fd_T custom_scara_fd_U;\n\n  /* External outputs */\n  ExtY_custom_scara_fd_T custom_scara_fd_Y;\n\n  /* Initial conditions function */\n  void initialize();\n\n  /* model step function */\n  void step();\n\n  /* model terminate function */\n  static void terminate();\n\n  /* Constructor */\n  custom_scara_fd();\n\n  /* Destructor */\n  ~custom_scara_fd();\n\n  /* private data and function members */\n private:\n  /* Block signals */\n  B_custom_scara_fd_T custom_scara_fd_B;\n\n  /* Block states */\n  DW_custom_scara_fd_T custom_scara_fd_DW;\n\n  /* private member function(s) for subsystem '<Root>'*/\n  void custom_scara_fd_eye(real_T b_I[9]);\n  void custom_scara_fd_diag(const real_T v[3], real_T d[9]);\n  void custom_scara_fd_repmat(real_T b[18]);\n  boolean_T custom_scara_fd_all(const boolean_T x[3]);\n  void custom_scara_fd_mtimes(const real_T A_data[], const int32_T A_size[2],\n    const real_T B[16], real_T C_data[], int32_T C_size[2]);\n  void custom_scara_fd_mtimes_m(const real_T A[36], const real_T B_data[], const\n    int32_T B_size[2], real_T C_data[], int32_T C_size[2]);\n  void custom_sca_binary_expand_op_ih2(real_T in1[18], int32_T in2, const real_T\n    in3[36], const real_T in4[18], const real_T in5[9], const real_T in6[6],\n    const real_T in7[18]);\n  void custom_scara_fd_mtimes_mn(const real_T A_data[], const int32_T A_size[2],\n    const real_T B_data[], const int32_T B_size[2], real_T C_data[], int32_T\n    C_size[2]);\n  void custom_scara_fd_mtimes_mni(const real_T A_data[], const int32_T A_size[2],\n    const real_T B_data[], const int32_T B_size[2], real_T C_data[], int32_T\n    C_size[2]);\n  void custom_scar_binary_expand_op_ih(real_T in1[9], int32_T in2, const real_T\n    in3_data[], const int32_T in3_size[2], const real_T in4[18]);\n  void custom_scara_fd_mtimes_mnik(const real_T A_data[], const int32_T A_size[2],\n    const real_T B[36], real_T C_data[], int32_T C_size[2]);\n  void custom_scara_binary_expand_op_i(real_T in1[9], int32_T in2, const real_T\n    in3[18], real_T in4, const real_T in5[9], const real_T in6[9], const real_T\n    in7[9], const real_T in8_data[], const int32_T in8_size[2], const real_T\n    in9[18]);\n  void custom_scara_fd_mtimes_mnik3(const real_T A_data[], const int32_T A_size\n    [2], const real_T B[9], real_T C_data[], int32_T C_size[2]);\n  void custom_scara_fd_mtimes_mnik3n(const real_T A_data[], const int32_T\n    A_size[2], real_T C_data[], int32_T *C_size);\n  void custom_scara_f_binary_expand_op(real_T in1[3], int32_T in2, const real_T\n    in3_data[], const int32_T in3_size[2], const real_T in4[16]);\n\n  /* Real-Time Model */\n  RT_MODEL_custom_scara_fd_T custom_scara_fd_M;\n};\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Note that this particular code originates from a subsystem build,\n * and has its own system numbers different from the parent model.\n * Refer to the system hierarchy for this subsystem below, and use the\n * MATLAB hilite_system command to trace the generated code back\n * to the parent model.  For example,\n *\n * hilite_system('custom_forward_dynamics/custom_scara_fd')    - opens subsystem custom_forward_dynamics/custom_scara_fd\n * hilite_system('custom_forward_dynamics/custom_scara_fd/Kp') - opens and selects block Kp\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'custom_forward_dynamics'\n * '<S1>'   : 'custom_forward_dynamics/custom_scara_fd'\n * '<S2>'   : 'custom_forward_dynamics/custom_scara_fd/calcSysMatrices'\n */\n#endif                                 /* RTW_HEADER_custom_scara_fd_h_ */\n"},{"name":"custom_scara_fd_private.h","type":"header","group":"model","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * custom_scara_fd_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_custom_scara_fd_private_h_\n#define RTW_HEADER_custom_scara_fd_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"custom_scara_fd_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern void rt_invd3x3_snf(const real_T u[9], real_T y[9]);\n\n#endif                               /* RTW_HEADER_custom_scara_fd_private_h_ */\n"},{"name":"custom_scara_fd_types.h","type":"header","group":"model","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * custom_scara_fd_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_custom_scara_fd_types_h_\n#define RTW_HEADER_custom_scara_fd_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_custom_scara_fd_T RT_MODEL_custom_scara_fd_T;\n\n#endif                                 /* RTW_HEADER_custom_scara_fd_types_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T inf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T minf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one{ 1U };\n\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T nan{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder\n{\n        (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n      };\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF{ { 0.0F } };\n\n    uint16_T one{ 1U };\n\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder\n{\n      (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian\n    };\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result{ (boolean_T) 0 };\n\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/divij/Documents/quadopter/robot/custom_scara_fd_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"custom_scara_fd\".\n *\n * Model version              : 12.44\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 23 05:14:10 2023\n *\n * Target selection: grt.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Debugging\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"custom_scara_fd.h\"\n#define MODEL_CLASSNAME                custom_scara_fd\n#define MODEL_STEPNAME                 step\n#define GRTINTERFACE                   0\n\n/*\n * ROOT_IO_FORMAT: 0 (Individual arguments)\n * ROOT_IO_FORMAT: 1 (Structure reference)\n * ROOT_IO_FORMAT: 2 (Part of model data structure)\n */\n#define ROOT_IO_FORMAT                 2\n\n/* Macros generated for backwards compatibility  */\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((void*) 0)\n#endif\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};